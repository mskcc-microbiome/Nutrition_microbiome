---
title: "Adjust for cancer type, transplant origin, and baseline health status"
output: html_document
date: "2025-09-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(tidyverse)
library(cowplot)
library(broom.mixed)
library(brms)   
library(ggpubr)
library(tidybayes)
library(brmstools)
library(bayesplot)
library(gt)
library(rcompanion)
library(janitor)
library(ggtext)
rstan::rstan_options(auto_write = TRUE)
theme_set(theme_tidybayes() + panel_border())
```



```{r}
df_pt <- read_rds('../data/R02_cleaned_clinical_outcome.rds') %>% select(pid, source, intensity, gvhd_ppx, disease.simple) %>% janitor::clean_names()

meta <- read_csv('../data/153_combined_META.csv') %>% 
  mutate(intensity = factor(intensity, levels = c('nonablative','reduced','ablative'))) %>%
  mutate(pid = factor(pid)) %>%
    # This divides all the new intake columns by 100.
  mutate(across(starts_with("fg_"), ~ .x / 100))

ptb <- read_csv('../../MSS_pipeline-/scripts/food_tree/data/156_combined_PTB_original.csv')
```

```{r}
# to see if I have the HCT CI data 
# HCT-CI is a well-validated scoring system designed specifically to predict outcomes in HCT patients by quantifying pre-transplant comorbidities. It is the standard in the field.
library(vdbR) 
connect_database()
link <- read_csv('../../MSS_pipeline-/scripts/food_tree/data/152_pid_match.csv')
list_table_from_database('Comorbidity')
get_table_from_database('comorbidity_index_ag')
get_table_from_database('patients_msk_comorbidity_index_ag')
get_table_from_database('current_clinical_pull_through_2024')
```

# HCT CI

```{r}
df_ci <- patients_msk_comorbidity_index_ag %>% 
  inner_join(ptb %>% select(mrn, hct)) %>% 
  select(mrn:ci_age_adjusted)

msk_multi <- comorbidity_index_ag %>% 
  filter(institution == 'MSKCC') %>% 
  mutate(mrn = as.numeric(patient_id)) %>% 
  inner_join(ptb %>% select(mrn, hct))

length(intersect(msk_multi$mrn, df_ci$mrn))

found <- current_clinical_pull_through_2024 %>% clean_names() %>% 
  mutate(mrn = as.numeric(mrn)) %>% 
  select(mrn, hct,hct_ci_total_score ) %>% 
  inner_join(ptb %>% select(mrn, hct)) %>% 
  inner_join(link) %>% 
  filter(pid %in% meta$pid) %>% 
  left_join(df_ci) %>% 
  arrange(pid)

# found %>% write_csv('../data/R43_diet_pt_CI_needed.csv')


```

## merging the CI from several sources   

```{r}
# merging in the few patients tsoni did the manual pull from chart
few <- read_csv('../data/still_missing_hct_ci_2025-10-01_manually_reviewed.csv') %>% 
  mutate(mrn = as.numeric(mrn), hct = mdy(hct), hct_ci_tsoni_manual = as.character(hct_ci_tsoni_manual))


cleaned_ci_data <- found %>%
  left_join(few) %>% 
  # Part 1: Create the cleaned CI column from the three sources.
  mutate(
    hct_ci_total_score = as.character(hct_ci_total_score),
    ci = as.character(ci),
    hct_ci_tsoni_manual = as.character(hct_ci_tsoni_manual),

    ci_cleaned = case_when(
      # Rule 1: Prioritize a valid number from 'hct_ci_total_score'.
      !is.na(as.numeric(hct_ci_total_score)) ~ hct_ci_total_score,
      # Rule 2: If the above is false, check for a valid number in 'ci'.
      !is.na(as.numeric(ci)) ~ ci,
      # Rule 3: If the above are false, check for a valid number in 'hct_ci_tsoni_manual'.
      !is.na(as.numeric(hct_ci_tsoni_manual)) ~ hct_ci_tsoni_manual,
      # Rule 4: ONLY if no number is found, check if a column contains "missing data".
      !is.na(hct_ci_total_score) & tolower(hct_ci_total_score) == "missing data" ~ "missing",
      # Rule 5 (Default): If none of the above rules are met, the value is NA.
      TRUE ~ NA_character_
    )
  ) %>%
  select(-age) %>% 
  inner_join(ptb %>% select(mrn, age)) %>% 
  # Part 2: Add the Age-Adjusted Column.
  # This calculates the age-adjusted score based on the cleaned CI value.
  mutate(
    # First, ensure both the cleaned CI and age columns are numeric for calculations.
    ci_cleaned_numeric = as.numeric(ci_cleaned),
    age = as.numeric(age),

    # Now, create the age-adjusted score using a case_when() statement.
    Age_adjusted_CI = case_when(
      # If either the cleaned score or age is NA, the result is NA.
      is.na(ci_cleaned_numeric) | is.na(age) ~ NA_real_,

      # Add 3 points for patients aged 60 or older.
      age >= 60 ~ ci_cleaned_numeric + 3,
      
      # Add 2 points for patients aged 50-59.
      age >= 50 ~ ci_cleaned_numeric + 2,
      
      # Add 1 point for patients aged 40-49.
      age >= 40 ~ ci_cleaned_numeric + 1,
      
      # For patients under 40, the score is not adjusted (it's the same as the cleaned score).
      TRUE ~ ci_cleaned_numeric
    )
  )
```

## model with CI included as a fixed effect

```{r}
# the meta table should remove the few patients that we don't have CI data 
meta_CI <- meta %>%
  left_join(cleaned_ci_data %>% select(pid, ci_cleaned, age, ci_cleaned_numeric, Age_adjusted_CI)) %>% 
  filter(!is.na(Age_adjusted_CI))

# how many samples from how many patients are removed 
rm_pt_num <- cleaned_ci_data %>% filter(is.na(ci_cleaned_numeric)) 
rm_pt_num %>% nrow

rm_samples_num <- meta %>% filter(pid %in% rm_pt_num$pid) 
```

## running model 

```{r}
all_food_vars <- meta_CI %>% select(starts_with('fg')) %>% colnames()

# Create the interaction terms for all food variables in this iteration
interaction_terms <- paste(all_food_vars, "empirical", sep = ":")

# Build the full formula string dynamically
formula_string <- paste(
  "log(simpson_reciprocal) ~ 0 + intensity + empirical + TPN + EN + Age_adjusted_CI +",
  paste(interaction_terms, collapse = " + "),
  "+ (1 | pid) + (1 | timebin)"
)

# Convert the string to a formula object
formula <- brms::bf(as.formula(formula_string))

# Build the priors by adding them together.
# This single prior() call applies to all coefficients listed in `all_food_coefs`.
priors <-
    prior(normal(0, 1), class = 'b') + # General prior for all food effects
    # Specific priors that override the general one for non-food covariates
    prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE") +
    prior(normal(0, 0.1), class = 'b', coef = "ENTRUE") +
    prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE") +
    prior(normal(2, .1), class = 'b', coef = "intensityablative") +
    prior(normal(2, .1), class = 'b', coef = "intensityreduced") +
    prior(normal(2, .1), class = 'b', coef = "intensitynonablative")

#Fit the model (using fewer iterations for this example to run quickly)
model_fit <- brm(
  formula = formula,
  data = meta_CI,
  prior = priors,
    warmup = 1000, iter = 3000,
    chains = 4, cores = 4,
    seed = 123,
    silent = 2,
  control = list(adapt_delta = 0.99)
)

results_df <- tidy(model_fit, conf.int = TRUE) %>%
  mutate(conf.low = round(conf.low, 2),
         conf.high = round(conf.high, 2))
```

## forest figure 

```{r}
# the above figure but make it the way the other figure look like
key <- read_csv('../data/food_group_color_key_final.csv', col_types = 'ccccc')

replacement_dictionary <- setNames(key$shortname, key$fg1_name)

level_order <- rev(c(
    "abx", "EN", "TPN", "Age adjusted CI",
    "abx * Sweets", "Sweets",
    "abx * Grains", "Grains",
    "abx * Milk", "Milk",
    "abx * Eggs", "Eggs",
    "abx * Legumes", "Legumes",
    "abx * Meats", "Meats",
    "abx * Fruits", "Fruits",
    "abx * Oils", "Oils",
    "abx * Vegetables", "Vegetables"
))

cleaned_effects <- results_df %>%
  # Keep only the fixed effects
  filter(effect == "fixed") %>%
  # Create a new column to distinguish main effects from interactions
  mutate(
    effect_type = if_else(str_detect(term, ":"), "Interaction", "Main Effect"),
    # Create clean labels for plotting
    clean_term = term %>%
      str_replace("empiricalTRUE$", "abx") %>%
      str_remove_all("empiricalFALSE:|avg_intake_|TRUE$") %>%
      str_replace_all( replacement_dictionary) %>%
      str_replace("empiricalTRUE:", "abx * ") %>%
      str_replace_all("_", " ")
  ) %>%
  filter(!str_detect(clean_term, 'intensity')) %>%
  # Create a new column to identify significant results
  # The condition is TRUE if conf.low and conf.high have the same sign (i.e., don't cross zero)
  mutate(is_significant = (conf.low * conf.high) >= 0) %>%
  mutate(clean_term = factor(clean_term, levels = level_order))

shading_df <- cleaned_effects %>%
  mutate(y_numeric = as.numeric(clean_term)) %>%
  filter(str_detect(clean_term, "\\*")) # Filter for interaction terms

plot_CI <- ggplot(cleaned_effects, aes(x = estimate, y = clean_term)) +
  geom_rect(
    data = shading_df,
    aes(ymin = y_numeric - 0.5, ymax = y_numeric + 0.5, xmin = -Inf, xmax = Inf),
    fill = "#FBEADC", # A light orange/peach color like the example
    alpha = 0.7,
    inherit.aes = FALSE
   ) +
   # Add a vertical line at zero, which represents "no effect"
  geom_vline(xintercept = 0, linetype = "solid", color = "blue",size = 0.8) +
   # Use geom_pointrange to show the estimate (point) and confidence interval (line)
   geom_pointrange(
   aes(xmin = conf.low, xmax = conf.high, color = is_significant),
     size = 0.25,linewidth = 1,
  ) +
  scale_color_manual(
    values = c(
      "TRUE" = "red",
      "FALSE" = "black"
    ), name = "Effect Status" # Legend title
  ) +
  scale_y_discrete( labels = function(x) { ifelse(str_detect(x, '\\*'),  str_glue("<b style='color:royalblue'>{x}</b>"), as.character(x)) }) +
  # Add labels and a clean theme
  labs(
    x = "ln(diversity) change",
    title = "Predictor effects on diversity",
    subtitle = "Sensitivity Analysis:\nControl for baseline health status\nby including the age-adjusted\ncomorbidity index",
    y = ''
  ) +
  theme_classic(base_size = 11) +
  theme(legend.position = "none", axis.text.y = element_markdown())

plot_CI
```


# correlation between intensity, graft source,  gvhd ppx

```{r}
df_pt_stool <- df_pt %>% 
  filter(pid %in% meta$pid)


# --- Association Analysis ---
# Get the names of the columns to analyze, excluding the patient ID.
cols_to_compare <- df_pt_stool %>%
  select(-pid, -disease_simple) %>%
  names()

# Generate all unique pairs of these column names.
# For 3 columns {A, B, C}, this creates pairs {A,B}, {A,C}, {B,C}.
column_pairs <- combn(cols_to_compare, 2, simplify = FALSE)

# Iterate over each pair of columns to calculate the association statistics.
# map_dfr automatically combines the results for each pair into a single data frame.
pairwise_associations <- map_dfr(column_pairs, ~{
  
  # Assign the column names for the current pair to var1 and var2 for clarity.
  var1 <- .x[1]
  var2 <- .x[2]
  
  # A Chi-squared test requires a contingency table (a frequency count of each combination).
  contingency_table <- table(df_pt_stool[[var1]], df_pt_stool[[var2]])
  
  # Switched to Fisher's Exact Test because of low expected counts in some cells,
  # which makes the Chi-squared approximation unreliable (and produces a warning).
  # Fisher's test calculates the exact p-value and is more accurate for small samples.
  # We use simulate.p.value for tables larger than 2x2 to get an accurate estimate.
  stat_test <- fisher.test(contingency_table, simulate.p.value = TRUE)
  
  # Calculate Cramér's V to measure the strength of the association.
  # This remains a valid and useful metric alongside Fisher's test.
  cramer_val <- cramerV(contingency_table)
  
  # Return the results for this pair as a single-row tibble (a modern data frame).
  tibble(
    Variable_1 = var1,
    Variable_2 = var2,
    p_value = stat_test$p.value,
    Cramers_V = cramer_val
  )
})

# --- Display Results ---
# Print the final table with all pairwise associations.
print(pairwise_associations)
```

## gt table 

```{r}
# --- Create the Polished GT Table ---
# This section takes the raw results and makes them publication-ready.

# Define the formal names for the variables.
formal_names <- c(
  "source" = "Graft Source",
  "intensity" = "Conditioning Intensity",
  "gvhd_ppx" = "GVHD Prophylaxis"
)

# Build the table.
association_gt_table <- pairwise_associations %>%
  # Clean up the variable names and manually format the p-value.
  mutate(
    Variable_1 = recode(Variable_1, !!!formal_names),
    Variable_2 = recode(Variable_2, !!!formal_names),
    # This replaces the numeric p-value with a formatted character string.
    p_value = if_else(p_value < 0.001, "<0.001", as.character(round(p_value, 3)))
  ) %>%
  # Start the gt table creation process.
  gt() %>%
  # Set the main title and subtitle.
  tab_header(
    title = md("**Association Between Clinical Transplant Variables**"),
    subtitle = "Assessing multicollinearity between key predictors"
  ) %>%
  # Define the column labels.
  cols_label(
    Variable_1 = md("**Variable 1**"),
    Variable_2 = md("**Variable 2**"),
    p_value = md("**p-value***"),
    Cramers_V = md("**Cramér's V**")
  ) %>%
  # Format the numeric columns for better readability.
  fmt_number(
    columns = Cramers_V,
    decimals = 3
  ) %>%
  # Add a source note to explain the statistics.
  tab_source_note(
    source_note = md("*p-value calculated using Fisher's Exact Test. Cramér's V measures the strength of association from 0 (none) to 1 (perfect).")
  ) %>%
  # Apply a clean, professional theme using a more compatible function.
  tab_options(
    table.border.top.style = "hidden",
    column_labels.border.bottom.style = "solid",
    column_labels.border.bottom.width = px(1.5),
    column_labels.border.bottom.color = "gray80",
    table_body.border.bottom.color = "gray80"
  ) %>%
  # Center the text in the columns.
  cols_align(
      align = "center",
      columns = everything()
  )%>% 
  gt::gtsave(filename = "../data/R43_three_var_correlation.png") 


```

# cancer type (disease)

```{r}
df_pt_stool_grouped <- df_pt_stool %>% 
  # Create a new column 'disease_lineage' based on the 'disease_simple' column.
  mutate(
    disease_lineage = case_when(
      # If the disease is in this list, classify it as 'Myeloid'.
      disease_simple %in% c("AML", "MDS/MPN", "CML") ~ "Myeloid",
      
      # If it's in this list, classify it as 'Lymphoid'.
      disease_simple %in% c("NHL", "ALL", "Myeloma", "CLL", "Hodgkins") ~ "Lymphoid",
      
      # For any other disease (like 'AA' or 'other'), assign NA.
      TRUE ~ NA_character_
    )
  ) %>%
  # Remove the rows where 'disease_lineage' is NA.
  # This cleanly excludes the patients you don't want in this specific analysis.
  filter(!is.na(disease_lineage))
```

```{r}
meta_disease <- meta %>% 
  inner_join(df_pt_stool_grouped %>% select(pid, disease_simple, disease_lineage)) %>% 
  mutate(disease_lineage = factor(disease_lineage))

# how many samples from how many patients are removed 
rm_pt_num <- df_pt_stool  %>% filter(disease_simple %in% c('AA','other')) 
rm_pt_num %>% nrow

rm_samples_num <- meta %>% filter(pid %in% rm_pt_num$pid) 
rm_samples_num %>% nrow
```

## running model 

```{r}
all_food_vars <- meta_disease %>% select(starts_with('fg')) %>% colnames()

# Create the interaction terms for all food variables in this iteration
interaction_terms <- paste(all_food_vars, "empirical", sep = ":")

# Build the full formula string dynamically
formula_string <- paste(
  "log(simpson_reciprocal) ~ 0 + intensity + empirical + TPN + EN + disease_lineage +",
  paste(interaction_terms, collapse = " + "),
  "+ (1 | pid) + (1 | timebin)"
)

# Convert the string to a formula object
formula <- brms::bf(as.formula(formula_string))

# Build the priors by adding them together.
# This single prior() call applies to all coefficients listed in `all_food_coefs`.
priors <-
    prior(normal(0, 1), class = 'b') + # General prior for all food effects
    # Specific priors that override the general one for non-food covariates
    prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE") +
    prior(normal(0, 0.1), class = 'b', coef = "ENTRUE") +
    prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE") +
    prior(normal(2, .1), class = 'b', coef = "intensityablative") +
    prior(normal(2, .1), class = 'b', coef = "intensityreduced") +
    prior(normal(2, .1), class = 'b', coef = "intensitynonablative")

#Fit the model (using fewer iterations for this example to run quickly)
model_fit <- brm(
  formula = formula,
  data = meta_disease,
  prior = priors,
    warmup = 1000, iter = 3000,
    chains = 4, cores = 4,
    seed = 123,
    silent = 2,
  control = list(adapt_delta = 0.99)
)

results_df_disease <- tidy(model_fit, conf.int = TRUE) %>%
  mutate(conf.low = round(conf.low, 2),
         conf.high = round(conf.high, 2))
```

## forest figure 

```{r}
# the above figure but make it the way the other figure look like
key <- read_csv('../data/food_group_color_key_final.csv', col_types = 'ccccc')

replacement_dictionary <- setNames(key$shortname, key$fg1_name)

level_order <- rev(c(
    "abx", "EN", "TPN", "Disease: Myeloid",
    "abx * Sweets", "Sweets",
    "abx * Grains", "Grains",
    "abx * Milk", "Milk",
    "abx * Eggs", "Eggs",
    "abx * Legumes", "Legumes",
    "abx * Meats", "Meats",
    "abx * Fruits", "Fruits",
    "abx * Oils", "Oils",
    "abx * Vegetables", "Vegetables"
))

cleaned_effects <- results_df_disease %>%
  # Keep only the fixed effects
  filter(effect == "fixed") %>%
  # Create a new column to distinguish main effects from interactions
  mutate(
    effect_type = if_else(str_detect(term, ":"), "Interaction", "Main Effect"),
    # Create clean labels for plotting
    clean_term = term %>%
      str_replace("empiricalTRUE$", "abx") %>%
      str_remove_all("empiricalFALSE:|avg_intake_|TRUE$") %>%
      str_replace_all( replacement_dictionary) %>%
      str_replace("empiricalTRUE:", "abx * ") %>%
      str_replace_all("_", " ") %>% 
      str_replace("disease lineageMyeloid", "Disease: Myeloid")
  ) %>%
  filter(!str_detect(clean_term, 'intensity')) %>%
  # Create a new column to identify significant results
  # The condition is TRUE if conf.low and conf.high have the same sign (i.e., don't cross zero)
  mutate(is_significant = (conf.low * conf.high) >= 0) %>%
  mutate(clean_term = factor(clean_term, levels = level_order))

shading_df <- cleaned_effects %>%
  mutate(y_numeric = as.numeric(clean_term)) %>%
  filter(str_detect(clean_term, "\\*")) # Filter for interaction terms

plot_disease <- ggplot(cleaned_effects, aes(x = estimate, y = clean_term)) +
  geom_rect(
    data = shading_df,
    aes(ymin = y_numeric - 0.5, ymax = y_numeric + 0.5, xmin = -Inf, xmax = Inf),
    fill = "#FBEADC", # A light orange/peach color like the example
    alpha = 0.7,
    inherit.aes = FALSE
   ) +
   # Add a vertical line at zero, which represents "no effect"
  geom_vline(xintercept = 0, linetype = "solid", color = "blue",size = 0.8) +
   # Use geom_pointrange to show the estimate (point) and confidence interval (line)
   geom_pointrange(
   aes(xmin = conf.low, xmax = conf.high, color = is_significant),
     size = 0.25,linewidth = 1,
  ) +
  scale_color_manual(
    values = c(
      "TRUE" = "red",
      "FALSE" = "black"
    ), name = "Effect Status" # Legend title
  ) +
  scale_y_discrete( labels = function(x) { ifelse(str_detect(x, '\\*'),  str_glue("<b style='color:royalblue'>{x}</b>"), as.character(x)) }) +
  # Add labels and a clean theme
  labs(
    x = "ln(diversity) change",
    title = "Predictor effects on diversity",
    subtitle = "Sensitivity Analysis:\nControl for disease lineage\n- Myeloid or Lymphoid\n",
    y = ''
  ) +
  theme_classic(base_size = 11) +
  theme(legend.position = "none", axis.text.y = element_markdown())

plot_disease
```

# assemble 

```{r}
table_cor <- ggdraw() + draw_image("../data/R43_three_var_correlation.png", scale = 1)

bottom <- plot_grid(plot_disease , plot_CI,
                ncol  = 2,
                labels = c('b', 'c'),
                align = 'vh', axis = 'lrtb')

final_plot <- plot_grid(table_cor , bottom,
                ncol  = 1,
                rel_heights = c(.6,1),
                labels = c('a', NA),
                align = 'vh', axis = 'lrtb')


title <- ggdraw() + 
  draw_label("Rebuttal Fig X",fontface = 'bold', x = 0,hjust = 0) +
  theme(plot.margin = margin(0, 0, 0, 0))

combined <- plot_grid(
  title, final_plot,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
) +theme(plot.margin = unit(c(1,1,1,1), "cm"))

ggsave('../data/R43_control_4_transplant_var.pdf',
      width = 8.5, height = 11, units = "in", device = 'pdf', 
      dpi = 300)       
```