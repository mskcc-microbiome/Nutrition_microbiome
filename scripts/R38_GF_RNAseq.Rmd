---
title: "GF mouse RNA-seq"
output: html_document
date: "2025-08-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(ggpubr)
library(edgeR)
library(DESeq2)
library(ggrepel)
library(cowplot)
library(patchwork)
library(ashr)
library(fgsea)       # For GSEA
library(msigdbr)     # To get MSigDB gene sets
library(AnnotationDbi)
library(org.Mm.eg.db)
library(ggupset)
library(pheatmap)      # For creating the heatmap
library(viridis)  
library(RColorBrewer) 
library(gridExtra)
library(tidyverse)
```

Basic gene annotation is the main annotation file for most users. To ensure that reads mapped to these alternate regions are correctly counted, I must use the "ALL" GTF file. (mouse genome)

# making the sample meta data info table

```{r}
# Read the raw counts file to get the column names.
counts_data <- read_tsv("../data/raw_counts_matrix.tsv") %>%
  rename_with(.fn = ~ str_remove(.,"_IGO_\\d+.+$"), .cols = 2:dplyr::last_col())

sample_names <- colnames(counts_data)[-1] # This gets all column names except the first one ('Geneid').

# Now, build the metadata table.
meta_table <- tibble(sample_id = sample_names) %>%
  mutate(
    # Pull out the mouse identifier from the start of the sample name.
    mouse_id = str_extract(sample_id, "^\\d+_\\d+"),

    # Create a 'gavage_treatment' column.
    # If the mouse ID starts with '1_' or '2_', it's E. faecalis, otherwise it's PBS.
    gavage_treatment = case_when(
      str_starts(mouse_id, "1_") | str_starts(mouse_id, "2_") ~ "E. faecalis",
      TRUE ~ "PBS"
    ),

    # Create a 'diet_treatment' column.
    # If the mouse ID starts with '1_' or '3_', the diet is sucrose water.
    diet_treatment = case_when(
      str_starts(mouse_id, "1_") | str_starts(mouse_id, "3_") ~ "sucrose_water",
      TRUE ~ "regular_water"
    ),

    # Create a 'tissue' column.
    # If the sample name contains '_LI_', it's from the large intestine.
    tissue = if_else(str_detect(sample_id, "_LI"), "large_intestine", "small_intestine")
  ) %>% 
  mutate(
    # Use 'across()' to apply the as.factor function to all these columns at once
    across(c(mouse_id, diet_treatment), as.factor),
    gavage_treatment = factor(gavage_treatment, levels = c('PBS','E. faecalis')),
    treatment = str_glue('{gavage_treatment}__{diet_treatment}'),   
    treatment = factor(treatment, levels = c('E. faecalis__regular_water','E. faecalis__sucrose_water','PBS__regular_water','PBS__sucrose_water')),
  )

# Display the first few rows of the new table to check the result.
print(meta_table)
levels(meta_table$treatment)
```

## normalization to cpm and filtering

```{r}
raw_counts_matrix <- counts_data %>% column_to_rownames('Geneid') %>% as.matrix()
cpm_matrix <- cpm(raw_counts_matrix)

# ---  Calculate Genes Kept at Different Thresholds ---
# Define the range of CPM thresholds to test.
cpm_thresholds <- seq(0.5, 10, by = 0.5)

# This function will count how many genes pass the filter for a given threshold.
# The rule is: at least 3 samples must be >= the threshold.
count_genes_kept <- function(threshold, cpm_data) {
  # 'apply' goes through each row (gene) of the matrix.
  # For each row, it checks how many sample values are >= the threshold.
  # The result is a vector of TRUE/FALSE for each gene.
  genes_to_keep <- apply(cpm_data, 1, function(gene_row) {
    sum(gene_row >= threshold) >= 3
  })
  # Finally, sum up the TRUE values to get the total number of genes kept.
  return(sum(genes_to_keep))
}

# Apply the function to every threshold in our sequence.
genes_left <- map_int(cpm_thresholds, ~count_genes_kept(., cpm_matrix))

# Combine the thresholds and the gene counts into a results table.
results_df <- tibble(
  cpm_threshold = cpm_thresholds,
  genes_remaining = genes_left
)

# Create the plot.
ggplot(results_df, aes(x = cpm_threshold, y = genes_remaining)) +
  geom_line(color = "dodgerblue", size = 1) +
  geom_point(color = "dodgerblue", size = 2) +
  labs(
    title = "Effect of CPM Threshold on Gene Filtering",
    x = "CPM Threshold (gene kept if expressed in at least 3 samples)",
    y = "Number of Genes Remaining"
  ) +
  theme_minimal() +
  # Add grid lines for easier reading of values.
  theme(panel.grid.major = element_line(color = "grey85"),
        panel.grid.minor = element_line(color = "grey90"))
# 2.5 is a good elbow point
```

## filtering with CPM 2.5 

```{r}
# --- 3. Define Filtering Thresholds --- 
cpm_threshold <- 2.5   
min_samples <- 3       # Minimum number of samples that must meet the CPM threshold

# --- 4. Apply the Filter ---

# Create a logical matrix: TRUE if CPM > threshold, FALSE otherwise
passes_cpm_threshold_matrix <- cpm_matrix > cpm_threshold

# Count how many samples pass the threshold for each gene (summing TRUEs row-wise)
samples_passing_per_gene <- rowSums(passes_cpm_threshold_matrix)

# Identify genes that meet the criteria (TRUE if gene should be kept)
genes_to_keep_logical <- samples_passing_per_gene >= min_samples
cat(sprintf("\nNumber of genes to keep: %d (out of %d)\n", sum(genes_to_keep_logical), nrow(raw_counts_matrix)))


# --- 5. Create the Filtered Raw Count Matrix ---
# Use the logical vector to subset the original raw count matrix
filtered_raw_counts_matrix <- raw_counts_matrix[genes_to_keep_logical, ]
```

## PCA to visualize the expression profiles between differnt treatment conditions

```{r}
# --- 1. Data Transformation ---
# Raw counts are not ideal for PCA. We need to transform them to stabilize variance.
# Variance Stabilizing Transformation (VST) or regularized log (rlog) from DESeq2 are good choices.

# Create a DESeqDataSet object.
# For VST/rlog, the design formula can be simple if you're just transforming for PCA,
# e.g., ~1, or you can use your main experimental design like ~condition.
# Using the main design can sometimes help stabilize variance better with respect to known factors.
colData <- meta_table %>% column_to_rownames('sample_id')


color_palette <- c(
  "PBS__regular_water" = "#A2E8E6",
  "PBS__sucrose_water" = "#FAD5D2",
  "E. faecalis__regular_water" = "#00BFC4",
  "E. faecalis__sucrose_water" = "#F8766D"
)
```


```{r}
dds <- DESeqDataSetFromMatrix(
  countData = round(filtered_raw_counts_matrix), # DESeq2 expects integer counts
  colData = colData,
  design = ~ tissue + treatment # This model will still account for the large differences between tissues while looking for the effects of diet and gavage. You lose the ability to explicitly model the paired nature of the samples, but it's the necessary trade-off to make the model work with this experimental design.
)

# Apply Variance Stabilizing Transformation  
# For very small datasets (e.g. < 10-12 samples per group), rlog might be preferred by some.
rld <- rlog(dds, blind = TRUE) # blind=TRUE: transform agnostic to the design (good for QC/PCA)
transformed_counts <- assay(rld)

# --- 2. Select Most Variable Genes (Optional, but often recommended for PCA) ---
# PCA works best when performed on genes that show the most variation across samples.
num_top_genes <- 500 # You can adjust this number

# Calculate row variances
rv <- rowVars(transformed_counts)

# Select the N most variable genes
select <- order(rv, decreasing = TRUE)[seq_len(min(num_top_genes, length(rv)))]
top_variable_transformed_counts <- transformed_counts[select, ]

cat(sprintf("\nPerforming PCA on the top %d most variable genes.\n", num_top_genes))
cat("Dimensions of matrix for PCA (genes x samples):\n")
print(dim(top_variable_transformed_counts))

# --- 3. Perform PCA ---
# prcomp expects samples as rows and variables (genes) as columns.
# So, we need to transpose our matrix.
pca_input <- t(top_variable_transformed_counts)
pca_results <- prcomp(pca_input, scale. = FALSE, center = TRUE) # VST/rlog are already roughly on the same scale

# Summary of PCA
# print(summary(pca_results))

# Extract PCA scores for plotting
pca_data <- as.data.frame(pca_results$x)
pca_data$sample <- rownames(pca_data) # Add sample names

# Merge with sample conditions for coloring points
pca_data <- merge(pca_data, meta_table, by.x = "sample", by.y = "sample_id")

# Calculate percentage of variance explained by each PC
percent_variance <- round(100 * pca_results$sdev^2 / sum(pca_results$sdev^2), 1)

cat("\nFirst few rows of data prepared for PCA plotting:\n")
print(head(pca_data))

# --- 4. Plot PCA Results using ggplot2 ---
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = treatment, shape = tissue)) +
  geom_point(size = 3) +
  xlab(paste0("PC1: ", percent_variance[1], "% variance")) +
  ylab(paste0("PC2: ", percent_variance[2], "% variance")) +
  ggtitle("PCA of Samples") +
  theme_bw(base_size = 14) +
  scale_color_manual(values = color_palette) +
  theme(legend.position = "right") +
  coord_fixed() # Ensures PC1 and PC2 are on the same scale visually

# Optional: Add sample labels (can be crowded)
#pca_plot <- pca_plot + geom_text_repel(aes(label = sample), size = 2)

print(pca_plot)
ggsave('../data/R38_pca_gf.png', width = 10)
# given the massive tissue effect shown in the PCA, splitting the data by tissue and analyzing them separately is the best path forward.
```

# split by tissue PCA   

```{r}
# --- 2. Split Data by Tissue ---
# Create metadata for the Small Intestine (SI)
meta_si <- meta_table %>% filter(tissue == "small_intestine")
# Create metadata for the Large Intestine (LI)
meta_li <- meta_table %>% filter(tissue == "large_intestine")

# Subset the counts matrix for each tissue based on the sample IDs in the new metadata
counts_si <- filtered_raw_counts_matrix[,meta_si$sample_id]
counts_li <- filtered_raw_counts_matrix[,meta_li$sample_id]

# --- 3. PCA for Small Intestine ---
# Create the DESeq2 object for the SI
dds_si <- DESeqDataSetFromMatrix(
  countData = counts_si,
  colData = meta_si,
  design = ~ treatment
)

# Apply the variance stabilizing transformation, which is great for visualizations like PCA
vst_si <- vst(dds_si, blind = TRUE)

# Generate the PCA plot for the SI using ggplot2
pca_plot_si <- plotPCA(vst_si, intgroup = "treatment") +
  ggtitle("PCA of Small Intestine Samples") +
  theme_minimal() +
  scale_color_manual(values = color_palette) +
  # Make the points a bit larger for clarity
  geom_point(size = 4) +
  coord_fixed()

# --- 4. PCA for Large Intestine ---
# Now, do the exact same process for the LI
dds_li <- DESeqDataSetFromMatrix(
  countData = counts_li,
  colData = meta_li,
  design = ~ treatment
)
vst_li <- vst(dds_li, blind = TRUE)

pca_plot_li <- plotPCA(vst_li, intgroup = "treatment") +
  ggtitle("PCA of Large Intestine Samples") +
  theme_minimal() +
  geom_point(size = 4) +
  scale_color_manual(values = color_palette) +
  coord_fixed()+
  theme(legend.position = "right")

# --- 5. Combine and Display the Plots ---
# Use the 'patchwork' library to combine the two plots into one figure
combined_pca_plot <- pca_plot_si + pca_plot_li+
  plot_layout(guides = 'collect')

# Display the final figure
print(combined_pca_plot)
ggsave('../data/R38_pca_gf_split.png', width = 10)
```
## specific pca of subset samples

```{r}
# --- Step 1: Prepare a Reusable PCA Plotting Function ---
# This function takes a subset of the data and generates a PCA plot.
# The 'group_variable' tells the plot how to color the points (e.g., by "treatment" or by "water").

generate_pca_plot <- function(counts_matrix, meta_subset, group_variable, plot_title) {
  
  # Subset the counts matrix to include only the samples in the metadata subset
  counts_subset <- counts_matrix[, meta_subset$sample_id]
  
  # Create the DESeq2 object for the subset
  # The design formula is now flexible based on the group_variable
  dds_subset <- DESeqDataSetFromMatrix(
    countData = counts_subset,
    colData = meta_subset,
    design = as.formula(paste("~", group_variable))
  )
  
  # Apply the variance stabilizing transformation
  vst_subset <- vst(dds_subset, blind = TRUE)
  
  # Generate the PCA plot, coloring by the specified group_variable
  pca_plot <- plotPCA(vst_subset, intgroup = group_variable) +
    ggtitle(plot_title) +
    theme_minimal(base_size = 14) +
    coord_fixed()
  
  return(pca_plot)
}
```


```{r}
# --- Step 2: Analyze Colonization Effect (Regular Water Samples) ---

# Filter metadata for regular water samples in both tissues
meta_si_regular <- meta_table %>% filter(tissue == "small_intestine", diet_treatment == "regular_water")
meta_li_regular <- meta_table %>% filter(tissue == "large_intestine", diet_treatment == "regular_water")

# Generate PCA plots comparing PBS vs E. faecalis
pca_si_col <- generate_pca_plot(filtered_raw_counts_matrix, meta_si_regular, "treatment", "SI: Colonization Effect")
pca_li_col <- generate_pca_plot(filtered_raw_counts_matrix, meta_li_regular, "treatment", "LI: Colonization Effect")

# Combine into a single figure
colonization_plot <- plot_grid(pca_si_col, pca_li_col, ncol = 2, labels = c("A", "B"))
save_plot("../data/pca_colonization_effect.jpg", colonization_plot, base_height = 6, base_width = 12)
print(colonization_plot)
```


```{r}
# --- Step 3: Analyze Sucrose Effect (E. faecalis Samples) ---

# Filter metadata for E. faecalis samples in both tissues
meta_si_faecalis <- meta_table %>% filter(tissue == "small_intestine", gavage_treatment == "E. faecalis")
meta_li_faecalis <- meta_table %>% filter(tissue == "large_intestine", gavage_treatment == "E. faecalis")

# Generate PCA plots comparing regular_water vs sucrose_water
pca_si_suc <- generate_pca_plot(filtered_raw_counts_matrix, meta_si_faecalis, "treatment", "SI: Sucrose Effect")
pca_li_suc <- generate_pca_plot(filtered_raw_counts_matrix, meta_li_faecalis, "treatment", "LI: Sucrose Effect")

# Combine into a single figure
sucrose_plot <- plot_grid(pca_si_suc, pca_li_suc, ncol = 2, labels = c("C", "D"))
save_plot("../data/pca_sucrose_effect.jpg", sucrose_plot, base_height = 6, base_width = 12)
print(sucrose_plot)


```



# Differential gene expression analysis

## LI

```{r}
# ==============================================================================
#  ANALYSIS FOR LARGE INTESTINE (LI)
# ==============================================================================
print("--- Starting DGE Analysis for Large Intestine ---")

# --- 2. Run the main DESeq2 function ---
# This step performs differential expression analysis on all groups.
dds_li <- DESeq(dds_li)

# --- 3. Extract and filter Contrast 1: E. faecalis effect ---
# We are comparing PBS vs. E. faecalis in mice given regular water.

#Think of the contrast argument in DESeq2 like this:
# c("variable", "numerator", "denominator")
# The function calculates the log2 fold change as log2(numerator / denominator).

print("--- LI Contrast 1: PBS_regular_water vs E. faecalis_regular_water ---")
results_li_contrast1 <- results(dds_li,
                                contrast = c("treatment",  "E. faecalis__regular_water", "PBS__regular_water"),
                                alpha = 0.05) # Set our significance cutoff

# Apply LFC shrinkage to get more accurate fold change estimates.
shrunken_li_contrast1 <- lfcShrink(dds_li,
                                   contrast = c("treatment",  "E. faecalis__regular_water", "PBS__regular_water"),
                                   res = results_li_contrast1,
                                   type = "ashr")

# Filter the shrunken results for significance.
sig_li_contrast1 <- as.data.frame(shrunken_li_contrast1) %>%
  rownames_to_column("gene") %>%
  filter(padj < 0.05 & abs(log2FoldChange) > 1)

# Summarize the findings
print(paste("Found", nrow(sig_li_contrast1), "significant genes."))
print(table(sig_li_contrast1$log2FoldChange > 0))
# and the log2fc is really small...basically there isn't much change
```

```{r}
# --- 4. Extract and filter Contrast 2: Sucrose effect ---
# We are comparing sucrose vs. regular water in mice given E. faecalis.
print("--- LI Contrast 2: E. faecalis_sucrose_water vs E. faecalis_regular_water ---")
results_li_contrast2 <- results(dds_li,
                                contrast = c("treatment", "E. faecalis__sucrose_water", "E. faecalis__regular_water"),
                                alpha = 0.05)

shrunken_li_contrast2 <- lfcShrink(dds_li,
                                   contrast = c("treatment", "E. faecalis__sucrose_water", "E. faecalis__regular_water"),
                                   res = results_li_contrast2,
                                   type = "ashr")

sig_li_contrast2 <- as.data.frame(shrunken_li_contrast2) %>%
  rownames_to_column("gene") %>%
  filter(padj < 0.05 & abs(log2FoldChange) > 1)

print(paste("Found", nrow(sig_li_contrast2), "significant genes."))
print(table(sig_li_contrast2$log2FoldChange > 0))
```

## SI

```{r}
# ==============================================================================
#  ANALYSIS FOR SMALL INTESTINE (SI)
# ==============================================================================
print("--- Starting DGE Analysis for Small Intestine ---")

# --- 5. Repeat the entire process for the SI dataset ---
dds_si <- DESeq(dds_si)

# Contrast 1: E. faecalis effect
print("--- SI Contrast 1: PBS_regular_water vs E. faecalis_regular_water ---")
results_si_contrast1 <- results(dds_si, contrast = c("treatment",  "E. faecalis__regular_water", "PBS__regular_water"), alpha = 0.05)
shrunken_si_contrast1 <- lfcShrink(dds_si, contrast = c("treatment", "E. faecalis__regular_water", "PBS__regular_water"), res = results_si_contrast1, type = "ashr")
sig_si_contrast1 <- as.data.frame(shrunken_si_contrast1) %>%
  rownames_to_column("gene") %>%
  filter(padj < 0.05 & abs(log2FoldChange) > 1)
print(paste("Found", nrow(sig_si_contrast1), "significant genes."))
print(table(sig_si_contrast1$log2FoldChange > 0))
```

```{r}
# Contrast 2: Sucrose effect
print("--- SI Contrast 2: E. faecalis_sucrose_water vs E. faecalis_regular_water ---")
results_si_contrast2 <- results(dds_si, contrast = c("treatment", "E. faecalis__sucrose_water", "E. faecalis__regular_water"), alpha = 0.05)
shrunken_si_contrast2 <- lfcShrink(dds_si, contrast = c("treatment", "E. faecalis__sucrose_water", "E. faecalis__regular_water"), res = results_si_contrast2, type = "ashr")
sig_si_contrast2 <- as.data.frame(shrunken_si_contrast2) %>%
  rownames_to_column("gene") %>%
  filter(padj < 0.05 & abs(log2FoldChange) > 1 )
print(paste("Found", nrow(sig_si_contrast2), "significant genes."))
print(table(sig_si_contrast2$log2FoldChange > 0))
```
```{r}
# Convert results to a dataframe for easier manipulation
results_df_si2 <- as.data.frame(shrunken_si_contrast2) %>%
  rownames_to_column("ensembl_version")

# Find the top 20 most abundant genes
top_abundant_genes <- results_df_si2 %>%
  arrange(desc(baseMean)) %>%
  head(20)

# Extract the Ensembl IDs (with version) of these top genes
top_gene_ids <- top_abundant_genes$ensembl_version

# --- Step 2: Prepare Data for Plotting ---
# This assumes 'dds_si' is your main DESeqDataSet object for the small intestine.

# Get the normalized counts for all genes
normalized_counts_si <- counts(dds_si, normalized = TRUE)

# Get the sample metadata (e.g., conditions)
sample_info_si <- as.data.frame(colData(dds_si))

# Filter the normalized counts to just our top genes and format for ggplot
plot_data_top20 <- normalized_counts_si[top_gene_ids, ] %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("sample_name") %>%
  # Join with the sample metadata to get the experimental conditions
  left_join(sample_info_si %>% rownames_to_column("sample_name"), by = "sample_name") %>%
  # Convert from wide to long format for plotting
  pivot_longer(cols = all_of(top_gene_ids), names_to = "ensembl_version", values_to = "normalized_count")

# --- Step 3: Add Gene Symbols for Clearer Labels ---

# Create a clean Ensembl ID without the version number
plot_data_top20 <- plot_data_top20 %>%
  mutate(ensembl_id = str_remove(ensembl_version, "\\..*"))

# Map the clean Ensembl IDs to gene symbols
gene_symbols_map <- mapIds(org.Mm.eg.db,
                           keys = unique(plot_data_top20$ensembl_id),
                           column = "SYMBOL",
                           keytype = "ENSEMBL",
                           multiVals = "first")

# Add the gene symbols to our plotting data
plot_data_top20$symbol <- gene_symbols_map[plot_data_top20$ensembl_id]

# --- Step 4: Generate the Boxplots ---

# Create a plot for each gene using facet_wrap
ggplot(plot_data_top20, aes(x = treatment, y = normalized_count, fill = treatment)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.15, alpha = 0.7) + # Overlay individual data points
  facet_wrap(~symbol, scales = "free_y", ncol = 5) + # Create a grid of plots
  
  # Assuming your conditions are named "Sucrose" and "Regular"
  scale_fill_manual(values = color_palette) +
  
  labs(
    title = "Top 20 Most Abundant Genes in Small Intestine",
    subtitle = "E. faecalis: Sucrose vs Regular Water",
    x = "Water Treatment",
    y = "Normalized Gene Count"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold.italic", size = 9), # Style the gene names
    axis.text.x = element_text(angle = 45, hjust = 1) # Angle x-axis labels
  )

ggsave('../data/R38_top20.pdf', width = 10, height = 8)
```

```{r}
results_df_si2 <- as.data.frame(shrunken_si_contrast2) %>%
  rownames_to_column("ensembl_version")

# Find the top 50 genes with the largest absolute fold change
top_lfc_genes <- results_df_si2 %>%
  arrange(desc(abs(log2FoldChange))) %>%
  head(50)

# Extract the Ensembl IDs (with version) of these top genes
top_gene_ids <- top_lfc_genes$ensembl_version

# --- Step 2: Prepare Data for Plotting ---
# This assumes 'dds_si' is your main DESeqDataSet object for the small intestine.

# Get the normalized counts for all genes
normalized_counts_si <- counts(dds_si, normalized = TRUE)

# Get the sample metadata (e.g., conditions)
sample_info_si <- as.data.frame(colData(dds_si))

# Filter the normalized counts to just our top genes and format for ggplot
plot_data_top50 <- normalized_counts_si[top_gene_ids, ] %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("sample_name") %>%
  # Join with the sample metadata to get the experimental conditions
  left_join(sample_info_si %>% rownames_to_column("sample_name"), by = "sample_name") %>%
  # Convert from wide to long format for plotting
  pivot_longer(cols = all_of(top_gene_ids), names_to = "ensembl_version", values_to = "normalized_count")

# --- Step 3: Add Gene Symbols for Clearer Labels ---

# Create a clean Ensembl ID without the version number
plot_data_top50 <- plot_data_top50 %>%
  mutate(ensembl_id = str_remove(ensembl_version, "\\..*"))

# Map the clean Ensembl IDs to gene symbols
gene_symbols_map <- mapIds(org.Mm.eg.db,
                           keys = unique(plot_data_top50$ensembl_id),
                           column = "SYMBOL",
                           keytype = "ENSEMBL",
                           multiVals = "first")

# Add the gene symbols to our plotting data
plot_data_top50$symbol <- gene_symbols_map[plot_data_top50$ensembl_id]

# --- Step 4: Generate the Boxplots ---

# Create a plot for each gene using facet_wrap
ggplot(plot_data_top50, aes(x = treatment, y = normalized_count, fill = treatment)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.15, alpha = 0.7) + # Overlay individual data points
  facet_wrap(~symbol, scales = "free_y", ncol = 10) + # Create a grid of plots
  
  # Assuming your conditions are named "Sucrose" and "Regular"
  scale_fill_manual(values = color_palette) +
  
  labs(
    title = "Top 50 Genes by Absolute Fold Change in Small Intestine",
    subtitle = "E. faecalis: Sucrose vs Regular Water",
    x = "Water Treatment",
    y = "Normalized Gene Count"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold.italic", size = 8), # Style the gene names
    axis.text.x = element_text(angle = 45, hjust = 1) # Angle x-axis labels
  )

ggsave('../data/R38_top50.pdf', width = 20, height = 13)
```

## Volcano plots

```{r}
# --- 2. Set up Gene Symbol Annotation ---
# We need an annotation database to map Ensembl IDs to gene symbols in a mouse experiment. 
library(org.Mm.eg.db)
library(AnnotationDbi)

# --- 3. Create a Reusable Plotting Function ---
# Since we are making four similar plots, a function is the cleanest approach.
create_volcano_plot <- function(shrunken_results, plot_title) {

  # Convert the results to a data frame and remove Ensembl versions for mapping
  results_df <- as.data.frame(shrunken_results) %>%
    rownames_to_column("ensembl_version") %>%
    mutate(ensembl_id = str_remove(ensembl_version, "\\..*"))

  # Map Ensembl IDs to gene symbols. 'mapIds' will return NA for any ID it can't find.
  results_df$symbol <- mapIds(org.Mm.eg.db,
                              keys = results_df$ensembl_id,
                              column = "SYMBOL",
                              keytype = "ENSEMBL",
                              multiVals = "first")

  # Create a column to identify significant genes for coloring and labeling
  results_df <- results_df %>%
    mutate(significant = ifelse(padj < 0.05 & abs(log2FoldChange) > 1, "Yes", "No"))

  # Generate the plot
  ggplot(results_df, aes(x = log2FoldChange, y = -log10(padj))) +
    # Add points, colored by significance
    geom_point(aes(color = significant), alpha = 0.6) +
    scale_color_manual(values = c("No" = "grey", "Yes" = "red"), name = "") +
    
    # Add the dashed line for the FDR 0.05 cutoff
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
    
    # Add vertical dashed lines for the log2FoldChange threshold
    geom_vline(xintercept = -1, linetype = "dashed", color = "black") +
    geom_vline(xintercept = 1, linetype = "dashed", color = "black") +
    
    # Add gene symbols for significant genes using ggrepel
    geom_text_repel(aes(label = symbol),
                    data = subset(results_df, padj < 0.05 & abs(log2FoldChange) > 1),
                    max.overlaps = 2.8, # Increase to allow more labels
                    size = 2,
                    box.padding = 0.5) +
    
    labs(title = plot_title,
         x = "Log2 Fold Change",
         y = "-log10(Adjusted P-value)") +
    theme_minimal(base_size = 11) +
    theme(legend.position = "none") # Hide the individual legends
}

# --- 4. Generate Each of the Four Plots ---
# Create each volcano plot by calling the function with the corresponding results.
# Small Intestine Plots
p_si_contrast1 <- create_volcano_plot(shrunken_si_contrast1, "SI: E. faecalis vs PBS (Regular Water)") 
p_si_contrast2 <- create_volcano_plot(shrunken_si_contrast2, "E. faecalis (Sucrose vs Regular Water)")

# Large Intestine Plots
p_li_contrast1 <- create_volcano_plot(shrunken_li_contrast1, "LI: E. faecalis vs PBS (Regular Water)")    
p_li_contrast2 <- create_volcano_plot(shrunken_li_contrast2, "E. faecalis (Sucrose vs Regular Water)")

# --- 5. Arrange Plots into a 2x2 Grid ---
# Use patchwork to combine the plots. The '/' operator stacks plots vertically.
p_si_contrast2  + p_li_contrast2
ggsave('../data/R38_DEG_volcano.png', width = 6, height = 4)
```


```{r}
# the volcano for the non-shrunken resutls

original_si_contrast2 <- create_volcano_plot(results_si_contrast2, "E. faecalis (Sucrose vs Regular Water)")

```
## plot gene counts

### Defa2 

```{r}
get_gene_counts <- function(dds_object, gene_symbol, tissue_name) {
  
  # Create a mapping from clean Ensembl IDs to the versioned IDs in the DDS object
  ensembl_map <- data.frame(
    ensembl_version = rownames(dds_object)
  ) %>%
    mutate(ensembl_id = str_remove(ensembl_version, "\\..*"))
  
  # Find the clean Ensembl ID for our target gene symbol
  target_ensembl_id <- mapIds(org.Mm.eg.db,
                              keys = gene_symbol,
                              column = "ENSEMBL",
                              keytype = "SYMBOL",
                              multiVals = "first")
  
  # Check if the gene symbol was found
  if (is.na(target_ensembl_id)) {
    stop(paste("Gene symbol", gene_symbol, "not found in org.Mm.eg.db."))
  }
  
  # Find the full, versioned Ensembl ID corresponding to our clean ID
  target_ensembl_version <- ensembl_map %>%
    filter(ensembl_id == target_ensembl_id) %>%
    pull(ensembl_version) %>%
    unique()
    
  # Check if the gene was found in the DDS object
  if (length(target_ensembl_version) == 0) {
    stop(paste(gene_symbol, "not found in the provided DESeqDataSet object."))
  }
  
  # Use plotCounts to extract normalized data for the gene
  plot_df <- plotCounts(dds_object, 
                        gene = target_ensembl_version[1], # Use the first match if multiple exist
                        intgroup = "treatment", 
                        returnData = TRUE) %>%
    rownames_to_column("sample_name") %>%
    mutate(tissue = tissue_name) # Add the tissue label
    
  return(plot_df)
}
```


```{r}
li_counts_Defa2 <- get_gene_counts(dds_li, "Defa2", "Large Intestine")

LI_Defa2 <- ggplot(li_counts_Defa2, aes(x = treatment, y = count, fill = treatment)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.8, height = 0) + # Overlay individual data points
  #facet_wrap(~tissue, scales = "free_y") + # Create separate plots for LI and SI
  
  # Use the same colors as the previous plot for consistency
  scale_fill_manual(values = color_palette) +
  scale_y_sqrt() +
  labs(
    title = "Defa2",
    x = "",
    y = "Normalized Gene Count"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 12), # Style the facet titles
    axis.text.x = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold.italic")
  ) 

LI_Defa2
```


### Serpina10

```{r}
# --- Step 1: Extract Serpina10 counts from both dds objects ---
# This assumes 'dds_li' and 'dds_si' are your DESeqDataSet objects.
li_counts <- get_gene_counts(dds_li, "Serpina10", "Large Intestine")
si_counts <- get_gene_counts(dds_si, "Serpina10", "Small Intestine")

# --- Step 2: Combine the data from both tissues ---
combined_counts <- rbind(li_counts, si_counts)

# --- Step 3: Generate the boxplots ---
SI_Serpina10 <- ggplot(si_counts, aes(x = treatment, y = count, fill = treatment)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.8, height = 0) + # Overlay individual data points
  #facet_wrap(~tissue, scales = "free_y") + # Create separate plots for LI and SI
  
  # Use the same colors as the previous plot for consistency
  scale_fill_manual(values = color_palette) +
  
  labs(
    title = "SERPINA10",
    x = "",
    y = "Normalized Gene Count"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 12), # Style the facet titles
    axis.text.x = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold.italic")
  ) 

SI_Serpina10
```


# GSEA

```{r}
# --- Step 1: Prepare the Ranked Gene List ---
# GSEA requires a list of all detected genes, ranked by a metric.
# The 'stat' column from DESeq2 is perfect for this, as it considers
# both fold change and variance.

# This function takes a DESeq2 results object and prepares the ranked list.
prepare_ranked_list <- function(deseq_results) {
  
  # Convert to a dataframe and get gene symbols
  results_df <- as.data.frame(deseq_results) %>%
    rownames_to_column("ensembl_version") %>%
   # Ensure pvalue and log2FoldChange are not NA
    filter(!is.na(pvalue) & !is.na(log2FoldChange)) %>%
    
    # ***  Create a custom ranking metric since 'stat' is not available ***
    # This metric combines the direction (sign of LFC) and significance (-log10 of p-value)
    mutate(rank_metric = sign(log2FoldChange) * -log10(pvalue)) %>%
    mutate(ensembl_id = str_remove(ensembl_version, "\\..*")) %>%
    # Add gene symbols
    mutate(symbol = mapIds(org.Mm.eg.db,
                           keys = ensembl_id,
                           column = "SYMBOL",
                           keytype = "ENSEMBL",
                           multiVals = "first")) %>%
    # Remove genes that didn't map to a symbol
    filter(!is.na(symbol))

  # Handle cases where one gene symbol maps to multiple Ensembl IDs.
  # We'll keep the one with the largest absolute rank_metric value.
  results_df <- results_df %>%
    group_by(symbol) %>%
    filter(abs(rank_metric) == max(abs(rank_metric))) %>%
    ungroup()

  # Create the final ranked list: a named vector
  ranked_list <- results_df$rank_metric
  names(ranked_list) <- results_df$symbol
  
  # Sort the list in descending order
  ranked_list <- sort(ranked_list, decreasing = TRUE)
  
  # Remove any NA values from the ranking metric
  ranked_list <- ranked_list[!is.na(ranked_list)]
  
  return(ranked_list)
}
```

## LI

```{r}
# Replace 'shrunken_li_contrast2' with the results you want to analyze.
ranked_genes_li2 <- prepare_ranked_list(shrunken_li_contrast2)
head(ranked_genes_li2)
```

```{r}
# --- Step 2: Get Gene Sets ---
# We'll use the msigdbr package to fetch gene sets. The Gene Ontology (GO)
# "Biological Process" (BP) collection is a great place to start.

# Fetch all GO:BP gene sets for mouse ("Mus musculus")
# go_bp_sets <- msigdbr(species = "Mus musculus", category = "C5", subcategory = "GO:BP")
# 
# # fgsea requires the gene sets in a specific list format.
# # We'll convert the dataframe from msigdbr into that format.
# go_pathways <- go_bp_sets %>%
#   split(x = .$gene_symbol, f = .$gs_name)

# Fetch the 50 Hallmark gene sets for mouse
hallmark_sets <- msigdbr(species = "Mus musculus", category = "H")
hallmark_pathways <- hallmark_sets %>%
  split(x = .$gene_symbol, f = .$gs_name)

# Combine both lists of pathways for a comprehensive analysis
# combined_pathways <- c(go_pathways, hallmark_pathways)

names(hallmark_pathways)
```


```{r}
# --- Step 3: Run fgsea ---
# Now we run the analysis with our ranked genes and the GO pathways.

set.seed(42) # for reproducibility
fgsea_results <- fgsea(
  pathways = hallmark_pathways,
  stats = ranked_genes_li2,
  minSize = 15,   # Minimum size of a gene set to be tested
  maxSize = 500,  # Maximum size of a gene set to be tested
  nPermSimple = 10000 # Number of permutations
)


# --- Step 4: Explore and Visualize the Results ---

# View the top enriched pathways
top_pathways_Li <- fgsea_results %>%
  as_tibble() %>%
  arrange(desc(NES)) # NES = Normalized Enrichment Score


# --- Searching for Specific Pathways (e.g., Gut Barrier) ---
# You can search the results for terms of interest.

filtered_pathways <- fgsea_results %>%
  as_tibble() %>%
  filter(str_detect(pathway, "INTESTINAL|BARRIER|EPITHELIUM")) %>%
  arrange(padj)

print(filtered_pathways)
```

### LI bars 

```{r}
# --- Plotting a Table of Top Pathways with NES ---
# Process and plot the data.
sig_pw_bar_LI <- top_pathways_Li %>%
  # Keep only the pathways that are statistically significant.
  filter(padj < 0.05) %>%
  # Create a new, cleaner pathway name for the plot labels.
  mutate(
    pathway_clean = pathway %>%
      str_replace("HALLMARK_", "") %>%       # Remove the "GOBP_" prefix.
      str_to_title() %>%                # Convert the entire name to lowercase.
      str_replace_all("_", " ")  %>%        # Replace underscores with spaces for readability.
      str_wrap( width = 20)
  ) %>%
  # Create the plot.
  ggplot(aes(x = NES, y = fct_reorder(pathway_clean, NES))) +
  # Add the bars. The fill color is determined by whether the NES is positive.
  geom_col(aes(fill = NES > 0)) +
  # Manually set the colors for positive (red) and negative (blue) NES values.
  # The `guide = "none"` part hides the unnecessary fill legend.
  scale_fill_manual(values = c(`TRUE` = "#E69F00", `FALSE` = "#56B4E9"), guide = "none") +
  # Set the labels for the axes and the title.
  labs(
    #title = "Significant Hallmark Pathways by Normalized Enrichment Score\nin LI samples",
    x = "Normalized Enrichment Score (NES)",
    y = ""
  ) +
  # Apply a clean, minimal theme to the plot.
  theme_minimal()

ggsave('../data/R38_sig_pathway_li_contrast2.pdf', height = 8, width = 6)
# The sucrose water is likely inducing a state of high stress and rapid repair in the large intestine. The gut lining is undergoing massive proliferation, supported by a fundamental shift in cell metabolism to prioritize growth over efficient energy production. However, this comes at a cost: the downregulation of key immune and structural pathways suggests the resulting gut barrier might be weaker and less immunologically prepared.

# The Hallmark sets confirm that sucrose acts as a powerful growth signal. It activates the master control switches for cell division (MYC, E2F, MTORC1), forcing the gut lining into a state of hyper-proliferation. This is fueled by a metabolic shift away from efficient energy production. The new data also reveals this comes at the cost of weakened detoxification and antiviral defense systems, making the gut potentially more vulnerable.
```

### contrast 1: enterococcus effects on the host

```{r}
ranked_genes_li1 <- prepare_ranked_list(shrunken_li_contrast1)

set.seed(42) # for reproducibility
fgsea_results_li1 <- fgsea(
  pathways = hallmark_pathways,
  stats = ranked_genes_li1,
  minSize = 15,   # Minimum size of a gene set to be tested
  maxSize = 500,  # Maximum size of a gene set to be tested
  nPermSimple = 10000 # Number of permutations
)


# --- Step 4: Explore and Visualize the Results ---

# View the top enriched pathways
top_pathways_li1 <- fgsea_results_li1 %>%
  as_tibble() %>%
  arrange(desc(NES))



sig_pw_bar_LI1 <- top_pathways_li1 %>%
  # Keep only the pathways that are statistically significant.
  filter(padj < 0.05) %>%
  # Create a new, cleaner pathway name for the plot labels.
  mutate(
    pathway_clean = pathway %>%
      str_replace("HALLMARK_", "") %>%       # Remove the "GOBP_" prefix.
      str_to_title() %>%                # Convert the entire name to lowercase.
      str_replace_all("_", " ")  %>%        # Replace underscores with spaces for readability.
      str_wrap( width = 30)
  ) %>%
  # Create the plot.
  ggplot(aes(x = NES, y = fct_reorder(pathway_clean, NES))) +
  # Add the bars. The fill color is determined by whether the NES is positive.
  geom_col(aes(fill = NES > 0)) +
  # Manually set the colors for positive (red) and negative (blue) NES values.
  # The `guide = "none"` part hides the unnecessary fill legend.
  scale_fill_manual(values = c(`TRUE` = "#E69F00", `FALSE` = "#56B4E9"), guide = "none") +
  # Set the labels for the axes and the title.
  labs(
    #title = "Significant Hallmark Pathways by Normalized Enrichment Score\nin LI samples",
    x = "Normalized Enrichment Score (NES)",
    y = ""
  ) +
  # Apply a clean, minimal theme to the plot.
  theme_minimal()

sig_pw_bar_LI1
```


## SI

```{r}
ranked_genes_si2 <- prepare_ranked_list(shrunken_si_contrast2)

set.seed(42) # for reproducibility
fgsea_results_SI <- fgsea(
  pathways = hallmark_pathways,
  stats = ranked_genes_si2,
  minSize = 15,   # Minimum size of a gene set to be tested
  maxSize = 500,  # Maximum size of a gene set to be tested
  nPermSimple = 10000 # Number of permutations
)


# --- Step 4: Explore and Visualize the Results ---

# View the top enriched pathways
top_pathways_SI <- fgsea_results_SI %>%
  as_tibble() %>%
  arrange(desc(NES)) # NES = Normalized Enrichment Score
```

### SI bars

```{r}
sig_pw_bar_SI <- top_pathways_SI %>%
  # Keep only the pathways that are statistically significant.
  filter(padj < 0.05) %>%
  # Create a new, cleaner pathway name for the plot labels.
  mutate(
    pathway_clean = pathway %>%
      str_replace("HALLMARK_", "") %>%       # Remove the "GOBP_" prefix.
      str_to_title() %>%                # Convert the entire name to lowercase.
      str_replace_all("_", " ")    %>%      # Replace underscores with spaces for readability.
      str_wrap( width = 20)
  ) %>%
  # Create the plot.
  ggplot(aes(x = NES, y = fct_reorder(pathway_clean, NES))) +
  # Add the bars. The fill color is determined by whether the NES is positive.
  geom_col(aes(fill = NES > 0)) +
  # Manually set the colors for positive (red) and negative (blue) NES values.
  # The `guide = "none"` part hides the unnecessary fill legend.
  scale_fill_manual(values = c(`TRUE` = "#E69F00", `FALSE` = "#56B4E9"), guide = "none") +
  # Set the labels for the axes and the title.
  labs(
    #title = "Significant Hallmark Pathways by Normalized Enrichment Score\nin SI samples",
    x = "Normalized Enrichment Score (NES)",
    y = ""
  ) +
  # Apply a clean, minimal theme to the plot.
  theme_minimal()

ggsave('../data/R38_sig_pathway_si_contrast2.pdf', height = 6, width = 8)
```

```{r}
sig_pw_bar_SI + sig_pw_bar_LI
ggsave('../data/R38_sig_pw_bar.png', width = 11, height = 5)
```
### contrast 1: enterococcus effects on the host

```{r}
ranked_genes_si1 <- prepare_ranked_list(shrunken_si_contrast1)

set.seed(42) # for reproducibility
fgsea_results_si1 <- fgsea(
  pathways = hallmark_pathways,
  stats = ranked_genes_si1,
  minSize = 15,   # Minimum size of a gene set to be tested
  maxSize = 500,  # Maximum size of a gene set to be tested
  nPermSimple = 10000 # Number of permutations
)


# --- Step 4: Explore and Visualize the Results ---

# View the top enriched pathways
top_pathways_si1 <- fgsea_results_si1 %>%
  as_tibble() %>%
  arrange(desc(NES))



sig_pw_bar_SI1 <- top_pathways_si1 %>%
  # Keep only the pathways that are statistically significant.
  filter(padj < 0.05) %>%
  # Create a new, cleaner pathway name for the plot labels.
  mutate(
    pathway_clean = pathway %>%
      str_replace("HALLMARK_", "") %>%       # Remove the "GOBP_" prefix.
      str_to_title() %>%                # Convert the entire name to lowercase.
      str_replace_all("_", " ")  %>%        # Replace underscores with spaces for readability.
      str_wrap( width = 40)
  ) %>%
  # Create the plot.
  ggplot(aes(x = NES, y = fct_reorder(pathway_clean, NES))) +
  # Add the bars. The fill color is determined by whether the NES is positive.
  geom_col(aes(fill = NES > 0)) +
  # Manually set the colors for positive (red) and negative (blue) NES values.
  # The `guide = "none"` part hides the unnecessary fill legend.
  scale_fill_manual(values = c(`TRUE` = "#E69F00", `FALSE` = "#56B4E9"), guide = "none") +
  # Set the labels for the axes and the title.
  labs(
    #title = "Significant Hallmark Pathways by Normalized Enrichment Score\nin LI samples",
    x = "Normalized Enrichment Score (NES)",
    y = ""
  ) +
  # Apply a clean, minimal theme to the plot.
  theme_minimal()

sig_pw_bar_SI1
```
```{r}
sig_pw_bar_SI1 + sig_pw_bar_LI1
ggsave('../data/R38_sig_pw_bar_contrast1.png', width = 11, height = 5)
```

## g heatmap

```{r}
# find the overlapped significant pathways in these four comparisons
list_of_dfs <- list(
  LI_Contrast1 = top_pathways_li1,
  LI_Contrast2 = top_pathways_Li,
  SI_Contrast1 = top_pathways_si1,
  SI_Contrast2 = top_pathways_SI
)

# Extract the significant pathway names from each dataframe
significant_pathways_list <- lapply(list_of_dfs, function(df) {
  df %>%
    filter(padj < 0.05) %>%
    pull(pathway)
})

# Use Reduce() to find the intersection (common elements) across all lists
overlapping_pathways <- Reduce(intersect, significant_pathways_list)

# Print the result
print("Pathways significant in all four contrasts:")
print(overlapping_pathways)
```

```{r}
# --- Step 2: Find Overlapping Leading Edge Genes for the Common Pathways ---

# This step will find the core genes driving the enrichment for each common pathway.
common_leading_edge_genes <- lapply(overlapping_pathways, function(p) {
  
  # For the current pathway 'p', get the list of leading edge genes from each of the 4 contrasts
  list_of_gene_sets <- lapply(list_of_dfs, function(df) {
    # Filter for the specific pathway
    pathway_data <- df %>% filter(pathway == p)
    
    # Check if the pathway was found and significant in this df before extracting genes
    if (nrow(pathway_data) > 0 && pathway_data$padj < 0.05) {
      # The 'leadingEdge' column is a list, so unlist to get the character vector of genes
      return(unlist(pathway_data$leadingEdge))
    } else {
      # If the pathway isn't in this df, return NULL
      return(NULL)
    }
  })
  
  # Remove any NULL elements from the list
  list_of_gene_sets <- compact(list_of_gene_sets)
  
  # Find the intersection of these gene sets
  if (length(list_of_gene_sets) > 0) {
    Reduce(intersect, list_of_gene_sets)
  } else {
    character(0) # Return an empty vector if no sets to compare
  }
})

# Name the final list with the pathway names for clarity
names(common_leading_edge_genes) <- overlapping_pathways

# Print the results
print("Common leading edge genes for each overlapping pathway:")
print(common_leading_edge_genes)
```

```{r}
# ---  Calculate Pairwise Overlap of Leading Edge Genes ---

# Get the names of the pathways for which we have common leading edge genes
pathway_names <- names(common_leading_edge_genes)

# Create an empty matrix to store the overlap counts
overlap_matrix <- matrix(
  0,
  nrow = length(pathway_names),
  ncol = length(pathway_names),
  dimnames = list(pathway_names, pathway_names)
)

# Loop through each pair of pathways to calculate the number of overlapping genes
for (i in 1:length(pathway_names)) {
  for (j in i:length(pathway_names)) {
    # Get the gene lists for the two pathways
    genes1 <- common_leading_edge_genes[[pathway_names[i]]]
    genes2 <- common_leading_edge_genes[[pathway_names[j]]]
    
    # Calculate the number of genes in the intersection
    overlap_count <- length(intersect(genes1, genes2))
    
    # Fill the matrix (it's symmetric)
    overlap_matrix[i, j] <- overlap_count
    overlap_matrix[j, i] <- overlap_count
  }
}

# Print the resulting matrix of overlap counts
print("Pairwise overlap count of common leading edge genes:")
print(overlap_matrix)
```




### top and bottom genes heatmap

```{r}
# --- Step 1: Identify Top and Bottom 200 Genes ---

# A helper function to get top/bottom genes from a results object
get_top_bottom_genes <- function(shrunken_results) {
  # Convert to a tibble, arrange by fold change, and get row names
  df <- as.data.frame(shrunken_results) %>%
    rownames_to_column("ensembl_id") %>%
    as_tibble() %>%
    filter(!is.na(log2FoldChange)) %>% # Ensure no NA values
    arrange(desc(log2FoldChange))
  
  # Get top 100 (most upregulated) and bottom 100 (most downregulated)
  top_genes <- head(df, 100) %>% pull(ensembl_id)
  bottom_genes <- tail(df, 100) %>% pull(ensembl_id)
  
  return(c(top_genes, bottom_genes))
}

get_top_genes <- function(shrunken_results) {
  # Convert to a tibble, arrange by fold change, and get row names
  df <- as.data.frame(shrunken_results) %>%
    rownames_to_column("ensembl_id") %>%
    as_tibble() %>%
    filter(!is.na(log2FoldChange)) %>% # Ensure no NA values
    arrange(desc(log2FoldChange))
  
  # Get top 100 (most upregulated) 
  top_genes <- head(df, 100) %>% pull(ensembl_id)
  
  return(c(top_genes))
}

# Apply the function to both contrast results
# IMPORTANT: Replace the mock objects with your actual results objects
genes_si <- get_top_genes(shrunken_si_contrast1)
genes_li <- get_top_genes(shrunken_li_contrast1)

# Combine the lists and get a single unique vector of genes to plot
unique_genes_to_plot <- unique(c(genes_si, genes_li))

# --- Step 2: Extract Normalized Counts for These Genes ---

# Get normalized counts from both dds objects
# IMPORTANT: Replace the mock objects with your actual dds objects
counts_si <- counts(dds_si, normalized = TRUE)
counts_li <- counts(dds_li, normalized = TRUE)

# Filter the count matrices to include only the selected genes
counts_si_filtered <- counts_si[rownames(counts_si) %in% unique_genes_to_plot, ]
counts_li_filtered <- counts_li[rownames(counts_li) %in% unique_genes_to_plot, ]

# Combine them into a single matrix
combined_counts <- cbind(counts_si_filtered, counts_li_filtered)

# --- Step 3: Prepare Data and Annotations for the Heatmap ---

# Create the annotation data frame for the columns (samples)
annotation_col_si <- as.data.frame(colData(dds_si)[, c("tissue", "treatment")])
annotation_col_li <- as.data.frame(colData(dds_li)[, c("tissue", "treatment")])
annotation_col <- rbind(annotation_col_si, annotation_col_li)


# --- Step 4: Generate the Heatmap ---

# Define a colorblind-friendly Red-White-Blue color palette
my_colors <- colorRampPalette(rev(brewer.pal(n = 11, name = "RdBu")))(100)


# Generate the heatmap
pheatmap(
  combined_counts,
  main = "Top 100 upregulated genes from SI and LI (Contrast 1)",
  annotation_col = annotation_col,
   annotation_colors = ann_colors, # Use the custom colors
  #labels_row = final_gene_labels, # Use symbols as labels
  color = my_colors,
  scale = "row",                  # Scale genes to have mean 0 and SD 1
  cluster_cols = TRUE,            # Cluster columns (samples) based on similarity
  cluster_rows = TRUE,            # Cluster genes by expression pattern
  show_rownames = TRUE,           # Show the gene labels
  fontsize_row = 6,               # Adjust font size to fit more labels
  filename = "../data/heatmap_top_100_genes.png",
  width = 7,
  height = 7
)

```


## the enrichment plots

```{r}
# --- Large Intestine Plots ---

# 1. Interferon Alpha Response in the Large Intestine
p_li_ifn <- plotEnrichment(hallmark_pathways[["HALLMARK_INTERFERON_ALPHA_RESPONSE"]],
                           ranked_genes_li2) +
  labs(title = "Interferon Alpha Response") +
  theme(
        plot.subtitle = element_text(hjust = 0.5))


# 2. E2F Targets (Cell Cycle) in the Large Intestine
p_li_e2f <- plotEnrichment(hallmark_pathways[["HALLMARK_E2F_TARGETS"]],
                           ranked_genes_li2) +
  labs(title = "E2F Targets (Proliferation)") +
  theme(
        plot.subtitle = element_text(hjust = 0.5))


# --- Small Intestine Plots ---

# 3. Interferon Alpha Response in the Small Intestine
p_si_ifn <- plotEnrichment(hallmark_pathways[["HALLMARK_INTERFERON_ALPHA_RESPONSE"]],
                           ranked_genes_si2) +
  labs(title = "Interferon Alpha Response") +
  theme(
        plot.subtitle = element_text(hjust = 0.5))


# 4. E2F Targets (Cell Cycle) in the Small Intestine
p_si_e2f <- plotEnrichment(hallmark_pathways[["HALLMARK_E2F_TARGETS"]],
                           ranked_genes_si2) +
  labs(title = "E2F Targets (Proliferation)") +
  theme(
        plot.subtitle = element_text(hjust = 0.5))


# --- Arrange the plots into a 2x2 grid ---
# Using the patchwork library for easy and clean arrangement
(p_li_ifn + p_si_ifn) / (p_li_e2f + p_si_e2f)


```

# assemble 

```{r}
top_pca_all <- pca_plot

SI_enrichment <- plot_grid( p_si_ifn, p_si_e2f,
                       label_size = 12, ncol  =2,
                align = 'vh', axis = 'lrtb')

SI_panels <- plot_grid(p_si_contrast2, SI_Serpina10, sig_pw_bar_SI, p_si_ifn, p_si_e2f,
                       label_size = 12, ncol  =1,
                 rel_heights = c(1.2, 0.6,1.5,.8,.8),
                 #labels = "auto", 
                align = 'vh', axis = 'lrtb')

LI_enrichment <- plot_grid( p_li_ifn, p_li_e2f,
                       label_size = 12, ncol  =2,
                 #rel_heights = c(1.2,2,1.8),
                 #labels = "auto", 
                align = 'vh', axis = 'lrtb')

LI_panels <- plot_grid(p_li_contrast2, LI_Defa2, sig_pw_bar_LI, p_li_ifn, p_li_e2f,
                       label_size = 12, ncol  =1,
                 rel_heights = c(1.2, 0.6,1.5, .8,.8),
                 #labels = "auto", 
                align = 'vh', axis = 'lrtb')
     
                       
two_columns <-  plot_grid( SI_panels , LI_panels , 
                ncol  =2,
                 #rel_heights = c(1.2,2,1.8),labels = "auto", 
                align = 'vh', axis = 'lrtb')

final_plot <- plot_grid( top_pca_all , two_columns , 
                nrow  =2,
                 rel_heights = c(0.5,2),
                align = 'vh', axis = 'lrtb')


title <- ggdraw() + 
  draw_label("Supplemental Fig X",fontface = 'bold', x = 0,hjust = 0) +
  theme(plot.margin = margin(0, 0, 0, 0))

combined <- plot_grid(
  title, two_columns,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.05, 1)
) +theme(plot.margin = unit(c(1,1,1,1), "cm"))

ggsave('../data/R38_germ_free_RNAseq.pdf',
      width = 8.5, height = 16, units = "in", device = 'pdf', 
      dpi = 300)                    
```

# gsea combine

```{r}
# Arrange the Plots into a 2x2 Grid with Cowplot ---

# Arrange the SI plots into the top row
top_row <- plot_grid(sig_pw_bar_SI1, sig_pw_bar_SI, ncol = 2)

# Arrange the LI plots into the bottom row
bottom_row <- plot_grid(sig_pw_bar_LI1, sig_pw_bar_LI, ncol = 2)

# Create titles for the rows
si_title <- ggdraw() + draw_label("Small Intestine", fontface = 'bold', x = 0.5, size = 18)
li_title <- ggdraw() + draw_label("Large Intestine", fontface = 'bold', x = 0.5, size = 18)

# Combine the titled rows into the final plot
final_plot <- plot_grid(
  si_title,
  top_row,
  li_title,
  bottom_row,
  ncol = 1,
  rel_heights = c(0.1, 1, 0.1, 1) # Give space for the titles
)

# --- Step 4: Save the Final Figure ---

# Save the combined plot to a file
save_plot("../data/R38_gsea_summary_figure.pdf", final_plot, base_width = 14, base_height = 12)
```

## heatmap of the opposing two pathways

```{r}
# --- Step 1: Identify Key Genes from GSEA Results ---

# List your GSEA result dataframes
list_of_gsea_dfs <- lapply(list_of_dfs, function(df) {
  df %>%
    filter(padj < 0.05)
})

# Define the key opposing pathways you want to visualize
prolif_pathways <- c("HALLMARK_E2F_TARGETS", "HALLMARK_G2M_CHECKPOINT")
immune_pathways <- c("HALLMARK_INTERFERON_ALPHA_RESPONSE", "HALLMARK_INTERFERON_GAMMA_RESPONSE")

# A helper function to extract leading-edge genes for a set of pathways
get_leading_edge_genes <- function(gsea_list, target_pathways) {
  gsea_list %>%
    map_dfr(~ .x %>% filter(pathway %in% target_pathways)) %>%
    pull(leadingEdge) %>%
    unlist() %>%
    unique()
}

# Get the unique genes for each biological theme
prolif_genes <- get_leading_edge_genes(list_of_gsea_dfs, prolif_pathways)
immune_genes <- get_leading_edge_genes(list_of_gsea_dfs, immune_pathways)
genes_to_plot <- unique(c(prolif_genes, immune_genes))
```


```{r}
# --- Step 2: Extract and Prepare Normalized Count Data ---

all_counts_li <- genes_to_plot %>% 
  set_names(genes_to_plot) %>% 
  map(~get_gene_counts(dds_li, .x, "Large Intestine")) %>% 
  bind_rows(.id = 'gene')

all_counts_si <- genes_to_plot %>% 
  set_names(genes_to_plot) %>% 
  map(~get_gene_counts(dds_si, .x, "Small Intestine")) %>% 
  bind_rows(.id = 'gene')

```


## 4 heatmaps

```{r}
# --- Step 2: Prepare a Reusable Heatmap Plotting Function ---
# This function will take tidy counts, tissue name, and effect type to generate a heatmap object

generate_heatmap_grob <- function(tidy_counts_df, tissue_name, effect_type, show_legend = FALSE) {
  
  # Filter data based on the effect type
  if (effect_type == "Colonization") {
    plot_data_tidy <- tidy_counts_df %>% filter(str_detect(treatment, "regular_water"))
    main_title <- paste(tissue_name, "- Colonization Effect")
    treatment_colors <- setNames(c("#A2E8E6", "#00BFC4"), c("PBS__regular_water", "E. faecalis__regular_water"))
  } else if (effect_type == "Sucrose") {
    plot_data_tidy <- tidy_counts_df %>% filter(str_detect(treatment, "E. faecalis"))
    main_title <- paste(tissue_name, "- Sucrose Effect")
    treatment_colors <- setNames(c("#00BFC4", "#F8766D"), c("E. faecalis__regular_water", "E. faecalis__sucrose_water"))
  }
  
  # Filter for genes of interest
  plot_data_tidy <- plot_data_tidy %>% filter(gene %in% genes_to_plot)
  
  # Convert to matrix
  plot_matrix <- plot_data_tidy %>%
    dplyr::select(gene, sample_name, count) %>%
    pivot_wider(names_from = sample_name, values_from = count) %>%
    column_to_rownames("gene")
  
  # Create annotations
  annotation_col <- plot_data_tidy %>% dplyr::select(sample_name, treatment) %>% distinct() %>% column_to_rownames("sample_name")
  annotation_row <- data.frame(Pathway = case_when(
    rownames(plot_matrix) %in% prolif_genes ~ "Proliferation",
    rownames(plot_matrix) %in% immune_genes ~ "Immune Response"
  ))
  rownames(annotation_row) <- rownames(plot_matrix)
  
  # Order rows
  annotation_row <- annotation_row %>% arrange(Pathway)
  plot_matrix <- plot_matrix[rownames(annotation_row), ]
  
  # Gaps and colors
  gaps_row <- table(annotation_row$Pathway) %>% cumsum() %>% head(-1)
  ann_colors <- list(treatment = treatment_colors, Pathway = c(Proliferation = "#D95F02", `Immune Response` = "purple"))
  
  # Generate heatmap as a grob object
  pheatmap(
    plot_matrix, main = main_title, annotation_col = annotation_col,
    annotation_row = annotation_row, annotation_colors = ann_colors,
    scale = "row", cluster_cols = F, cluster_rows = FALSE,
    gaps_row = gaps_row, show_rownames = F, fontsize_row = 8,
    legend = T, annotation_legend = F, # Turn legends off
    silent = TRUE
  )$gtable
}

# --- Step 3: Generate the Four Heatmap Grobs ---

# Small Intestine Plots
p_si_col <- generate_heatmap_grob(all_counts_si, "Small Intestine", "Colonization")
p_si_suc <- generate_heatmap_grob(all_counts_si, "Small Intestine", "Sucrose")

# Large Intestine Plots
p_li_col <- generate_heatmap_grob(all_counts_li, "Large Intestine", "Colonization")
p_li_suc <- generate_heatmap_grob(all_counts_li, "Large Intestine", "Sucrose") # Show legend on one plot

# --- Step 4: Create a Shared Legend ---

# Define all possible annotation levels and their colors
all_treatment_colors <- setNames(
    c("#A2E8E6", "#00BFC4", "#F8766D"),
    c("PBS__regular_water", "E. faecalis__regular_water", "E. faecalis__sucrose_water")
)
all_pathway_colors <- setNames(c("#D95F02", "purple"), c("Proliferation", "Immune Response"))
all_ann_colors <- list(treatment = all_treatment_colors, Pathway = all_pathway_colors)

# Create dummy data that includes all these levels to ensure they appear in the legend
dummy_matrix <- matrix(1:6, nrow = 2, dimnames = list(c("G1", "G2"), c("S1", "S2", "S3")))
dummy_ann_col <- data.frame(treatment = names(all_treatment_colors))
rownames(dummy_ann_col) <- c("S1", "S2", "S3")
dummy_ann_row <- data.frame(Pathway = names(all_pathway_colors))
rownames(dummy_ann_row) <- c("G1", "G2")

# Generate a dummy heatmap just to steal its legend
legend_hm <- pheatmap(
    dummy_matrix, annotation_col = dummy_ann_col, annotation_row = dummy_ann_row,
    annotation_colors = all_ann_colors, legend = TRUE, annotation_legend = TRUE,
    silent = TRUE
)
shared_legend <- legend_hm$gtable$grobs[[which(legend_hm$gtable$layout$name == "legend")]]


# --- Step 5: Arrange Plots into a Final Figure ---

# Combine the four heatmap panels
p_grid <- plot_grid(
  p_si_col, p_si_suc,
  p_li_col, p_li_suc,
  ncol = 2,
  align = 'hv'
)

# Create a title for the entire figure
caption <- ggdraw() + 
  draw_label(
    "Gene Expression of Key Pathways Across Tissues and Treatments",
    fontface = 'bold', x = 0.5
  )

title <- ggdraw() + 
  draw_label("Supplemental Fig X",fontface = 'bold', x = 0,hjust = 0) +
  theme(plot.margin = margin(0, 0, 0, 0))

combined <- plot_grid(
  title, caption,shared_legend,p_grid,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.05, 0.05, 0.1, 1)
) +theme(plot.margin = unit(c(1,1,1,1), "cm"))

ggsave('../data/R38_combined_heatmaps_figure_top_legend.pdf',
      width = 8.5, height = 11, units = "in", device = 'pdf', 
      dpi = 300)  
```

