---
title: "GF mouse RNA-seq"
output: html_document
date: "2025-08-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(ggpubr)
library(edgeR)
library(DESeq2)
library(ggrepel)
library(cowplot)
library(patchwork)
library(ashr)
library(fgsea)       # For GSEA
library(msigdbr)     # To get MSigDB gene sets
```

Basic gene annotation is the main annotation file for most users. To ensure that reads mapped to these alternate regions are correctly counted, I must use the "ALL" GTF file. (mouse genome)

# making the sample meta data info table

```{r}
# Read the raw counts file to get the column names.
counts_data <- read_tsv("../data/raw_counts_matrix.tsv") %>%
  rename_with(.fn = ~ str_remove(.,"_IGO_\\d+.+$"), .cols = 2:dplyr::last_col())

sample_names <- colnames(counts_data)[-1] # This gets all column names except the first one ('Geneid').

# Now, build the metadata table.
meta_table <- tibble(sample_id = sample_names) %>%
  mutate(
    # Pull out the mouse identifier from the start of the sample name.
    mouse_id = str_extract(sample_id, "^\\d+_\\d+"),

    # Create a 'gavage_treatment' column.
    # If the mouse ID starts with '1_' or '2_', it's E. faecalis, otherwise it's PBS.
    gavage_treatment = case_when(
      str_starts(mouse_id, "1_") | str_starts(mouse_id, "2_") ~ "E. faecalis",
      TRUE ~ "PBS"
    ),

    # Create a 'diet_treatment' column.
    # If the mouse ID starts with '1_' or '3_', the diet is sucrose water.
    diet_treatment = case_when(
      str_starts(mouse_id, "1_") | str_starts(mouse_id, "3_") ~ "sucrose_water",
      TRUE ~ "regular_water"
    ),

    # Create a 'tissue' column.
    # If the sample name contains '_LI_', it's from the large intestine.
    tissue = if_else(str_detect(sample_id, "_LI"), "large_intestine", "small_intestine")
  ) %>% 
  mutate(
    # Use 'across()' to apply the as.factor function to all these columns at once
    across(c(mouse_id, diet_treatment), as.factor),
    gavage_treatment = factor(gavage_treatment, levels = c('PBS','E. faecalis')),
    treatment = str_glue('{gavage_treatment}__{diet_treatment}'),   
    treatment = factor(treatment, levels = c('E. faecalis__regular_water','E. faecalis__sucrose_water','PBS__regular_water','PBS__sucrose_water')),
  )

# Display the first few rows of the new table to check the result.
print(meta_table)
levels(meta_table$treatment)
```

## normalization to cpm and filtering

```{r}
raw_counts_matrix <- counts_data %>% column_to_rownames('Geneid') %>% as.matrix()
cpm_matrix <- cpm(raw_counts_matrix)

# ---  Calculate Genes Kept at Different Thresholds ---
# Define the range of CPM thresholds to test.
cpm_thresholds <- seq(0.5, 10, by = 0.5)

# This function will count how many genes pass the filter for a given threshold.
# The rule is: at least 3 samples must be >= the threshold.
count_genes_kept <- function(threshold, cpm_data) {
  # 'apply' goes through each row (gene) of the matrix.
  # For each row, it checks how many sample values are >= the threshold.
  # The result is a vector of TRUE/FALSE for each gene.
  genes_to_keep <- apply(cpm_data, 1, function(gene_row) {
    sum(gene_row >= threshold) >= 3
  })
  # Finally, sum up the TRUE values to get the total number of genes kept.
  return(sum(genes_to_keep))
}

# Apply the function to every threshold in our sequence.
genes_left <- map_int(cpm_thresholds, ~count_genes_kept(., cpm_matrix))

# Combine the thresholds and the gene counts into a results table.
results_df <- tibble(
  cpm_threshold = cpm_thresholds,
  genes_remaining = genes_left
)

# Create the plot.
ggplot(results_df, aes(x = cpm_threshold, y = genes_remaining)) +
  geom_line(color = "dodgerblue", size = 1) +
  geom_point(color = "dodgerblue", size = 2) +
  labs(
    title = "Effect of CPM Threshold on Gene Filtering",
    x = "CPM Threshold (gene kept if expressed in at least 3 samples)",
    y = "Number of Genes Remaining"
  ) +
  theme_minimal() +
  # Add grid lines for easier reading of values.
  theme(panel.grid.major = element_line(color = "grey85"),
        panel.grid.minor = element_line(color = "grey90"))
# 2.5 is a good elbow point
```

## CPM 2.5 filtering

```{r}
# --- 3. Define Filtering Thresholds --- 
cpm_threshold <- 2.5   
min_samples <- 3       # Minimum number of samples that must meet the CPM threshold

# --- 4. Apply the Filter ---

# Create a logical matrix: TRUE if CPM > threshold, FALSE otherwise
passes_cpm_threshold_matrix <- cpm_matrix > cpm_threshold

# Count how many samples pass the threshold for each gene (summing TRUEs row-wise)
samples_passing_per_gene <- rowSums(passes_cpm_threshold_matrix)

# Identify genes that meet the criteria (TRUE if gene should be kept)
genes_to_keep_logical <- samples_passing_per_gene >= min_samples
cat(sprintf("\nNumber of genes to keep: %d (out of %d)\n", sum(genes_to_keep_logical), nrow(raw_counts_matrix)))


# --- 5. Create the Filtered Raw Count Matrix ---
# Use the logical vector to subset the original raw count matrix
filtered_raw_counts_matrix <- raw_counts_matrix[genes_to_keep_logical, ]
```

## PCA to visualize the expression profiles between differnt treatment conditions

```{r}
# --- 1. Data Transformation ---
# Raw counts are not ideal for PCA. We need to transform them to stabilize variance.
# Variance Stabilizing Transformation (VST) or regularized log (rlog) from DESeq2 are good choices.

# Create a DESeqDataSet object.
# For VST/rlog, the design formula can be simple if you're just transforming for PCA,
# e.g., ~1, or you can use your main experimental design like ~condition.
# Using the main design can sometimes help stabilize variance better with respect to known factors.
colData <- meta_table %>% column_to_rownames('sample_id')
```


```{r}
dds <- DESeqDataSetFromMatrix(
  countData = round(filtered_raw_counts_matrix), # DESeq2 expects integer counts
  colData = colData,
  design = ~ tissue + treatment # This model will still account for the large differences between tissues while looking for the effects of diet and gavage. You lose the ability to explicitly model the paired nature of the samples, but it's the necessary trade-off to make the model work with this experimental design.
)

# Apply Variance Stabilizing Transformation  
# For very small datasets (e.g. < 10-12 samples per group), rlog might be preferred by some.
rld <- rlog(dds, blind = TRUE) # blind=TRUE: transform agnostic to the design (good for QC/PCA)
transformed_counts <- assay(rld)

# --- 2. Select Most Variable Genes (Optional, but often recommended for PCA) ---
# PCA works best when performed on genes that show the most variation across samples.
num_top_genes <- 500 # You can adjust this number

# Calculate row variances
rv <- rowVars(transformed_counts)

# Select the N most variable genes
select <- order(rv, decreasing = TRUE)[seq_len(min(num_top_genes, length(rv)))]
top_variable_transformed_counts <- transformed_counts[select, ]

cat(sprintf("\nPerforming PCA on the top %d most variable genes.\n", num_top_genes))
cat("Dimensions of matrix for PCA (genes x samples):\n")
print(dim(top_variable_transformed_counts))

# --- 3. Perform PCA ---
# prcomp expects samples as rows and variables (genes) as columns.
# So, we need to transpose our matrix.
pca_input <- t(top_variable_transformed_counts)
pca_results <- prcomp(pca_input, scale. = FALSE, center = TRUE) # VST/rlog are already roughly on the same scale

# Summary of PCA
# print(summary(pca_results))

# Extract PCA scores for plotting
pca_data <- as.data.frame(pca_results$x)
pca_data$sample <- rownames(pca_data) # Add sample names

# Merge with sample conditions for coloring points
pca_data <- merge(pca_data, meta_table, by.x = "sample", by.y = "sample_id")

# Calculate percentage of variance explained by each PC
percent_variance <- round(100 * pca_results$sdev^2 / sum(pca_results$sdev^2), 1)

cat("\nFirst few rows of data prepared for PCA plotting:\n")
print(head(pca_data))

# --- 4. Plot PCA Results using ggplot2 ---
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = treatment, shape = tissue)) +
  geom_point(size = 3) +
  xlab(paste0("PC1: ", percent_variance[1], "% variance")) +
  ylab(paste0("PC2: ", percent_variance[2], "% variance")) +
  ggtitle("PCA of Samples") +
  theme_bw(base_size = 14) +
  theme(legend.position = "right") +
  coord_fixed() # Ensures PC1 and PC2 are on the same scale visually

# Optional: Add sample labels (can be crowded)
#pca_plot <- pca_plot + geom_text_repel(aes(label = sample), size = 2)

print(pca_plot)
ggsave('../data/R38_pca_gf.png', width = 10)
# given the massive tissue effect shown in the PCA, splitting the data by tissue and analyzing them separately is the best path forward.
```

# split by tissue PCA   

```{r}
# --- 2. Split Data by Tissue ---
# Create metadata for the Small Intestine (SI)
meta_si <- meta_table %>% filter(tissue == "small_intestine")
# Create metadata for the Large Intestine (LI)
meta_li <- meta_table %>% filter(tissue == "large_intestine")

# Subset the counts matrix for each tissue based on the sample IDs in the new metadata
counts_si <- filtered_raw_counts_matrix[,meta_si$sample_id]
counts_li <- filtered_raw_counts_matrix[,meta_li$sample_id]

# --- 3. PCA for Small Intestine ---
# Create the DESeq2 object for the SI
dds_si <- DESeqDataSetFromMatrix(
  countData = counts_si,
  colData = meta_si,
  design = ~ treatment
)

# Apply the variance stabilizing transformation, which is great for visualizations like PCA
vst_si <- vst(dds_si, blind = TRUE)

# Generate the PCA plot for the SI using ggplot2
pca_plot_si <- plotPCA(vst_si, intgroup = "treatment") +
  ggtitle("PCA of Small Intestine Samples") +
  theme_minimal() +
  # Make the points a bit larger for clarity
  geom_point(size = 4) +
  coord_fixed()

# --- 4. PCA for Large Intestine ---
# Now, do the exact same process for the LI
dds_li <- DESeqDataSetFromMatrix(
  countData = counts_li,
  colData = meta_li,
  design = ~ treatment
)
vst_li <- vst(dds_li, blind = TRUE)

pca_plot_li <- plotPCA(vst_li, intgroup = "treatment") +
  ggtitle("PCA of Large Intestine Samples") +
  theme_minimal() +
  geom_point(size = 4) +
  coord_fixed()+
  theme(legend.position = "right")

# --- 5. Combine and Display the Plots ---
# Use the 'patchwork' library to combine the two plots into one figure
combined_pca_plot <- pca_plot_si + pca_plot_li+
  plot_layout(guides = 'collect')

# Display the final figure
print(combined_pca_plot)
ggsave('../data/R38_pca_gf_split.png', width = 10)
```

# Differential gene expression analysis

## LI

```{r}
# ==============================================================================
#  ANALYSIS FOR LARGE INTESTINE (LI)
# ==============================================================================
print("--- Starting DGE Analysis for Large Intestine ---")

# --- 2. Run the main DESeq2 function ---
# This step performs differential expression analysis on all groups.
dds_li <- DESeq(dds_li)

# --- 3. Extract and filter Contrast 1: E. faecalis effect ---
# We are comparing PBS vs. E. faecalis in mice given regular water.

#Think of the contrast argument in DESeq2 like this:
# c("variable", "numerator", "denominator")
# The function calculates the log2 fold change as log2(numerator / denominator).

print("--- LI Contrast 1: PBS_regular_water vs E. faecalis_regular_water ---")
results_li_contrast1 <- results(dds_li,
                                contrast = c("treatment",  "E. faecalis__regular_water", "PBS__regular_water"),
                                alpha = 0.05) # Set our significance cutoff

# Apply LFC shrinkage to get more accurate fold change estimates.
shrunken_li_contrast1 <- lfcShrink(dds_li,
                                   contrast = c("treatment",  "E. faecalis__regular_water", "PBS__regular_water"),
                                   res = results_li_contrast1,
                                   type = "ashr")

# Filter the shrunken results for significance.
sig_li_contrast1 <- as.data.frame(shrunken_li_contrast1) %>%
  rownames_to_column("gene") %>%
  filter(padj < 0.05 & abs(log2FoldChange) > 1)

# Summarize the findings
print(paste("Found", nrow(sig_li_contrast1), "significant genes."))
print(table(sig_li_contrast1$log2FoldChange > 0))
# and the log2fc is really small...basically there isn't much change
```

```{r}
# --- 4. Extract and filter Contrast 2: Sucrose effect ---
# We are comparing sucrose vs. regular water in mice given E. faecalis.
print("--- LI Contrast 2: E. faecalis_sucrose_water vs E. faecalis_regular_water ---")
results_li_contrast2 <- results(dds_li,
                                contrast = c("treatment", "E. faecalis__sucrose_water", "E. faecalis__regular_water"),
                                alpha = 0.05)

shrunken_li_contrast2 <- lfcShrink(dds_li,
                                   contrast = c("treatment", "E. faecalis__sucrose_water", "E. faecalis__regular_water"),
                                   res = results_li_contrast2,
                                   type = "ashr")

sig_li_contrast2 <- as.data.frame(shrunken_li_contrast2) %>%
  rownames_to_column("gene") %>%
  filter(padj < 0.05 & abs(log2FoldChange) > 1)

print(paste("Found", nrow(sig_li_contrast2), "significant genes."))
print(table(sig_li_contrast2$log2FoldChange > 0))
```

## SI

```{r}
# ==============================================================================
#  ANALYSIS FOR SMALL INTESTINE (SI)
# ==============================================================================
print("--- Starting DGE Analysis for Small Intestine ---")

# --- 5. Repeat the entire process for the SI dataset ---
dds_si <- DESeq(dds_si)

# Contrast 1: E. faecalis effect
print("--- SI Contrast 1: PBS_regular_water vs E. faecalis_regular_water ---")
results_si_contrast1 <- results(dds_si, contrast = c("treatment",  "E. faecalis__regular_water", "PBS__regular_water"), alpha = 0.05)
shrunken_si_contrast1 <- lfcShrink(dds_si, contrast = c("treatment", "E. faecalis__regular_water", "PBS__regular_water"), res = results_si_contrast1, type = "ashr")
sig_si_contrast1 <- as.data.frame(shrunken_si_contrast1) %>%
  rownames_to_column("gene") %>%
  filter(padj < 0.05 & abs(log2FoldChange) > 1)
print(paste("Found", nrow(sig_si_contrast1), "significant genes."))
print(table(sig_si_contrast1$log2FoldChange > 0))
```

```{r}
# Contrast 2: Sucrose effect
print("--- SI Contrast 2: E. faecalis_sucrose_water vs E. faecalis_regular_water ---")
results_si_contrast2 <- results(dds_si, contrast = c("treatment", "E. faecalis__sucrose_water", "E. faecalis__regular_water"), alpha = 0.05)
shrunken_si_contrast2 <- lfcShrink(dds_si, contrast = c("treatment", "E. faecalis__sucrose_water", "E. faecalis__regular_water"), res = results_si_contrast2, type = "ashr")
sig_si_contrast2 <- as.data.frame(shrunken_si_contrast2) %>%
  rownames_to_column("gene") %>%
  filter(padj < 0.05 & abs(log2FoldChange) > 1 )
print(paste("Found", nrow(sig_si_contrast2), "significant genes."))
print(table(sig_si_contrast2$log2FoldChange > 0))
```


## volcano plots

```{r}
# --- 2. Set up Gene Symbol Annotation ---
# We need an annotation database to map Ensembl IDs to gene symbols in a mouse experiment. 
library(org.Mm.eg.db)
library(AnnotationDbi)

# --- 3. Create a Reusable Plotting Function ---
# Since we are making four similar plots, a function is the cleanest approach.
create_volcano_plot <- function(shrunken_results, plot_title) {

  # Convert the results to a data frame and remove Ensembl versions for mapping
  results_df <- as.data.frame(shrunken_results) %>%
    rownames_to_column("ensembl_version") %>%
    mutate(ensembl_id = str_remove(ensembl_version, "\\..*"))

  # Map Ensembl IDs to gene symbols. 'mapIds' will return NA for any ID it can't find.
  results_df$symbol <- mapIds(org.Mm.eg.db,
                              keys = results_df$ensembl_id,
                              column = "SYMBOL",
                              keytype = "ENSEMBL",
                              multiVals = "first")

  # Create a column to identify significant genes for coloring and labeling
  results_df <- results_df %>%
    mutate(significant = ifelse(padj < 0.05 & abs(log2FoldChange) > 1, "Yes", "No"))

  # Generate the plot
  ggplot(results_df, aes(x = log2FoldChange, y = -log10(padj))) +
    # Add points, colored by significance
    geom_point(aes(color = significant), alpha = 0.6) +
    scale_color_manual(values = c("No" = "grey", "Yes" = "red"), name = "") +
    
    # Add the dashed line for the FDR 0.05 cutoff
    geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
    
    # Add vertical dashed lines for the log2FoldChange threshold
    geom_vline(xintercept = -1, linetype = "dashed", color = "black") +
    geom_vline(xintercept = 1, linetype = "dashed", color = "black") +
    
    # Add gene symbols for significant genes using ggrepel
    geom_text_repel(aes(label = symbol),
                    data = subset(results_df, padj < 0.05 & abs(log2FoldChange) > 1),
                    max.overlaps = 15, # Increase to allow more labels
                    box.padding = 0.5) +
    
    labs(title = plot_title,
         x = "Log2 Fold Change",
         y = "-log10(Adjusted P-value)") +
    theme_minimal() +
    theme(legend.position = "none") # Hide the individual legends
}

# --- 4. Generate Each of the Four Plots ---
# Create each volcano plot by calling the function with the corresponding results.
# Small Intestine Plots
p_si_contrast1 <- create_volcano_plot(shrunken_si_contrast1, "SI: E. faecalis vs PBS (Regular Water)") 
p_si_contrast2 <- create_volcano_plot(shrunken_si_contrast2, "SI: E. faecalis (Sucrose vs Regular Water)")

# Large Intestine Plots
p_li_contrast1 <- create_volcano_plot(shrunken_li_contrast1, "LI: E. faecalis vs PBS (Regular Water)")    
p_li_contrast2 <- create_volcano_plot(shrunken_li_contrast2, "LI: E. faecalis (Sucrose vs Regular Water)")

# --- 5. Arrange Plots into a 2x2 Grid ---
# Use patchwork to combine the plots. The '/' operator stacks plots vertically.
(p_si_contrast1 + p_si_contrast2) / (p_li_contrast1 + p_li_contrast2)
ggsave('../data/R38_DEG_volcano.png', width = 15, height = 9)
```
## plot gene counts

```{r}
# --- Step 1: Identify the Top Two Most Downregulated Genes ---

# Convert results to a dataframe for easier manipulation
results_df_li2 <- as.data.frame(shrunken_li_contrast2) %>%
  rownames_to_column("ensembl_version")

# Find the top 2 downregulated genes (negative log2FoldChange, sorted by p-value)
top_downregulated_genes <- results_df_li2 %>%
  filter(log2FoldChange < 0) %>%
  arrange(log2FoldChange) %>%
  head(2)

# Extract the Ensembl IDs (with version) of these top genes
top_gene_ids <- top_downregulated_genes$ensembl_version

# --- Step 2: Prepare Data for Plotting ---

# Get the normalized counts for all genes
normalized_counts <- counts(dds_li, normalized = TRUE)

# Get the sample metadata (e.g., conditions)
sample_info <- as.data.frame(colData(dds_li))

# Filter the normalized counts to just our top genes and format for ggplot
plot_data <- normalized_counts[top_gene_ids, ] %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column("sample_name") %>%
  # Join with the sample metadata to get the experimental conditions
  left_join(sample_info %>% rownames_to_column("sample_name"), by = "sample_name") %>%
  # Convert from wide to long format for plotting
  pivot_longer(cols = all_of(top_gene_ids), names_to = "ensembl_version", values_to = "normalized_count")

# --- Step 3: Add Gene Symbols for Clearer Labels ---

# Create a clean Ensembl ID without the version number
plot_data <- plot_data %>%
  mutate(ensembl_id = str_remove(ensembl_version, "\\..*"))

# Map the clean Ensembl IDs to gene symbols
gene_symbols <- mapIds(org.Mm.eg.db,
                       keys = unique(plot_data$ensembl_id),
                       column = "SYMBOL",
                       keytype = "ENSEMBL",
                       multiVals = "first")

# Add the gene symbols to our plotting data
plot_data$symbol <- gene_symbols[plot_data$ensembl_id]

# --- Step 4: Generate the Boxplots ---

# Create a plot for each gene using facet_wrap
ggplot(plot_data, aes(x = treatment, y = normalized_count, fill = treatment)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.1, alpha = 0.8) + # Overlay individual data points
  facet_wrap(~symbol, scales = "free_y") + # Create a separate plot for each gene
  #scale_fill_manual(values = c("Sucrose" = "#F8766D", "Regular" = "#00BFC4")) +
  labs(
    title = "Abundance of Top 2 Downregulated Genes",
    subtitle = "LI: E. faecalis (Sucrose vs Regular Water)",
    x = "Treatment",
    y = "Normalized Gene Count"
  ) +
  theme_minimal(base_size = 14) +
  scale_y_sqrt() +
  theme(
    legend.position = "none",
    axis.text.x = element_text(angle = 45,  hjust=1),
    strip.text = element_text(face = "bold.italic") # Style the gene names
  )


```

## Serpina10

```{r}
get_gene_counts <- function(dds_object, gene_symbol, tissue_name) {
  
  # Create a mapping from clean Ensembl IDs to the versioned IDs in the DDS object
  ensembl_map <- data.frame(
    ensembl_version = rownames(dds_object)
  ) %>%
    mutate(ensembl_id = str_remove(ensembl_version, "\\..*"))
  
  # Find the clean Ensembl ID for our target gene symbol
  target_ensembl_id <- mapIds(org.Mm.eg.db,
                              keys = gene_symbol,
                              column = "ENSEMBL",
                              keytype = "SYMBOL",
                              multiVals = "first")
  
  # Check if the gene symbol was found
  if (is.na(target_ensembl_id)) {
    stop(paste("Gene symbol", gene_symbol, "not found in org.Mm.eg.db."))
  }
  
  # Find the full, versioned Ensembl ID corresponding to our clean ID
  target_ensembl_version <- ensembl_map %>%
    filter(ensembl_id == target_ensembl_id) %>%
    pull(ensembl_version) %>%
    unique()
    
  # Check if the gene was found in the DDS object
  if (length(target_ensembl_version) == 0) {
    stop(paste(gene_symbol, "not found in the provided DESeqDataSet object."))
  }
  
  # Use plotCounts to extract normalized data for the gene
  plot_df <- plotCounts(dds_object, 
                        gene = target_ensembl_version[1], # Use the first match if multiple exist
                        intgroup = "treatment", 
                        returnData = TRUE) %>%
    rownames_to_column("sample_name") %>%
    mutate(tissue = tissue_name) # Add the tissue label
    
  return(plot_df)
}

# --- Step 1: Extract Serpina10 counts from both dds objects ---
# This assumes 'dds_li' and 'dds_si' are your DESeqDataSet objects.
li_counts <- get_gene_counts(dds_li, "Serpina10", "Large Intestine")
si_counts <- get_gene_counts(dds_si, "Serpina10", "Small Intestine")

# --- Step 2: Combine the data from both tissues ---
combined_counts <- rbind(li_counts, si_counts)
```


```{r}
# --- Step 3: Generate the boxplots ---
ggplot(combined_counts, aes(x = treatment, y = count, fill = treatment)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.8, height = 0) + # Overlay individual data points
  facet_wrap(~tissue, scales = "free_y") + # Create separate plots for LI and SI
  
  # Use the same colors as the previous plot for consistency
  #scale_fill_manual(values = c("Sucrose" = "#F8766D", "Regular" = "#00BFC4", "PBS" = "grey")) +
  
  labs(
    title = "Normalized Abundance of Serpina10",
    x = "Treatment",
    y = "Normalized Gene Count"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 12), # Style the facet titles
    axis.text.x = element_text(angle = 45,  hjust=1),
    plot.title = element_text(hjust = 0.5, face = "bold")
  ) 
```


