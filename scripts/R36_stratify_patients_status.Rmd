---
title: "Stratification by patient status"
output: html_document
date: "2025-08-04"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(broom.mixed)
library(brms)   
library(ggpubr)
library(patchwork)
library(tidybayes)
library(cowplot)
library(ggridges)
library(brmstools)
library(bayesplot)
library(gt)
options(mc.cores = parallel::detectCores())
rstan::rstan_options(auto_write = TRUE)
theme_set(theme_tidybayes() + panel_border())
ncores <- parallel::detectCores()
```

- Why Not to Split the Data     
  
- Loss of Power

- Wasted Information: The model learns about the general effects of diet and antibiotics from the entire cohort. By splitting the data, you prevent the model from "borrowing strength" across the groups, making your estimates less precise.

- No Direct Comparison: Running three separate models doesn't actually give you a statistical test to say whether the effect of sweets * abx is significantly different between the ablative and non-ablative groups.

# run three way interaction model

I am testing if the effect of sweets * abx depends on the intensity level. In statistical terms, you are testing for an interaction between (sweets * abx) and intensity.

```{r}
meta <- read_csv('../data/153_combined_META.csv') %>% 
  mutate(pid = factor(pid)) %>%
    # This divides all the new intake columns by 100.
  mutate(across(starts_with("fg_"), ~ .x / 100))      
```

```{r}
# Combine the main food groups and the current sweet variable
other_food_terms <- meta %>% select(starts_with('fg')) %>% select(-fg_sweets) %>% colnames()

other_food_terms_ <- paste(other_food_terms, collapse = ' + ')

sweet_interaction_term <- 'fg_sweets * empirical * intensity'

all_terms <- paste(other_food_terms_, sweet_interaction_term, sep =  ' + ')

# Build the full formula string dynamically
formula_string <- paste(
  "log(simpson_reciprocal) ~ 0   + TPN + EN +",
  all_terms,
  "+ (1 | pid) + (1 | timebin)"
)

# Convert the string to a formula object
formula <- brms::bf(as.formula(formula_string))

# Build the priors by adding them together.
# This single prior() call applies to all coefficients listed in `all_food_coefs`.
priors <-
  prior(normal(0, 1), class = 'b') + # General prior for all food effects
  # Specific priors that override the general one for non-food covariates
  prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE") +
  prior(normal(0, 0.1), class = 'b', coef = "ENTRUE") +
  prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE") 

# Fit the model (using fewer iterations for this example to run quickly)
model_fit <- brm(
  formula = formula,
  data = meta,
  prior = priors,
  warmup = 1000, iter = 3000,
  chains = 2, cores = 10, # Adjust cores as needed
  seed = 123,
  silent = 2
)

# Tidy the output and return only the interaction term for the sweet subcategory
model_results <- tidy(model_fit, conf.int = TRUE)  # it is the 95% CI by default
```
```{r}
library(emmeans)

# 1. Calculate the "Slope" (Trend) of sweets for every group
# This function automatically sums the main effects + interaction terms
sweets_slopes <- model_fit |> 
  emtrends(
    specs = ~ intensity + empirical,  # Break it down by these groups
    var = "fg_sweets"                 # Calculate the slope of this variable
  )

# 2. Extract the posterior draws to make the plot
plot_data <- sweets_slopes |>
  gather_emmeans_draws() |> 
  # IMPORTANT: Filter to only show the Antibiotics group (empirical = TRUE)
  # This answers the reviewer's specific concern about patients on Abx
  filter(empirical == "TRUE") 

# 3. Create the Forest Plot (The "Combined Effect")
ggplot(plot_data, aes(x = .value, y = intensity)) +
  # Plot the median (dot) and 95% Credible Interval (line)
  stat_pointinterval(point_interval = median_qi, .width = 0.95) +
  # Add a reference line at 0 (No effect)
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  labs(
    title = "Combined Effect of Sweets on Microbiome Diversity",
    subtitle = "Marginal effect of sweets intake during antibiotic exposure",
    x = "Estimated Change in log(Diversity) per 100g Sweets",
    y = "Conditioning Intensity"
  ) +
  theme_minimal()
```


```{r}
# ---  Calculate Conditional Effects Correctly Using Posterior Draws ---
# This is the statistically sound way to calculate the effect for each group.
# It uses the full posterior distribution to correctly propagate uncertainty.

# First, extract the posterior draws for the relevant coefficients.
# The 'as_draws_df' function converts the model's posterior samples into a tidy data frame.
posterior_draws <- as_draws_df(model_fit)

# Now, calculate the conditional effect for each draw.
conditional_effects_draws <- posterior_draws %>%
  transmute(
    # The effect for the Ablative group is just its own coefficient.
    `Ablative` = `b_fg_sweets:empiricalTRUE`,
    
    # The effect for the Reduced group is the baseline effect + its interaction term.
    `Reduced Intensity` = `b_fg_sweets:empiricalTRUE` + `b_fg_sweets:empiricalTRUE:intensityreduced`,
    
    # The effect for the Non-Ablative group is the baseline effect + its interaction term.
    `Non-Ablative` = `b_fg_sweets:empiricalTRUE` + `b_fg_sweets:empiricalTRUE:intensitynonablative`
  )

# ---  Summarize the Posterior to Get Point Estimates and Intervals ---
# Now we summarize the thousands of draws for each conditional effect into a
# point estimate (the mean of the draws) and a credible interval (the quantiles).

plot_data <- conditional_effects_draws %>%
  # Convert the data to a long format for easy summarization and plotting
  pivot_longer(
    cols = everything(),
    names_to = "term_label",
    values_to = "estimate"
  ) %>%
  # Group by each term to summarize
  group_by(term_label) %>%
  # Use mean_qi to get the mean (point estimate) and the 95% credible interval
  mean_qi(estimate) %>%
  # Rename columns to match the plotting code below
  rename(conf.low = .lower, conf.high = .upper) %>%
  # Make the labels a factor to control their order on the plot
  mutate(term_label = fct_relevel(term_label, "Non-Ablative", "Reduced Intensity", "Ablative")) %>% 
  mutate(is_significant = (conf.low * conf.high) > 0)


# --- 4. Create the More Intuitive Coefficient Plot ---
results <- ggplot(plot_data, aes(x = estimate, y = term_label)) +
  # Add a vertical line at zero. If a credible interval crosses this line,
  # the effect is not statistically significant.
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey70") +
  
  # Add the error bars (the "whiskers") representing the 95% credible interval
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high,  color = is_significant), height = 0.2, linewidth = 0.8) +
  
  # Add the points representing the model's posterior mean for each term
  geom_point(size = 4, aes(  color = is_significant)) +
  scale_color_manual(values = c("TRUE" = "red", "FALSE" = "gray50"), guide = "none") +
  
  # Add labels and a title
  labs(
    title = "\nAssociation of Sweets + Antibiotics on Microbiome Diversity",
    subtitle = "for each conditioning intensity group",
    x = "Estimated Change in log(Diversity)",
    y = "" # No y-axis label needed
  ) +
  
  # Use a clean theme
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(size = 14),
    panel.grid.major.y = element_blank(), # Remove horizontal grid lines
    plot.title.position = "plot"
  )

results
```

# include the tally of the patients and samples in the three intensity again

```{r}
# --- Generate the summary table ---
sample_data <- meta
# Calculate total number of unique patients and samples for percentage calculations
total_patients <- n_distinct(sample_data$pid)
total_samples <- nrow(sample_data)

summary_table <- sample_data %>%
  # Group data by the conditioning intensity
  group_by(intensity) %>%
  # Calculate counts for patients (distinct) and samples (all rows)
  summarise(
    patient_n = n_distinct(pid),
    sample_n = n(),
    .groups = 'drop' # Drop grouping for the next steps
  ) %>%
  # Calculate the percentage relative to the total
  mutate(
    patient_pct = patient_n / total_patients,
    sample_pct = sample_n / total_samples,
    # Reformat intensity names 
    intensity = case_when(
      intensity == "ablative" ~ "Ablative",
      intensity == "reduced" ~ "Reduced Intensity",
      intensity == "nonablative" ~ "Non-Ablative"
    )
  ) %>% 
  arrange(factor(intensity, levels = c("Ablative", "Reduced Intensity", "Non-Ablative"))) 

# --- Format the table with the 'gt' package ---
summary_table %>%
  gt() %>%
  # Re-label the columns for clarity
  cols_label(
    intensity = "Conditioning Intensity",
    patient_n = "Patients (n)",
    patient_pct = "Patients (%)",
    sample_n = "Samples (n)",
    sample_pct = "Samples (%)"
  ) %>%
  # Format the percentage columns
  fmt_percent(
    columns = c(patient_pct, sample_pct),
    decimals = 1
  ) %>%
  # Add a source note
  tab_source_note(
    source_note = md(paste0("Based on a total of **", total_samples, "** samples from **", total_patients, "** patients."))
  ) %>%
  # Add a spanning header to group related columns
  tab_spanner(
    label = md("**Patient Counts**"),
    columns = c(patient_n, patient_pct)
  ) %>%
  tab_spanner(
    label = md("**Sample Counts**"),
    columns = c(sample_n, sample_pct)
  )%>%
  # Add some final styling options for a polished look.
  opt_table_font(font = "sans-serif") %>%
  gt::gtsave(filename = "../data/R36_number_tally_intensity.png") 
```

# assemble 

```{r}
table_tally_intensity <- ggdraw() + draw_image("../data/R36_number_tally_intensity.png", scale = 1)


final_plot <- plot_grid( table_tally_intensity ,  results , 
                nrow  =1,
                 rel_widths  = c(1, 0.6),
                labels = 'auto',
                align = 'hv', axis = 'b')


title <- ggdraw() + 
  draw_label("Rebuttal Fig X",fontface = 'bold', x = 0,hjust = 0) +
  theme(plot.margin = margin(0, 0, 0, 0))

combined <- plot_grid(
  title, final_plot,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
) +theme(plot.margin = unit(c(1,3,1,1), "cm"))

ggsave('../data/R36_threeway_intensity.pdf',
      width = 11, height = 4, units = "in", device = 'pdf', plot = final_plot,
      dpi = 300)     


ggsave('../data/R36_threeway_intensity_model_results.pdf',
      width = 3, height = 3, units = "in", device = 'pdf', plot = results,
      dpi = 300)   
```

# the loess in the scatter plot

to answer the reviewer’s  question “Could patients with severe conditioning effects be more likely to consume sweets” 



```{r}

ptb <- read_csv('../../MSS_pipeline-/scripts/food_tree/data/156_combined_PTB.csv')

dtb <- read_csv('../data/152_combined_DTB.csv') |> 
  left_join(ptb |> select(pid, intensity))
  
  

# --- Data Preparation ---

# First, create a "scaffold" of all unique patient-day combinations.
# This is essential for the imputation step, ensuring any day a patient
# had *any* food is represented, even if they didn't have sweets.
scaffold <- dtb |>
  distinct(pid, fdrt, intensity)

# --- Plot 1: Daily Sweets Intake ---

# Calculate daily sweets intake.
# We must first filter for food codes starting with '9' (as strings).
sweets_summary <- dtb |>
  mutate(Food_code_str = as.character(Food_code)) |>
  filter(str_starts(Food_code_str, "9")) |>
  group_by(pid, fdrt) |>
  summarize(daily_sweets = sum(dehydrated_weight, na.rm = TRUE)) |>
  ungroup()

# Join the sweets data back to the main scaffold.
# A left_join keeps all rows from the scaffold.
# 'replace_na' fills in 0 for patient-days that had no sweets.
plot_data_1 <- scaffold |>
  left_join(sweets_summary, by = c("pid", "fdrt")) |>
  mutate(daily_sweets = replace_na(daily_sweets, 0))

# Build the plot for sweets
p1 <- plot_data_1 |>
  ggplot(aes(x = fdrt, y = daily_sweets, color = intensity)) +
   geom_point(alpha = 0.05, shape = 16) +
    
    # Add the LOESS smoothing line.
    # 'method = "loess"' specifies the type of smoother.
    # 'se = FALSE' removes the confidence interval band around the line.
    # 'color = "blue"' sets the line color to be distinct (you can change this).
    geom_smooth(method = "loess", se = FALSE,  aes(color = intensity), size = 1.2) +
    
    # Apply a minimal, clean theme to the plot.
    theme_classic(base_size = 11) +
    scale_y_sqrt() +
  scale_color_manual(values = c(
    "ablative" = "blue",   # Electric Yellow
    "reduced" = "#DC143C", # Crimson Red
    "nonablative" = "green"     # Oxford Blue
  )) +
  labs(
    #title = "Daily Sweets Intake vs.\nDay Relative to Transplant",
    x = "Day Relative to Transplant",
    y = "Daily Sweets (dehydrated weight)",
    color = "Conditioning intensity"
  ) +
   theme(aspect.ratio = 1, legend.position = 'right')

p1

# --- Plot 2: Daily Sugar Intake ---

# For total sugar, the process is simpler.
# We just group the *entire* dataset by patient-day and sum 'Sugars_g'.
# 'na.rm = TRUE' handles any missing sugar values during the sum.
# This inherently includes all patient-days from the start.
sugar_summary <- dtb |>
  group_by(pid, fdrt) |>
  summarize(daily_sugar = sum(Sugars_g, na.rm = TRUE)) |>
  ungroup()

plot_data_2 <- scaffold |>
  left_join(sugar_summary, by = c("pid", "fdrt")) |>
  mutate(daily_sugar = replace_na(daily_sugar, 0))

# Build the plot for sugar
p2 <- plot_data_2 |>
  ggplot(aes(x = fdrt, y = daily_sugar, color = intensity)) +
   geom_point(alpha = 0.2) +
    
    # Add the LOESS smoothing line.
    # 'method = "loess"' specifies the type of smoother.
    # 'se = FALSE' removes the confidence interval band around the line.
    # 'color = "blue"' sets the line color to be distinct (you can change this).
    geom_smooth(method = "loess", se = FALSE,  aes(color = intensity), size = 1.2) +
    
    # Apply a minimal, clean theme to the plot.
    theme_classic(base_size = 11) +
    scale_y_sqrt() +
  labs(
    title = "Daily Sugar Intake vs. Day Relative to Transplant",
    x = "Day Relative to Transplant",
    y = "Daily Sugar (g)",
    color = "Conditioning intensity"
  ) + theme(aspect.ratio = 1, legend.position = 'right')

# Save the second plot
final_plot <- plot_grid(p1, p2, nrow = 2)
ggsave("../data/R36_sugar__and_sweets_intake_scatter_R.pdf", plot = final_plot, width = 4, height = 7, dpi = 300)
```

