---
title: "Stratification by patient status"
output: html_document
date: "2025-08-04"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(broom.mixed)
library(brms)   
library(ggpubr)
library(patchwork)
library(tidybayes)
library(cowplot)
library(ggridges)
library(brmstools)
library(bayesplot)
library(gt)
options(mc.cores = parallel::detectCores())
rstan::rstan_options(auto_write = TRUE)
theme_set(theme_tidybayes() + panel_border())
ncores <- parallel::detectCores()
```
- Why Not to Split the Data     
  
- Loss of Power

- Wasted Information: The model learns about the general effects of diet and antibiotics from the entire cohort. By splitting the data, you prevent the model from "borrowing strength" across the groups, making your estimates less precise.

- No Direct Comparison: Running three separate models doesn't actually give you a statistical test to say whether the effect of sweets * abx is significantly different between the ablative and non-ablative groups.

# run three way interaction model

I am testing if the effect of sweets * abx depends on the intensity level. In statistical terms, you are testing for an interaction between (sweets * abx) and intensity.

```{r}
meta <- read_csv('../data/153_combined_META.csv') %>% 
  mutate(pid = factor(pid)) %>%
    # This divides all the new intake columns by 100.
  mutate(across(starts_with("fg_"), ~ .x / 100))      
```

```{r}
# Combine the main food groups and the current sweet variable
other_food_terms <- meta %>% select(starts_with('fg')) %>% select(-fg_sweets) %>% colnames()

other_food_terms_ <- paste(other_food_terms, collapse = ' + ')

sweet_interaction_term <- 'fg_sweets * empirical * intensity'

all_terms <- paste(other_food_terms_, sweet_interaction_term, sep =  ' + ')

# Build the full formula string dynamically
formula_string <- paste(
  "log(simpson_reciprocal) ~ 0   + TPN + EN +",
  all_terms,
  "+ (1 | pid) + (1 | timebin)"
)

# Convert the string to a formula object
formula <- brms::bf(as.formula(formula_string))

# Build the priors by adding them together.
# This single prior() call applies to all coefficients listed in `all_food_coefs`.
priors <-
  prior(normal(0, 1), class = 'b') + # General prior for all food effects
  # Specific priors that override the general one for non-food covariates
  prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE") +
  prior(normal(0, 0.1), class = 'b', coef = "ENTRUE") +
  prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE") 

# Fit the model (using fewer iterations for this example to run quickly)
model_fit <- brm(
  formula = formula,
  data = meta,
  prior = priors,
  warmup = 1000, iter = 3000,
  chains = 2, cores = 10, # Adjust cores as needed
  seed = 123,
  silent = 2
)

# Tidy the output and return only the interaction term for the sweet subcategory
model_results <- tidy(model_fit, conf.int = TRUE)  # it is the 95% CI by default
```
```{r}
# ---  Calculate Conditional Effects Correctly Using Posterior Draws ---
# This is the statistically sound way to calculate the effect for each group.
# It uses the full posterior distribution to correctly propagate uncertainty.

# First, extract the posterior draws for the relevant coefficients.
# The 'as_draws_df' function converts the model's posterior samples into a tidy data frame.
posterior_draws <- as_draws_df(model_fit)

# Now, calculate the conditional effect for each draw.
conditional_effects_draws <- posterior_draws %>%
  transmute(
    # The effect for the Ablative group is just its own coefficient.
    `Ablative` = `b_fg_sweets:empiricalTRUE`,
    
    # The effect for the Reduced group is the baseline effect + its interaction term.
    `Reduced Intensity` = `b_fg_sweets:empiricalTRUE` + `b_fg_sweets:empiricalTRUE:intensityreduced`,
    
    # The effect for the Non-Ablative group is the baseline effect + its interaction term.
    `Non-Ablative` = `b_fg_sweets:empiricalTRUE` + `b_fg_sweets:empiricalTRUE:intensitynonablative`
  )

# ---  Summarize the Posterior to Get Point Estimates and Intervals ---
# Now we summarize the thousands of draws for each conditional effect into a
# point estimate (the mean of the draws) and a credible interval (the quantiles).

plot_data <- conditional_effects_draws %>%
  # Convert the data to a long format for easy summarization and plotting
  pivot_longer(
    cols = everything(),
    names_to = "term_label",
    values_to = "estimate"
  ) %>%
  # Group by each term to summarize
  group_by(term_label) %>%
  # Use mean_qi to get the mean (point estimate) and the 95% credible interval
  mean_qi(estimate) %>%
  # Rename columns to match the plotting code below
  rename(conf.low = .lower, conf.high = .upper) %>%
  # Make the labels a factor to control their order on the plot
  mutate(term_label = fct_relevel(term_label, "Non-Ablative", "Reduced Intensity", "Ablative")) %>% 
  mutate(is_significant = (conf.low * conf.high) > 0)


# --- 4. Create the More Intuitive Coefficient Plot ---
results <- ggplot(plot_data, aes(x = estimate, y = term_label)) +
  # Add a vertical line at zero. If a credible interval crosses this line,
  # the effect is not statistically significant.
  geom_vline(xintercept = 0, linetype = "dashed", color = "grey70") +
  
  # Add the error bars (the "whiskers") representing the 95% credible interval
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high,  color = is_significant), height = 0.2, linewidth = 0.8) +
  
  # Add the points representing the model's posterior mean for each term
  geom_point(size = 4, aes(  color = is_significant)) +
  scale_color_manual(values = c("TRUE" = "red", "FALSE" = "gray50"), guide = "none") +
  
  # Add labels and a title
  labs(
    title = "\nEffect of Sweets + Antibiotics on Microbiome Diversity",
    subtitle = "for each conditioning intensity group",
    x = "Estimated Change in log(Diversity)",
    y = "" # No y-axis label needed
  ) +
  
  # Use a clean theme
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major.y = element_blank(), # Remove horizontal grid lines
    plot.title.position = "plot"
  )

results
```

# include the tally of the patients and samples in the three intensity again

```{r}
# --- Generate the summary table ---
sample_data <- meta
# Calculate total number of unique patients and samples for percentage calculations
total_patients <- n_distinct(sample_data$pid)
total_samples <- nrow(sample_data)

summary_table <- sample_data %>%
  # Group data by the conditioning intensity
  group_by(intensity) %>%
  # Calculate counts for patients (distinct) and samples (all rows)
  summarise(
    patient_n = n_distinct(pid),
    sample_n = n(),
    .groups = 'drop' # Drop grouping for the next steps
  ) %>%
  # Calculate the percentage relative to the total
  mutate(
    patient_pct = patient_n / total_patients,
    sample_pct = sample_n / total_samples,
    # Reformat intensity names 
    intensity = case_when(
      intensity == "ablative" ~ "Ablative",
      intensity == "reduced" ~ "Reduced Intensity",
      intensity == "nonablative" ~ "Non-Ablative"
    )
  ) %>% 
  arrange(factor(intensity, levels = c("Ablative", "Reduced Intensity", "Non-Ablative"))) 

# --- Format the table with the 'gt' package ---
summary_table %>%
  gt() %>%
  # Re-label the columns for clarity
  cols_label(
    intensity = "Conditioning Intensity",
    patient_n = "Patients (n)",
    patient_pct = "Patients (%)",
    sample_n = "Samples (n)",
    sample_pct = "Samples (%)"
  ) %>%
  # Format the percentage columns
  fmt_percent(
    columns = c(patient_pct, sample_pct),
    decimals = 1
  ) %>%
  # Add a source note
  tab_source_note(
    source_note = md(paste0("Based on a total of **", total_samples, "** samples from **", total_patients, "** patients."))
  ) %>%
  # Add a spanning header to group related columns
  tab_spanner(
    label = md("**Patient Counts**"),
    columns = c(patient_n, patient_pct)
  ) %>%
  tab_spanner(
    label = md("**Sample Counts**"),
    columns = c(sample_n, sample_pct)
  )%>%
  # Add some final styling options for a polished look.
  opt_table_font(font = "sans-serif") %>%
  gt::gtsave(filename = "../data/R36_number_tally_intensity.png") 
```

# assemble 

```{r}
table_tally_intensity <- ggdraw() + draw_image("../data/R36_number_tally_intensity.png", scale = 1)


final_plot <- plot_grid( table_tally_intensity ,  results , 
                nrow  =2,
                 rel_heights = c(.9,1.5),
                labels = 'auto',
                align = 'h', axis = 'lrtb')


title <- ggdraw() + 
  draw_label("Rebuttal Fig X",fontface = 'bold', x = 0,hjust = 0) +
  theme(plot.margin = margin(0, 0, 0, 0))

combined <- plot_grid(
  title, final_plot,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
) +theme(plot.margin = unit(c(1,3,1,1), "cm"))

ggsave('../data/R36_threeway_intensity.pdf',
      width = 8.5, height = 11, units = "in", device = 'pdf', 
      dpi = 300)     
```

