---
title: "Enterococcus asv in human"
output: html_document
date: "2025-07-09"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(brms)   
library(broom.mixed)
library(tidybayes)
library(janitor)
library(patchwork)
library(cowplot)
library(brmstools)
library(ggtext)
library(tidytext)
library(vdbR)
connect_database()
```

```{r}
library(compositions)
meta <- read_csv('../data/153_combined_META.csv')
e_asv <- read_csv('../data/R25_all_enterococcus_asv_in_sample.csv') %>% inner_join(meta %>% select(pid, sampleid))
# asv_1 is feacium
```

```{r}
asv_summary <- e_asv %>%
  # First, filter for only the Enterococcus ASVs if your table contains others
  filter(genus == "Enterococcus") %>%
  
  # Group the data by the unique ASV key
  group_by(asv_key) %>%
  
  # Summarise to calculate the two counts for each group
  summarise(
    # Count the number of samples where the relative abundance is greater than 0
    # The sum(condition) trick works because TRUE evaluates to 1 and FALSE to 0
    present_in_samples = sum(count_relative > 0, na.rm = TRUE),
    
    # Count the number of samples where the relative abundance is greater than 0.3 (30%)
    dominant_in_samples_0.3 = sum(count_relative > 0.3, na.rm = TRUE)
  ) %>%
  
  # Arrange the final table to show the most prevalent ASVs at the top
  arrange(desc(present_in_samples))

# Print the resulting summary table
print(asv_summary)
```

```{r}
# clr transform the asv counts of asv_1
cts_all <- e_asv %>% 
  select(asv_key,sampleid, count ) %>% 
  right_join(meta %>% distinct(sampleid) ) %>% 
  spread('sampleid', 'count', fill = 0) %>% 
  filter(!is.na(asv_key)) %>% 
  column_to_rownames('asv_key')

clr_res <- clr(cts_all + 0.5) %>% 
  t() %>% 
  as.data.frame()  %>% 
  rownames_to_column('sampleid')
```

```{r}
# also try the log10 transformation
cts_log <- e_asv %>% 
  filter(asv_key %in% c('asv_1','asv_33')) %>% 
  mutate(log_relab = log10(count_relative + 1.230103e-05/2)) %>% 
  select(asv_key, sampleid, log_relab ) %>% 
  spread('asv_key', 'log_relab', fill = log10(0 + 1.230103e-05/2)) %>% 
  right_join(meta %>% distinct(sampleid) ) %>% 
  mutate(asv_1 = if_else(is.na(asv_1), log10(0 + 1.230103e-05/2), asv_1),
         asv_33 = if_else(is.na(asv_33), log10(0 + 1.230103e-05/2), asv_33)) %>% 
  rename(asv1_log = asv_1)

cts_log
```


```{r}
meta_entero <- meta %>% 
  inner_join( clr_res %>% select(sampleid, asv_1, asv_33)) %>% 
  inner_join(cts_log %>% select(sampleid, asv1_log))

all_food_vars <- meta_entero %>% select(starts_with('fg')) %>% colnames()
```

# the model with enterococcus outcome

## asv_1

```{r}
data <- meta_entero
# Create the interaction terms for all food variables in this iteration
interaction_terms <- paste(all_food_vars, "empirical", sep = ":")

# Build the full formula string dynamically
formula_string <- paste(
  "asv_1 ~ 0 + intensity + empirical + TPN + EN +",
  paste(interaction_terms, collapse = " + "),
  "+ (1 | pid) + (1 | timebin)"
)

# Convert the string to a formula object
formula <- brms::bf(as.formula(formula_string))

# Build the priors by adding them together.
# This single prior() call applies to all coefficients listed in `all_food_coefs`.
priors <-
  prior(normal(0, 1), class = 'b') + # General prior for all food effects
  # Specific priors that override the general one for non-food covariates
  prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE") +
  prior(normal(0, 0.1), class = 'b', coef = "ENTRUE") +
  prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE")

# Fit the model (using fewer iterations for this example to run quickly)
model_fit <- brm(
  formula = formula,
  data = data,
  prior = priors,
  warmup = 1000, iter = 3000,
  chains = 2, cores = 10, # Adjust cores as needed
  seed = 123,
  silent = 2
)

results_df <- tidy(model_fit, conf.int = TRUE)
```
```{r}
interaction_df <- results_df %>%
    # Keep only the fixed effects
    filter(effect == "fixed") %>%
    # Create a new column to distinguish main effects from interactions
    mutate(
      effect_type = if_else(str_detect(term, ":"), "Interaction", "Main Effect"),
      # Create clean labels for plotting
      clean_term = term %>%
        str_remove_all("empiricalFALSE:|avg_intake_|TRUE$") %>%
        str_replace("empiricalTRUE:", "abx * ") %>%
        str_replace_all("_", " ")
    ) %>% 
  filter(effect_type == "Interaction") %>%
    # Create a new column to identify significant results
    # The condition is TRUE if conf.low and conf.high have the same sign (i.e., don't cross zero)
    mutate(is_significant = (conf.low * conf.high) > 0)

plot_interactions <- ggplot(interaction_df, aes(x = estimate, y = fct_reorder(clean_term, estimate))) +
    geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
    geom_pointrange(aes(xmin = conf.low, xmax = conf.high, color = is_significant), linewidth = 1, size = 0.7) +
    scale_color_manual(values = c("TRUE" = "red", "FALSE" = "gray50"), guide = "none") +
    labs(
      title = "Food Group Interaction Effects to ASV_1 (CLR)",
      x = "Coefficient Estimate",
      y = "Food Group x Antibiotic Exposure"
    ) +
    theme_bw(base_size = 12) +
    theme(legend.position = "none")
plot_interactions
```

## asv_33

```{r}
model_fit_asv_33 <- brm(
  formula = brms::bf(as.formula(paste(
  "asv_33 ~ 0 + intensity + empirical + TPN + EN +",
  paste(interaction_terms, collapse = " + "),
  "+ (1 | pid) + (1 | timebin)"
))),
  data = data,
  prior = priors,
  warmup = 1000, iter = 3000,
  chains = 2, cores = 10, # Adjust cores as needed
  seed = 123,
  silent = 2
)

results_df_33 <- tidy(model_fit_asv_33, conf.int = TRUE)
```

```{r}
interaction_df <- results_df_33 %>%
    # Keep only the fixed effects
    filter(effect == "fixed") %>%
    # Create a new column to distinguish main effects from interactions
    mutate(
      effect_type = if_else(str_detect(term, ":"), "Interaction", "Main Effect"),
      # Create clean labels for plotting
      clean_term = term %>%
        str_remove_all("empiricalFALSE:|avg_intake_|TRUE$") %>%
        str_replace("empiricalTRUE:", "abx * ") %>%
        str_replace_all("_", " ")
    ) %>% 
  filter(effect_type == "Interaction") %>%
    # Create a new column to identify significant results
    # The condition is TRUE if conf.low and conf.high have the same sign (i.e., don't cross zero)
    mutate(is_significant = (conf.low * conf.high) > 0)

plot_interactions_33 <- ggplot(interaction_df, aes(x = estimate, y = fct_reorder(clean_term, estimate))) +
    geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
    geom_pointrange(aes(xmin = conf.low, xmax = conf.high, color = is_significant), linewidth = 1, size = 0.7) +
    scale_color_manual(values = c("TRUE" = "red", "FALSE" = "gray50"), guide = "none") +
    labs(
      title = "Food Group Interaction Effects to ASV_33 (CLR)",
      x = "Coefficient Estimate",
      y = "Food Group x Antibiotic Exposure"
    ) +
    theme_bw(base_size = 12) +
    theme(legend.position = "none")
plot_interactions_33
```
```{r}
# asv-1 log10 transformed

data <- meta_entero
# Create the interaction terms for all food variables in this iteration
interaction_terms <- paste(all_food_vars, "empirical", sep = ":")

# Build the full formula string dynamically
formula_string <- paste(
  "asv1_log ~ 0 + intensity + empirical + TPN + EN +",
  paste(interaction_terms, collapse = " + "),
  "+ (1 | pid) + (1 | timebin)"
)

# Convert the string to a formula object
formula <- brms::bf(as.formula(formula_string))

# Build the priors by adding them together.
# This single prior() call applies to all coefficients listed in `all_food_coefs`.
priors <-
  prior(normal(0, 1), class = 'b') + # General prior for all food effects
  # Specific priors that override the general one for non-food covariates
  prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE") +
  prior(normal(0, 0.1), class = 'b', coef = "ENTRUE") +
  prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE")

# Fit the model (using fewer iterations for this example to run quickly)
model_fit <- brm(
  formula = formula,
  data = data,
  prior = priors,
  warmup = 1000, iter = 3000,
  chains = 2, cores = 10, # Adjust cores as needed
  seed = 123,
  silent = 2
)

results_df <- tidy(model_fit, conf.int = TRUE)


```
```{r}
interaction_df <- results_df %>%
    # Keep only the fixed effects
    filter(effect == "fixed") %>%
    # Create a new column to distinguish main effects from interactions
    mutate(
      effect_type = if_else(str_detect(term, ":"), "Interaction", "Main Effect"),
      # Create clean labels for plotting
      clean_term = term %>%
        str_remove_all("empiricalFALSE:|avg_intake_|TRUE$") %>%
        str_replace("empiricalTRUE:", "abx * ") %>%
        str_replace_all("_", " ")
    ) %>% 
  filter(effect_type == "Interaction") %>%
    # Create a new column to identify significant results
    # The condition is TRUE if conf.low and conf.high have the same sign (i.e., don't cross zero)
    mutate(is_significant = (conf.low * conf.high) > 0)

plot_interactions <- ggplot(interaction_df, aes(x = estimate, y = fct_reorder(clean_term, estimate))) +
    geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
    geom_pointrange(aes(xmin = conf.low, xmax = conf.high, color = is_significant), linewidth = 1, size = 0.7) +
    scale_color_manual(values = c("TRUE" = "red", "FALSE" = "gray50"), guide = "none") +
    labs(
      title = "Food Group Interaction Effects to ASV_1 (log10)",
      x = "Coefficient Estimate",
      y = "Food Group x Antibiotic Exposure"
    ) +
    theme_bw(base_size = 12) +
    theme(legend.position = "none")
plot_interactions
```

# table for the spp

```{r}
# let's say we only focus on the asv that has been detected in at least 10% of the samples
focus <- asv_summary %>% 
  filter(present_in_samples > ceiling(nrow(meta) * 0.1)) %>% 
  pull(asv_key)

full <- read_csv('../data/R25_Enterococcus_asv_blast_res_full_sorted.csv') %>% 
  distinct(asv_key, pident, evalue, bitscore, taxa_desc) %>% 
  filter(asv_key %in% focus) %>% 
  mutate(
    # The word() function from stringr is perfect for this.
    # It extracts words from a string based on their position.
    # We are asking for words from position 1 to 2, separated by a space.
    taxa_desc = word(taxa_desc, 1, 2, sep = " ")
  )

plot_data <- full %>%
  # Abbreviate "Enterococcus" to "E." for cleaner labels
  mutate(
    short_taxa = str_replace(taxa_desc, "Enterococcus", "E.")
  )

# --- Create the Visualization ---
ggplot(plot_data, aes(x = fct_reorder(short_taxa, pident), y = pident)) +
  # geom_col() creates the bars. We'll color them by ASV key for clarity.
  geom_col(aes(fill = asv_key), show.legend = FALSE) +
  
  # Add the horizontal threshold line at 97% identity
  geom_hline(yintercept = 97, linetype = "dashed", color = "red", linewidth = 1) +
  
  # Add text on top of the threshold line to label it
  annotate("text", x = 0.5, y = 97.2, label = "97% Species Threshold", color = "red", hjust = 0, size = 3) +
  
  # Facet the plot by asv_key to create a separate panel for each ASV
  facet_wrap(~ asv_key, scales = "free_x") +
  
  # Set the y-axis limits to focus on the high-identity region
  coord_cartesian(ylim = c(92, 100)) +
  
  # Add informative labels
  labs(
    title = "BLAST Hit Identity for Each ASV",
    subtitle = "Each panel shows the top hits for a single Amplicon Sequence Variant (ASV)",
    x = "Matching Taxa from blast",
    y = "Percent Identity (%)"
  ) +
  
  # Use a clean theme and rotate x-axis labels for readability
  theme_bw() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    strip.text = element_text(face = "bold")
  )

```

# summary of the asv 

```{r}
# Define the total number of samples in your full dataset
total_samples <- nrow(meta)

# --- Step 2: Calculate the Detailed Summary Statistics ---

# This command calculates all the requested metrics for each ASV.
asv_detailed_summary <- e_asv %>%
  # Filter for only the Enterococcus ASVs if your table contains others
  filter(genus == "Enterococcus") %>%
  
  # Group the data by the unique ASV key
  group_by(asv_key) %>%
  
  # Summarise to calculate all the metrics for each group
  summarise(
    # --- Prevalence Metrics ---
    # Count of samples where the ASV is present
    n_present_samples = n(),
    # Percentage of total samples where the ASV is present
    pct_present_samples = n() / total_samples,
    
    # --- Dominance Metrics (using 0.3 threshold) ---
    # Count of samples where the ASV is dominant
    n_dominant_samples = sum(count_relative > 0.3, na.rm = TRUE),
    # Percentage of total samples where the ASV is dominant
    pct_dominant_samples = n_dominant_samples / total_samples,
    
    # --- Patient-Level Metrics ---
    # Count of unique patients where the ASV is present
    n_present_patients = n_distinct(pid),
    # Count of unique patients where the ASV is dominant
    n_dominant_patients = n_distinct(pid[count_relative > 0.3]),
    
    # --- Abundance Metrics ---
    # Median abundance ONLY in samples where the ASV is present, now as a percentage
    median_abundance_pct_when_present = median(count_relative, na.rm = TRUE) * 100,
    
    # To calculate the median across ALL samples, we need to account for the zeros.
    # We create a vector with the observed abundances and the correct number of zeros.
    median_abundance_pct_all_samples = median(c(count_relative, rep(0, total_samples - n())), na.rm = TRUE) * 100
  )  %>%
  
  # Arrange the final table to show the most prevalent ASVs at the top
  arrange(desc(n_present_samples))

# Print the resulting summary table
print(asv_detailed_summary)

library(gt)
asv_detailed_summary %>%
  gt() %>%
  fmt_percent(columns = starts_with("pct_"), decimals = 1) %>%
  # Use fmt_number for the new percentage columns
  fmt_number(columns = starts_with("median_abundance_pct"), decimals = 2, pattern = "{x}%") %>%
  cols_label(
    asv_key = "ASV Key",
    n_present_samples = "Present (N Samples)",
    pct_present_samples = "Present (%)",
    n_dominant_samples = "Dominant (N Samples)",
    pct_dominant_samples = "Dominant (%)",
    n_present_patients = "N Patients (Present)",
    n_dominant_patients = "N Patients (Dominant)",
    median_abundance_pct_when_present = "Median Abund. % (Present)",
    median_abundance_pct_all_samples = "Median Abund. % (All)"
  )

```

## abun and prevelance of the top Enterococcus ASV

```{r}
# First, we need to find out how many unique samples are in the entire dataset.
# This will be the denominator for our prevalence calculation.
total_samples <- n_distinct(meta$sampleid)

# Next, we calculate the prevalence for each ASV.
# We do this by counting the number of unique samples each ASV appears in,
# and then dividing by the total number of samples.
prevalence_df <- e_asv %>%
  group_by(asv_key) %>%
  summarise(
    n_present = n_distinct(sampleid),
    .groups = 'drop'
  ) %>%
  mutate(prevalence = n_present / total_samples)

# Now, we filter this list to keep only the ASVs that are prevalent
# in at least 10% of all samples. We also sort them from most to least prevalent.
# This sorted list will determine the order of the ASVs on our plot's x-axis.
prevalent_asv_keys <- prevalence_df %>%
  filter(prevalence >= 0.1) %>%
  arrange(prevalence) %>%
  pull(asv_key) # pull() extracts the column as a vector

# We filter the original data to include only these prevalent ASVs.
# We also join the prevalence information, which we'll use to color the boxes.
plot_data <- e_asv %>%
  filter(asv_key %in% prevalent_asv_keys) %>%
  left_join(prevalence_df, by = "asv_key") %>%
  # This is a key step: we turn `asv_key` into a factor and set its levels
  # to the sorted list we created. This ensures the x-axis is correctly ordered.
  mutate(asv_key = factor(asv_key, levels = prevalent_asv_keys))

relab_abun <- ggplot(plot_data, aes(x = asv_key, y = count_relative)) +
 geom_jitter( alpha = 0.3,   
              size = 1.5) +
  # Add the mean value as a diamond
  stat_summary(fun = mean, geom = "point", shape = 23, size = 5, fill = "white", color = "black") +
  
  # General aesthetics for a clean look
  labs(
    #title = "Distribution of Abundance for Present ASVs",
    #subtitle = "Showing samples with relative abundance > 0 and present in at least 10% of the samples",
    x = "ASV",
    y = "Relative Abundance"
  ) +
  theme_minimal() +
  theme(legend.position = 'top') +
  coord_flip() # Flip coordinates to make it horizontal, which is easier to read

relab_abun

```


```{r}
plot_data_bars <-  prevalence_df %>%
  filter(asv_key %in% prevalent_asv_keys) %>%
  # This is a key step: we turn `asv_key` into a factor and set its levels
  # to the sorted list we created. This ensures the x-axis is correctly ordered.
  mutate(asv_key = factor(asv_key, levels = prevalent_asv_keys))

# ---  Panel 2: The Prevalence Bar Plot ---
# Here we create the new horizontal bar plot
p2 <- ggplot(plot_data_bars, aes(x = prevalence, y = asv_key)) +
  geom_col( alpha = 0.8) +
  # Add text labels to the bars for clarity
  geom_text(aes(label = scales::percent(prevalence, accuracy = 0.1)), hjust = -0.2, size = 3) +
  scale_x_continuous(
    labels = scales::percent, 
    limits = c(0, 1) # Ensure axis goes from 0% to 100%
  ) +
  labs(
   # title = "Prevalence",
    #subtitle = "Percentage of samples",
    x = "Prevalence",
    y = "ASV"
  ) +
  theme_minimal() +
   # Define the color scale for the boxplot fill.
  # viridis is a colorblind-friendly and visually appealing palette.
  scale_fill_viridis_c(
    name = "Prevalence",
    # Format the legend labels as percentages.
    labels = scales::percent_format(accuracy = 1)
  ) +
  # This cleans up the y-axis since the labels are already on the first plot
  theme(
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    legend.position = "none"
  )
  

# --- 5. Combine the Plots ---
# plot_grid gives us the alignment control we need
p_asv_level <- plot_grid(relab_abun, p2, 
          align = 'vh', # This is the key: 'v' for vertical alignment
          nrow = 1,      # Arrange in one row
          rel_widths = c(1.2, 1)) # Optional: Give the left plot a bit more width

```


# compare the same sample shotgun and 16s sequenced

```{r}
shotgun <- read_csv('../data/R26_human_shotgun_res.csv') 

# spread the e_asv to wide format
e_asv_wide <- e_asv %>%
  select(asv_key, sampleid, count_relative) %>% 
  spread('asv_key','count_relative', fill = 0)
```


```{r}
library(geepack)
# Load the broom library to tidy model output
library(broom)
# do the correlation between the asv_1 and the e_faecium       
joined <- shotgun %>% 
  select(sampleid = Sample, shotgun_spp = Species, Abundance) %>% 
  filter(shotgun_spp == 'Enterococcus_faecium') %>% 
  left_join(e_asv_wide %>% select(sampleid, asv_1)) %>% 
  rename(shotgun_abundance = Abundance) %>% 
  rename(asv1_abundance = asv_1) %>% 
  inner_join(meta %>% select(sampleid, pid, sdrt)) %>% 
  mutate(pid = factor(pid)) %>% 
  mutate(asv1_abundance = if_else(is.na(asv1_abundance), 0, asv1_abundance))


# Fit the GEE model.
# The 'id = pid' argument tells the model that samples are clustered within each patient.
# 'corstr = "exchangeable"' is a robust choice for the correlation structure.
gee_model <- geeglm(
  shotgun_abundance ~ asv1_abundance,
  id = pid,
  data = joined,
  family = gaussian,
  corstr = "exchangeable"
)

# Use broom::tidy() to get a clean summary of the model results
gee_results <- tidy(gee_model)

# Extract the GEE coefficient and p-value for the plot title
# We are interested in the term for our predictor, 'asv1_abundance'
gee_term <- gee_results %>% filter(term == "asv1_abundance")
gee_coeff <- round(gee_term$estimate, 3)
gee_p_value <- format(gee_term$p.value, digits = 2, scientific = TRUE)

# ggplot(joined, aes(x = asv1_abundance, y = shotgun_abundance)) +
#   # Add the points for each sample, colored by patient ID
#   geom_point(aes(color = pid), alpha = 0.7, size = 3) +
#   # Add a single regression line to show the overall trend from the GEE model
#   geom_smooth(method = "lm", se = TRUE, color = "#073B4C") +
#   
#   # Add informative labels and a title that includes the GEE correlation results
#   labs(
#     title = "Correlation between ASV_1 and E. faecium Abundance",
#     subtitle = paste0("GEE Coefficient = ", gee_coeff, " (p = ", gee_p_value, ")"),
#     x = "ASV_1 Relative Abundance (16S)",
#     y = "E. faecium Relative Abundance (Shotgun)"
#   ) +
#   # Use a clean theme
#   theme_bw(base_size = 14) +
#   theme(legend.position = 'none')
```

```{r}
# # are there other asv that is also faecium
# get_table_from_database('asv_annotation_blast_ag')
# 
# 
# # do the correlation using all asv that are faecium and see if the correlation is better
# amplicon_faecium <- e_asv %>% 
#   left_join(asv_annotation_blast_ag %>% select(asv_key, species)) %>% 
#   filter(species == 'Enterococcus_faecium') %>% 
#   group_by(sampleid) %>% 
#   summarise(total_faecium = sum(count_relative))
#   
# 
# correlation_df <- shotgun %>% 
#   select(sampleid = Sample, shotgun_spp = Species, Abundance) %>% 
#   filter(shotgun_spp == 'Enterococcus_faecium') %>% 
#   left_join(amplicon_faecium) %>% 
#   rename(shotgun_abundance = Abundance) %>% 
#   rename(a16s_abundance = total_faecium) %>% 
#   inner_join(meta %>% select(sampleid, pid, sdrt)) %>% 
#   mutate(pid = factor(pid)) %>% 
#   mutate(a16s_abundance = if_else(is.na(a16s_abundance), 0, a16s_abundance))
```

```{r}
# gee_model <- geeglm(
#   shotgun_abundance ~ a16s_abundance,
#   id = pid,
#   data = correlation_df,
#   family = gaussian,
#   corstr = "exchangeable"
# )
# 
# # Use broom::tidy() to get a clean summary of the model results
# gee_results <- tidy(gee_model)
# 
# # Extract the GEE coefficient and p-value for the plot title
# # We are interested in the term for our predictor, 'asv1_abundance'
# gee_term <- gee_results %>% filter(term == "a16s_abundance")
# gee_coeff <- round(gee_term$estimate, 3)
# gee_p_value <- format(gee_term$p.value, digits = 2, scientific = TRUE)
# 
# ggplot(correlation_df, aes(x = a16s_abundance, y = shotgun_abundance)) +
#   # Add the points for each sample, colored by patient ID
#   geom_point(aes(color = pid), alpha = 0.7, size = 3) +
#   # Add a single regression line to show the overall trend from the GEE model
#   geom_smooth(method = "lm", se = TRUE, color = "#073B4C") +
#   
#   # Add informative labels and a title that includes the GEE correlation results
#   labs(
#     title = "Correlation between a16s_abundance and E. faecium Abundance",
#     subtitle = paste0("GEE Coefficient = ", gee_coeff, " (p = ", gee_p_value, ")"),
#     x = "faecium Relative Abundance (16S)",
#     y = "E. faecium Relative Abundance (Shotgun)"
#   ) +
#   # Use a clean theme
#   theme_bw(base_size = 14) +
#   theme(legend.position = 'none')

# not much change and the cor actually gets worse    
```

## ASV1 & shotgun spp corresponding to that 

```{r}
#what if I just correlating the shotgun abundance of those other possible species with asv_1
all_1 <- shotgun %>%
  select(Sample, Species, Abundance) %>%
  # these 4 are the ones that have 100% percent identity with asv_1 and exist in the shotgun data
  filter(Species %in% c('Enterococcus_durans','Enterococcus_hirae','Enterococcus_faecium','Enterococcus_mundtii')) %>%
  rename(sampleid = Sample, shotgun_spp = Species, shotgun_relab = Abundance) %>%
  mutate(shotgun_spp = str_replace(shotgun_spp, 'Enterococcus','E')) %>% 
  full_join(e_asv_wide %>% select(sampleid, asv_1)) %>%
  rename(asv1_abundance = asv_1) %>%
  inner_join(meta %>% select(sampleid, pid, sdrt)) %>%
  mutate(pid = factor(pid)) %>%
  split(.$shotgun_spp)

# Assuming 'all_1' is your list of dataframes
list_names <- names(all_1)

gee_cor <- all_1 %>%
  imap(function(df_, name_){
    joined = df_ %>%
      mutate(asv1_abundance = if_else(is.na(asv1_abundance), 0, asv1_abundance),
            shotgun_relab = if_else(is.na(shotgun_relab), 0, shotgun_relab) )

    gee_model = geeglm(
      shotgun_relab ~ asv1_abundance,
      id = pid,
      data = joined,
      family = gaussian,
      corstr = "exchangeable"
    )

    # Use broom::tidy() to get a clean summary of the model results
    gee_results <- tidy(gee_model)

    # Extract the GEE coefficient and p-value for the plot title
    # We are interested in the term for our predictor, 'asv1_abundance'
    gee_term <- gee_results %>% filter(term == "asv1_abundance")
    gee_coeff <- round(gee_term$estimate, 3)
    gee_p_value <- format(gee_term$p.value, digits = 2, scientific = F)

    p <- ggplot(joined, aes(x = asv1_abundance, y = shotgun_relab)) +
      # Add the points for each sample, colored by patient ID
      geom_point( alpha = 0.5, size = 2) +
      geom_abline(intercept = 0, slope = 1, color = "blue", linetype = "dashed", size = 1.2) +
      # Use annotate() to place text directly on the plot
      annotate(
        "text",
        x = Inf, y = Inf, # Position at the top-right corner
        hjust = 1.2, vjust = 1.5, # Adjust to bring it in from the edge
        color = "red",
        size = 3,
        # Use str_glue with a newline character (\n) for two lines
        label = str_glue("Coeff = {gee_coeff} p = {gee_p_value}")
      ) +

      # Add informative labels and a title that includes the GEE correlation results
      labs(
       # title = str_glue("Correlation between ASV_1 and\n{name_}"),
        x = "ASV_1 Relative Abundance (16S)",
        y = str_glue("{name_}\n(Shotgun Relab)")
      ) +
      # Use a clean theme
      theme_bw(base_size = 10) +
      theme(legend.position = 'none', aspect.ratio = 1/2) 
    
    # --- Conditionally remove the x-axis title ---
    # Check if the current plot is the last one in the list
    is_last_plot <- name_ == list_names[length(list_names)]
    
    # If it's NOT the last plot, remove the x-axis title
    if (!is_last_plot) {
      p <- p + theme(axis.title.x = element_blank())
    }
    return(p)
    
  })

res_1 <- plot_grid(plotlist = gee_cor, nrow = 4, align = 'v' )
ggsave('../data/R29_cor_asv_1.jpg', height = 10)
```

## ASV33 & shotgun spp corresponding to that 

```{r}
all_33 <- shotgun %>%
  select(Sample, Species, Abundance) %>%
  # these 4 are the ones that have 100% percent identity with asv_1 and exist in the shotgun data
  filter(Species %in% c('Enterococcus_faecalis','Enterococcus_dispar')) %>%
  rename(sampleid = Sample, shotgun_spp = Species, shotgun_relab = Abundance) %>%
  mutate(shotgun_spp = str_replace(shotgun_spp, 'Enterococcus','E')) %>% 
  full_join(e_asv_wide %>% select(sampleid, asv_33)) %>%
  rename(asv33_abundance = asv_33) %>%
  inner_join(meta %>% select(sampleid, pid, sdrt)) %>%
  mutate(pid = factor(pid)) %>%
  split(.$shotgun_spp)

# Assuming 'all_33' is your list of dataframes
list_names_33 <- names(all_33)

gee_cor_33 <- all_33 %>%
  imap(function(df_, name_){
    joined = df_ %>%
      mutate(asv33_abundance = if_else(is.na(asv33_abundance), 0, asv33_abundance),
            shotgun_relab = if_else(is.na(shotgun_relab), 0, shotgun_relab) )
      

    gee_model = geeglm(
      shotgun_relab ~ asv33_abundance,
      id = pid,
      data = joined,
      family = gaussian,
      corstr = "exchangeable"
    ) 

    # Use broom::tidy() to get a clean summary of the model results
    gee_results <- tidy(gee_model)

    # Extract the GEE coefficient and p-value for the plot title
    # We are interested in the term for our predictor, 'asv33_abundance'
    gee_term <- gee_results %>% filter(term == "asv33_abundance")
    gee_coeff <- round(gee_term$estimate, 3)
    gee_p_value <- format(gee_term$p.value, digits = 2, scientific = F)

    p <- ggplot(joined, aes(x = asv33_abundance, y = shotgun_relab)) +
      # Add the points for each sample, colored by patient ID
      geom_point( alpha = 0.5, size = 2) +
      geom_abline(intercept = 0, slope = 1, color = "blue", linetype = "dashed", size = 1.2) +
      # Use annotate() to place text directly on the plot
      annotate(
        "text",
        x = Inf, y = Inf, # Position at the top-right corner
        hjust = 1.2, vjust = 1.5, # Adjust to bring it in from the edge
        color = "red",
        size = 3,
        # Use str_glue with a newline character (\n) for two lines
        label = str_glue("Coeff = {gee_coeff} p = {gee_p_value}")
      ) +

      # Add informative labels and a title that includes the GEE correlation results
      labs(
       # title = str_glue("Correlation between ASV_1 and\n{name_}"),
        x = "ASV_33 Relative Abundance (16S)",
        y = str_glue("{name_}\n(Shotgun Relab)")
      ) +
      # Use a clean theme
      theme_bw(base_size = 10) +
      theme(legend.position = 'none', aspect.ratio = 1/2) 
    
    # --- Conditionally remove the x-axis title ---
    # Check if the current plot is the last one in the list
    is_last_plot <- name_ == list_names_33[length(list_names_33)]
    
    # If it's NOT the last plot, remove the x-axis title
    if (!is_last_plot) {
      p <- p + theme(axis.title.x = element_blank())
    }
    return(p)
    
  })

res_33 <- plot_grid(plotlist = gee_cor_33, nrow = 2, align = 'v' )
ggsave('../data/R29_cor_asv_33.jpg', height = 6)
```

# shotgun samples with any Enterococcus

```{r}
# shot_enter <- shotgun %>% 
#   filter(str_detect(Species, 'Enterococcus')) %>% 
#   clean_names() %>% 
#   select(sample, species, abundance, pid) %>% 
#   mutate(
#     asv = case_when(
#     species %in% c("Enterococcus_faecium" , 'Enterococcus_hirae', 'Enterococcus_mundtii', 'Enterococcus_durans') ~ "asv_1",
#     species %in% c("Enterococcus_faecalis", 'Enterococcus_dispar')~ "asv_33",
#     TRUE                              ~ NA_character_ # Handle ties or other cases
#    )
#   ) %>% 
#   filter(abundance > 0)
# 
# total_shotgun_samples <- shotgun %>% distinct(Sample) %>% nrow
# 
# # Create prevalence data
# prevalence_df <- shot_enter %>%
#   mutate(species_label = str_replace(species, "Enterococcus_", "E. ")) %>% 
#   group_by(asv, species_label) %>%
#   summarise(n_samples = n_distinct(sample)) %>% # Assuming you have a patient ID 'pid'
#   mutate(prevalence = n_samples /total_shotgun_samples) %>%
#   ungroup() %>% 
#    filter(!is.na(asv))
# 
# # This step calculates all the summary stats we need for all plots.
# summary_data <- shot_enter %>%
#   mutate(species_label = str_replace(species, "Enterococcus_", "E. ")) %>%
#   group_by(asv, species_label) %>%
#   # Calculate mean abundance and prevalence for sizing and sorting
#   summarise(
#     mean_abundance = mean(abundance),
#     median_abundance = median(abundance),
#     n_samples = n_distinct(sample)
#   ) %>%
#    mutate(prevalence = n_samples /total_shotgun_samples) %>%
#   ungroup() %>% filter(!is.na(asv)) %>% 
#   # Use reorder_within to create the sortable factor
#   mutate(species_ordered = reorder_within(species_label, median_abundance, asv))
# 
# plot_data <- shot_enter %>%
#   mutate(species_label = str_replace(species, "Enterococcus_", "E. ")) %>% 
#   filter(!is.na(asv))%>%
#   # This is the key step for sorting within each facet
#   # We calculate the median abundance for each species WITHIN each 'asv' group
#   group_by(asv, species_label) %>%
#   mutate(median_abundance = median(abundance)) %>%
#   ungroup()
# 
# # Now, use reorder_within to create a new factor that ggplot can sort correctly
# plot_data_sorted <- plot_data %>%
#   mutate(species_ordered = reorder_within(species_label, median_abundance, asv))
# 
# 
# 
# p_abundance <- ggplot(plot_data_sorted, aes(x = abundance, y = species_ordered)) +
#   geom_jitter(aes(color = asv), alpha = 0.4, height = 0.2, size = 1.5) +
#   geom_boxplot(width = 0.4, outlier.shape = NA, fill = NA, color = "gray30") +
#   # Add the mean value as a diamond
#   stat_summary(fun = mean, geom = "point", shape = 23, size = 3, fill = "white", color = "black") +
#   # This special scale works with reorder_within to create the correct labels
#   scale_y_reordered() +
#   facet_wrap(~ asv, ncol = 1, scales = "free_y") +
#   labs(
#     #title = "Species Abundance",
#     x = "Relative Abundance",
#     y = "Metagenomic sequencing species"
#   ) +
#   theme_minimal_grid() +
#   theme(
#   legend.position = "none",
#     strip.text = element_text(face = "bold", size = 12),
#     axis.ticks.y = element_blank()
#   )
# 
# # --- 3. Prepare the Prevalence Data ---
# 
# 
# # Apply the same sorting logic to the prevalence data
# prevalence_sorted <- prevalence_df %>%
#   left_join(plot_data_sorted %>% select(species_label, asv, median_abundance) %>% distinct(), 
#             by = c("species_label", "asv")) %>%
#   mutate(species_ordered = reorder_within(species_label, median_abundance, asv))
# 
# 
# # --- 4. Create the Prevalence Bar Plot (Panel 2) ---
# 
# p2 <- ggplot(prevalence_sorted, aes(x = prevalence, y = species_ordered)) +
#   geom_col(aes(fill = asv), alpha = 0.8) +
#   geom_text(aes(label = scales::percent(prevalence, accuracy = 1)), hjust = -0.2, size = 3.5) +
#   scale_x_continuous(labels = scales::percent, limits = c(0, 1)) +
#   # Use the same facet wrap and scale_y_reordered to ensure perfect alignment
#   scale_y_reordered() +
#   facet_wrap(~ asv, ncol = 1, scales = "free_y") +
#   labs(
#     #title = "Prevalence",
#     x = "Prevalence",
#     y = ""
#   ) +
#   theme_minimal_grid() +
#   theme(
#     legend.position = "none",
#     strip.text = element_text(face = "bold", size = 12),
#     axis.text.y = element_blank(), # Hide y-axis text as it's redundant
#     axis.ticks.y = element_blank()
#   )
# 
# # --- 5. Combine the Plots ---
# 
# p_species_level <- plot_grid(p_abundance, p2, align = 'h', # Align horizontally
#           axis = "tb",
#           nrow = 1,
#           rel_widths = c(1.2, 1))
```

# two cluster text label  

```{r}
# --- 1. Calculate Summary Data for the Diagram ---
# We need to get the mean abundance for each species within each ASV group
summary_data_cluster <- summary_data %>% 
  # Crucially, sort the species by mean abundance WITHIN each ASV group
  group_by(asv) %>%
  arrange(desc(mean_abundance)) %>%
# Assign horizontal position (1, 2, 3...) for plotting
  mutate(x_pos = row_number()) %>%
  ungroup()


# --- 2. Create the Diagram with ggplot2 ---
annot <- ggplot(summary_data_cluster, aes(x = x_pos, y = asv)) +
  
  # This layer adds the species names.
  # The 'size' is scaled by mean_abundance.
  geom_text(
    aes(label = species_label, size = mean_abundance),
    vjust = 0.5 # This helps vertically center the text in each row
  ) +
  
  # This layer adds the "asv_X -->" labels at the start of each row.
  # We use a subset of the data so the label only appears once per row.
  geom_text(
    data = . %>% distinct(asv), 
    aes(x = 0, label = paste0(asv, "   →")),
    size = 6,
    #fontface = "bold",
    hjust = 1 # Right-aligns the text to the arrow
  ) +
  
  # This controls the range of font sizes for a nice visual effect.
  scale_size_continuous(range = c(4, 11)) +
  
  # This expands the x-axis limits to ensure all text fits.
  xlim(-1, max(summary_data_cluster$x_pos) + 0.5) +
  
  # This removes all plot elements (axes, grid, background) for a clean look.
  theme_void() +
  theme(
    legend.position = "none" # Hides the size legend.
  )
```

# assemble 

## table

```{r}
# the table that has the cluster information from Nick
# --- 1. Read the Table Data from the CSV file ---
# This reads the provided CSV into a dataframe.
# The `read_csv` function is generally robust to different CSV formats.
cluster_table <- read_csv("../data/cluster_table.csv")

# --- 2. Process the Data for Plotting ---
# To create the table, we need to group by 'asv' and collapse all the
# associated species into a single line of text.
table_data <- cluster_table %>%
  # Grouping by 'asv' so we can summarize all species for each one
  group_by(asv) %>%
  # The 'summarise' function creates the list. 'paste' joins the text.
  summarise(
    # We clean up the species names and join them with a comma and space
    possible_species = paste(str_replace(species, "Enterococcus_", "E. "), collapse = ", ")
  ) %>%
  ungroup()


# --- 3. Create the Table Plot (Panel A) ---
# This ggplot object is designed to look like a clean text table.
p_table <- table_data %>%
  # We use Markdown formatting to make the ASV names bold.
  mutate(label = glue::glue("**{asv}**: {possible_species}")) %>%
  ggplot(aes(x = 0, y = fct_rev(asv))) +
  # 'geom_richtext' from the ggtext package renders the Markdown formatting.
  geom_richtext(
    aes(label = label),
    hjust = 0,          # Left-align the text
    label.color = NA,   # This removes the box around the text
    fill = NA
  ) +
  labs(
    title = "ASV to Species Cluster Mapping"
  ) +
  # This makes the x-axis wide enough for the text to fit.
  scale_x_continuous(limits = c(0, 1), expand = c(0, 0)) +
  # 'theme_void' removes all plot decorations (axes, gridlines, background).
  theme_void() +
  theme(
    axis.text.y = element_blank(), # The ASV is in the text, so the axis label is redundant.
    plot.title = element_text(hjust = 0.5, face = "bold", margin = margin(b = 10))
  )
p_table
```

## bottom

```{r}
# the bottom row that has my correlation plot
# decided to arrange the panels manually .....
bottom <- plot_grid(
  gee_cor$E_faecium, gee_cor_33$E_faecalis,
  gee_cor$E_mundtii, gee_cor_33$E_dispar,
  gee_cor$E_hirae, NA,
  gee_cor$E_durans, NA,
  ncol = 2,          # Arrange them in two rows (vertically)
  align = 'hv',       # Align them horizontally
  axis = 'lrtb',
  rel_widths  = c(1, 1) # Give the bottom plot 1.5x the height of the top one
)
bottom

# plot_grid arranges the plots and aligns them
final_plot <- plot_grid(
  p_asv_level, 
  p_table, 
  bottom,
  nrow = 3,          # Arrange them in two rows (vertically)
  align = 'hv',       # Align them horizontally
  rel_heights = c(.7, 0.5, 1.8) # Give the bottom plot 1.5x the height of the top one
)

title <- ggdraw() + 
  draw_label("Supplemental Fig X",fontface = 'bold',x = 0,hjust = 0) +
  theme(plot.margin = margin(0, 0, 0, 0))

combined <- plot_grid(
  title, final_plot,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.01, 1)
) +theme(plot.margin = unit(c(1,1,1,1), "cm"))

ggsave('../data/R29_Enterococcus_spp.pdf',
      width = 8.5, height = 11, units = "in", device = 'pdf', 
      dpi = 300) 
```