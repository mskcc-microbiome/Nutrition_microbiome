---
title: "Transcriptomics"
output: html_document
date: "2025-10-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

some mice are sacrificed at day 1 and some at day 3. normalized TPM is what needs to be used. 

```{r}
library(tidyverse)
# The fs package is great for working with the file system in a way that works
# across different operating systems (Windows, macOS, Linux).
library(fs)
library(janitor)
library(KEGGREST)
library(cowplot)
```


```{r}
data_folder <- "../data/taxo_normalized_rna_kos/"
metadata_file <- "../data/sample_metadata.csv"

# --- Script Logic ---
# Get a list of all files in the specified folder that end with ".tsv".
# dir_ls() from the fs package finds the files, and the glob argument acts as a filter.
file_paths <- dir_ls(data_folder, glob = "*.tsv")

combined_data <- map_dfr(file_paths, read_tsv, .id = "source_file") |>
  # This next step just cleans up the source_file column to only show the filename
  # itself, rather than the full path (e.g., "MR1.tsv" instead of "path/to/your/data_folder/MR1.tsv").
  mutate(source_file = path_file(source_file))|>
  mutate(sample_id = str_remove(source_file, ".tsv"))


# --- Metadata Integration ---
# Read the metadata. Based on your screenshot, it looks like a CSV.
# We'll also select only the first four columns as you requested.
metadata <- read_csv(metadata_file) |>
  clean_names() |>
  select(1:4)

final_data <- left_join(combined_data, metadata, by = "sample_id") |> select(-source_file, -...1) |> rename(relative_abundance = relvative_abundance)
# final_data table doesn't just list which bacteria are present. The columns like RNA_TPM and normalized_TPM measure the expression level of specific genes (gene_fam).

# A high TPM value for a gene involved in metabolizing sucrose in a sample from the "PBS, Sucrose" group means the bacteria are actively eating the sucrose you provided.
# 
# A high TPM value for an antibiotic resistance gene in the "Biapenem" group means the bacteria are actively fighting off the antibiotic to survive.
```

# composition from the shallow shotgun

```{r}
# --- Visualization of Microbial Composition ---

# To make the plot readable, it's often best to visualize only the most abundant taxa.
# Here, we find the top 10 most abundant taxa across the entire dataset.
top_taxa <- final_data |>
  group_by(g_s) |>
  summarise(total_abundance = sum(relative_abundance, na.rm = TRUE)) |>
  slice_max(order_by = total_abundance, n = 10) |>
  pull(g_s)

# Prepare the data for plotting. This involves a few steps:
# 1. Lump less abundant taxa into an "Other" category.
# 2. Convert the 'treatment' column to a factor with a specific order for the plot facets.
# 3. Group by the key variables and sum the abundances, which aggregates the new "Other" category.
plot_data <- final_data |>
  mutate(
    g_s_display = ifelse(g_s %in% top_taxa, as.character(g_s), "Other"),
    treatment = factor(treatment, levels = c("Not Treated", "PBS, Sucrose", "Biapenem, Plain Hydrogel", "Biapenem, Sucrose"))
  ) |>
  group_by(sample_id, timepoint_day, treatment, g_s_display) |>
  summarise(relative_abundance = sum(relative_abundance, na.rm = TRUE), .groups = 'drop')

# --- Custom Color Palette ---
# Define a set of contrasting colors. You can adjust these hex codes.
# This palette excludes "gray" for the main taxa.
contrasting_colors <- c(
  "#E41A1C", "#377EB8", "#FFFF33", "#984EA3", "#FF7F00",
  "#4DAF4A", "#A65628", "#F781BF", "#999999", "blue" # Example, you might need more if > 9 taxa
)

# Determine the number of unique top taxa to assign colors.
num_top_taxa <- length(setdiff(unique(plot_data$g_s_display), "Other"))

# Create the full color mapping, ensuring "Other" is specifically gray.
# We'll use the first `num_top_taxa` colors for the main taxa.
color_map <- c(setNames(contrasting_colors[1:num_top_taxa], sort(setdiff(unique(plot_data$g_s_display), "Other"))),
               "Other" = "gray70") # A light gray for 'Other'

# Create the faceted bar plot.
composition_plot <- ggplot(plot_data, aes(x = sample_id, y = relative_abundance, fill = g_s_display)) +
  # geom_col creates the bars; position="fill" makes each bar a stacked percentage plot (100% height).
  geom_col(position = "fill") +
  # Apply the custom color palette.
  scale_fill_manual(values = color_map) +
  # facet_grid creates the panel of plots. Rows are timepoints, columns are treatments.
  # `scales = "free_x"` and `space = "free_x"` ensure that each panel only shows the relevant samples.
  facet_grid(timepoint_day ~ treatment, scales = "free_x", space = "free_x") +
  # Add labels and a title.
  labs(
    title = "Microbial Composition Across Treatments and Timepoints",
    x = "Sample",
    y = "Relative Abundance",
    fill = "Taxa (Top 10 + Other)"
  ) +
  # Use a clean black and white theme.
  theme_bw() +
  # Customize the theme for better readability.
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    strip.text = element_text(face = "bold"),
    legend.position = "bottom"
  )

# Print the plot to the R viewer.
print(composition_plot)
ggsave('../data/R48_composition_plot.pdf', width = 13, plot = composition_plot, height = 10)

# You can now work with the 'final_data' data frame for your analysis.
# For example, to save it to a new CSV file:
write_csv(final_data, "../data/R48_final_combined_output.csv")
```

# statistical test between "Biapenem, Sucrose", "PBS, Sucrose"

```{r}
# --- Differential Expression Analysis  ---
# Goal: Find genes in Enterococcus that are differentially expressed between
# "Biapenem, Plain Hydrogel" at Day 1 and the "Not Treated" control group.

# First, filter the data to only include the relevant bacterium and treatment groups.
de_data <- final_data |>
  filter(
    # The name may need to be adjusted to exactly match your data.
    str_detect(g_s, "s__Enterococcus_faecalis"),
    treatment %in% c("Biapenem, Sucrose", "PBS, Sucrose"),
    # We are comparing both groups at the same timepoint.
    timepoint_day == 1
  ) 
```


```{r}
# Pre-filtering step based on RNA_TPM.
# It's good practice to remove genes with very low expression.
# A common threshold is to keep genes with RNA_TPM > 10 in at least as many
# samples as the smallest group size (which is 4 in this case).
genes_to_keep <- de_data |>
  group_by(gene_fam) |>
  filter(RNA_TPM > 10) |>
  summarise(n_samples_expr = n(), .groups = 'drop') |>
  filter(n_samples_expr >= 4) |>
  pull(gene_fam)

# Apply the filter to our data.
de_data_filtered <- de_data |>
  filter(gene_fam %in% genes_to_keep)

# Now, calculate the average expression and run a Wilcoxon test for each gene, using RNA_TPM.
de_results <- de_data_filtered |>
  group_by(gene_fam) |>
  # Ensure there are still observations in both groups after filtering.
  filter(n_distinct(treatment) > 1) |>
  summarise(
    # Calculate the average expression for each group using RNA_TPM.
    mean_expr_treated = mean(RNA_TPM[treatment == "Biapenem, Sucrose"], na.rm = TRUE),
    mean_expr_control = mean(RNA_TPM[treatment == "PBS, Sucrose"], na.rm = TRUE),
    # Handle the "present vs. absent" case explicitly. If a gene is completely
    # absent in the control group, we consider this highly significant.
    p_value = {
      if (mean_expr_control == 0) {
        0
      } else {
        # Perform the Wilcoxon test on the RNA_TPM values.
        test_res <- try(wilcox.test(RNA_TPM ~ treatment), silent = TRUE)
        if (inherits(test_res, "try-error")) NA_real_ else test_res$p.value
      }
    }
  ) |>
  # Ungroup to ensure subsequent operations apply to the whole data frame.
  ungroup() |>
  # Calculate the log2 fold change. A pseudocount of 1 is added to avoid log(0).
  mutate(
    log2_fold_change = log2((mean_expr_treated + 1) / (mean_expr_control + 1))
  ) |>
  # Arrange the results to see the most significant changes first.
  arrange(p_value)

# Print the top differentially expressed genes.
print(head(de_results))

# You can now explore the `de_results` table.
# Genes with a high absolute log2_fold_change and a low p_value (e.g., < 0.05)
# are the most interesting candidates for follow-up.

# For example, to find genes that are significantly upregulated in the treated group:
upregulated_genes <- de_results |>
  filter( log2_fold_change > median(de_results$log2_fold_change))

```

# annotation

```{r}
# --- Annotate Upregulated Genes with Functions ---

# Take the list of upregulated genes.
ko_ids <- de_results$gene_fam


# **FIX**: Replace batch queries with a more robust single-query loop.
# This is slower but prevents one bad ID from crashing the whole process.
kegg_results <- list() # Initialize an empty list to store successful results.

# Loop over each ID.
for (id in ko_ids) {
  # Use tryCatch to handle any errors that might occur for a single ID.
  result <- tryCatch({
    keggGet(id)
  }, error = function(e) {
    # If an error occurs, print a message to the console and return NULL.
    message(paste("Could not retrieve info for:", id, "\nError:", e$message))
    return(NULL)
  })

  # If the query was successful (not NULL), add it to our results list.
  if (!is.null(result)) {
    kegg_results <- c(kegg_results, result)
  }
}


# A function to parse the complex list structure from keggGet.
# It will extract multiple fields and flatten them into a single-row tibble.
extract_kegg_info <- function(kegg_entry) {
  # A small helper function to safely extract and collapse a field into a single string.
  # The `%||%` operator is a handy shortcut for `if (is.null(x)) y else x`.
  flatten_field <- function(field_name) {
    # Safely get the content of a field.
    content <- kegg_entry[[field_name]] %||% NA_character_
    # Paste all elements together, separated by a semicolon.
    paste(content, collapse = "; ")
  }

  # Build a one-row data frame (tibble) with all the desired information.
  tibble(
    gene_fam = str_remove(kegg_entry$ENTRY %||% NA_character_, "ko:"),
    name = kegg_entry$NAME %||% NA_character_,
    symbol = flatten_field("SYMBOL"),
    pathway = flatten_field("PATHWAY"),
    module = flatten_field("MODULE"),
    brite = flatten_field("BRITE")
  )
}


# Process the results into a clean table.
# We check if there are any results before trying to process them.
if (length(kegg_results) > 0) {
  # Apply the new parsing function to every entry in our results list.
  # map_dfr row-binds all the resulting one-row tibbles into a single data frame.
  gene_annotations <- map_dfr(kegg_results, extract_kegg_info)

  # Join these rich annotations back to our original results table.
  annotated_de_results <- left_join(de_results, gene_annotations, by = "gene_fam")

} else {
  # If no definitions were found at all, just add empty annotation columns.
  annotated_de_results <- de_results |>
    mutate(
      name = NA_character_,
      symbol = NA_character_,
      pathway = NA_character_,
      module = NA_character_,
      brite = NA_character_
    )
}

print(annotated_de_results)

# annotated_de_results |> write_tsv('../data/R48_annotated_de_results.tsv')
```

# Entercoccus abundance in the bars

```{r}
# --- Focused Composition Plot ---
sample_order_day1 <- c("MR12", "MR14", "MR15", "MR13", "MR4", "MR5", "MR6", "MR7")

# Filter the data for Day 1 samples in the two sucrose groups.
day1_comp_data <- final_data |>
  filter(timepoint_day == 1, treatment %in% c("PBS, Sucrose", "Biapenem, Sucrose")) |> 
  mutate(treatment = factor(treatment, levels = c("PBS, Sucrose", "Biapenem, Sucrose")))

# Prepare data for plotting, highlighting only Enterococcus.
day1_plot_data <- day1_comp_data |>
  mutate(
    # Create a new column to highlight our species of interest.
    g_s_highlight = ifelse(str_detect(g_s, "s__Enterococcus_faecalis"), "Enterococcus faecalis", "Other"),
    # Define the order of samples to match the heatmap.
    sample_id = factor(sample_id, levels = sample_order_day1)
  ) |>
  # Group by the new highlight column and sum abundances.
  group_by(sample_id, treatment, g_s_highlight) |>
  summarise(relative_abundance = sum(relative_abundance, na.rm = TRUE), .groups = 'drop') |>
  # Ensure the sample order is maintained.
  arrange(sample_id)


# Create the focused composition plot.
bar_plot_day1 <- ggplot(day1_plot_data, aes(x = sample_id, y = relative_abundance, fill = g_s_highlight)) +
  geom_col(position = "fill") +
  # Use a manual color scale to set Enterococcus to red and everything else to gray.
  scale_fill_manual(values = c("Enterococcus faecalis" = "#4DAF4A", "Other" = "#999999")) +
  # Facet by treatment to separate the groups.
  facet_grid(. ~ treatment, scales = "free_x", space = "free_x") +
  labs(
    x = "Sample",
    y = "Relative Abundance",
    fill = "Taxa"
  ) +
  theme_bw() +
  theme(
    # Remove x-axis elements to align with the heatmap below.
    axis.title.x = element_blank(),
    #axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.position = "right"
  )

# Print the new plot.
print(bar_plot_day1)
```


# heatmap : Enterococcus is doing ..

```{r}
annotated_de_results <- read_tsv('../data/R48_annotated_de_results.tsv')

# --- Heatmap Visualization ---

# Manually define which genes belong to which category for the heatmap.

# 1. Define categories for specific metabolic pathways manually.
pts_genes <- annotated_de_results |>
  filter(str_detect(name, "PTS") |str_detect(pathway, "PTS") ) |>
  select(gene_fam) |>
  mutate(category = "Phosphotransferase System")

# "Galactose metabolism" in the pathway, and "Glycolysis / Gluconeogenesis;" in the pathway
# Find genes related to Central Metabolism by searching for specific pathways.
central_metab_genes <- annotated_de_results |>
  filter(str_detect(pathway, "Galactose metabolism|Glycolysis / Gluconeogenesis")) |>
  select(gene_fam) |>
  mutate(category = "Central Metabolism")

# 2. Find genes for "Building Essential Components" based on keywords.
# Find all genes with "ribosomal" in their name from the annotated results.
ribosomal_genes <- annotated_de_results |>
  filter(str_detect(name, "ribosomal")) |>
  select(gene_fam) |>
  mutate(category = "Building Essential Components")

# Find all genes with "Arginine" in their pathway description.
arginine_genes <- annotated_de_results |>
  filter(str_detect(pathway, "Arginine")) |>
  select(gene_fam) |>
  mutate(category = "Building Essential Components")


# 3. Combine all categories into a single data frame.
# We bind the rows and then use `distinct` to avoid any duplicates if a gene fits multiple criteria.
gene_categories <- bind_rows(
  pts_genes,
  central_metab_genes,
  ribosomal_genes,
  arginine_genes
) |>
  distinct()


# Prepare the data for the heatmap.
heatmap_data <- de_data |>
  # Keep only the genes we have categorized.
  inner_join(gene_categories, by = "gene_fam") |>
  # Add the gene names from our annotation table for better labels.
  left_join(select(annotated_de_results, gene_fam, name), by = "gene_fam") |>
  # Create a more descriptive label for the heatmap rows.
  mutate(
    # Clean the gene name by removing the EC number for cleaner labels.
    name_clean = str_remove(name, "\\s\\[EC:.*\\]$"),
    gene_label = paste0(gene_fam, " | ", name_clean),
    # Log-transform RNA_TPM for better color scaling in the heatmap.
    log2_tpm = log2(RNA_TPM + 1),
    # Reverse the order of the treatment factor for the plot.
    treatment = factor(treatment, levels = c("PBS, Sucrose", "Biapenem, Sucrose")),
    sample_id = factor(sample_id, levels = sample_order_day1)
  )

# Create the heatmap using ggplot2.
heatmap_plot_day1 <- ggplot(heatmap_data, aes(x = sample_id, y = gene_label, fill = log2_tpm)) +
  # geom_tile creates the colored squares of the heatmap.
  geom_tile(color = "white", linewidth = 0.5) +
  # Move the gene labels to the right side of the plot.
  scale_y_discrete(position = "right") +
  # Use facet_grid to group the samples by treatment and the genes by category.
  # The `switch = "y"` argument moves the category labels to the left.
  facet_grid(category ~ treatment, scales = "free", space = "free", switch = "y") +
  # Use the Viridis color scale, which is good for colorblind viewers and prints well in grayscale.
  scale_fill_viridis_c(option = "plasma") +
  # Add labels and a title.
  labs(
    x = "Sample",
    y = "",
    fill = "Log2(RNA TPM + 1)"
  ) +
  # Use a minimal theme.
  theme_minimal() +
  # Customize theme elements for readability.
  theme(
    axis.text.x = element_text(angle = 0, vjust = 0.5, hjust = 1, size = 8),
    axis.text.y = element_text(size = 8),
    # Adjust the y-axis strip text now that it's on the left, and left-align it.
    strip.text.y.left = element_text(angle = 0, face = "bold", hjust = 0),
    strip.text.x = element_text(face = "bold"),
    legend.position = "bottom"
  )

# Print the heatmap.
print(heatmap_plot_day1)

ggsave('../data/R48_heatmap_plot_TPM_Day 1 Biapenem + Sucrose vs. PBS + Sucrose.pdf', width = 10, height = 8, plot = heatmap_plot_day1)
```
## stacking 

```{r}
# 5. Combine the plots 
# The `plot_grid` function arranges the plots. `align = 'v'` is crucial for
# ensuring the plotting areas are vertically aligned.
combined_plot <- plot_grid(
  bar_plot_day1,
  heatmap_plot_day1,
  ncol = 1,
  align = 'v',
  rel_heights = c(1, 4) # Make bar plot smaller
)

# Add a title using `ggdraw()` and `draw_plot()` from cowplot
# This creates a blank canvas and places the plot grid onto it, leaving space for a title.
final_plot_with_title <- ggdraw() +
  draw_plot(combined_plot, 0, 0, 1, 0.95) + # x, y, width, height
  draw_label(
    "Enterococcus Abundance and Gene Expression on Day 1",
    x = 0.5, y = 0.99, vjust = 1, fontface = 'bold'
  ) +
  draw_label(
    "Comparison between PBS + Sucrose and Biapenem + Sucrose Treatments",
    x = 0.5, y = 0.97, vjust = 1, size = 10
  )


# Print the final combined plot.
print(final_plot_with_title)

ggsave('../data/R48_combined_plot_Day 1 Biapenem + Sucrose vs. PBS + Sucrose.pdf', width = 10, height = 11, plot = final_plot_with_title)
```

# abx +/- sucrose on day 1

```{r}
# --- New Analysis: Day 1, Hydrogel vs Sucrose in abx treated samples ---

# Goal: Find genes in Enterococcus that are differentially expressed between
# "Biapenem, Plain Hydrogel" and "Biapenem, Sucrose" at Day 1.

# 1. Filter data for the new comparison.
de_data_hydrogel_vs_sucrose <- final_data |>
  filter(
    str_detect(g_s, "s__Enterococcus_faecalis"),
    treatment %in% c("Biapenem, Plain Hydrogel", "Biapenem, Sucrose"),
    timepoint_day == 1
  )

# 2. Filter for expressed genes.
genes_to_keep_hydrogel_vs_sucrose <- de_data_hydrogel_vs_sucrose |>
  group_by(gene_fam) |>
  filter(RNA_TPM > 10) |>
  summarise(n_samples_expr = n(), .groups = 'drop') |>
  # Both groups have 4 samples.
  filter(n_samples_expr >= 4) |>
  pull(gene_fam)

de_data_filtered_hydrogel_vs_sucrose <- de_data_hydrogel_vs_sucrose |>
  filter(gene_fam %in% genes_to_keep_hydrogel_vs_sucrose)

# 3. Perform Wilcoxon test.
de_results_hydrogel_vs_sucrose <- de_data_filtered_hydrogel_vs_sucrose |>
  group_by(gene_fam) |>
  filter(n_distinct(treatment) > 1) |>
  summarise(
    mean_expr_hydrogel = mean(normalized_TPM[treatment == "Biapenem, Plain Hydrogel"], na.rm = TRUE),
    mean_expr_sucrose = mean(normalized_TPM[treatment == "Biapenem, Sucrose"], na.rm = TRUE),
    p_value = {
      test_res <- try(wilcox.test(normalized_TPM ~ treatment), silent = TRUE)
      if (inherits(test_res, "try-error")) NA_real_ else test_res$p.value
    }
  ) |>
  ungroup() |>
  # Add p-value adjustment for multiple comparisons (Benjamini-Hochberg method).
  mutate(p_adj = p.adjust(p_value, method = "BH")) |>
  mutate(log2_fold_change = log2((mean_expr_sucrose + 1) / ( mean_expr_hydrogel+ 1))) |>
  # Arrange by the absolute fold change to see the largest effects first.
  arrange(desc(abs(log2_fold_change)))

# 4. Find top candidate genes using a log2 fold change cutoff.
# This is a common strategy when no genes are significant after p-value adjustment.
# It allows for exploratory analysis of the genes with the largest effect sizes.
candidate_genes_hydrogel_vs_sucrose <- de_results_hydrogel_vs_sucrose |>
  filter(abs(log2_fold_change) > 1)
```


```{r}
# Take the list of upregulated genes.
ko_ids <- candidate_genes_hydrogel_vs_sucrose$gene_fam

# Replace batch queries with a more robust single-query loop.
# This is slower but prevents one bad ID from crashing the whole process.
kegg_results <- list() # Initialize an empty list to store successful results.

# Loop over each ID.
for (id in ko_ids) {
  # Use tryCatch to handle any errors that might occur for a single ID.
  result <- tryCatch({
    keggGet(id)
  }, error = function(e) {
    # If an error occurs, print a message to the console and return NULL.
    message(paste("Could not retrieve info for:", id, "\nError:", e$message))
    return(NULL)
  })

  # If the query was successful (not NULL), add it to our results list.
  if (!is.null(result)) {
    kegg_results <- c(kegg_results, result)
  }
}

# A function to parse the complex list structure from keggGet.
# It will extract multiple fields and flatten them into a single-row tibble.
extract_kegg_info <- function(kegg_entry) {
  # A small helper function to safely extract and collapse a field into a single string.
  # The `%||%` operator is a handy shortcut for `if (is.null(x)) y else x`.
  flatten_field <- function(field_name) {
    # Safely get the content of a field.
    content <- kegg_entry[[field_name]] %||% NA_character_
    # Paste all elements together, separated by a semicolon.
    paste(content, collapse = "; ")
  }

  # Build a one-row data frame (tibble) with all the desired information.
  tibble(
    gene_fam = str_remove(kegg_entry$ENTRY %||% NA_character_, "ko:"),
    name = kegg_entry$NAME %||% NA_character_,
    symbol = flatten_field("SYMBOL"),
    pathway = flatten_field("PATHWAY"),
    module = flatten_field("MODULE"),
    brite = flatten_field("BRITE")
  )
}

# Process the results into a clean table.
# We check if there are any results before trying to process them.
if (length(kegg_results) > 0) {
  # Apply the new parsing function to every entry in our results list.
  # map_dfr row-binds all the resulting one-row tibbles into a single data frame.
  gene_annotations <- map_dfr(kegg_results, extract_kegg_info)

  # Join these rich annotations back to our original results table.
  annotated_de_results_hydrogel_vs_sucrose <- left_join(candidate_genes_hydrogel_vs_sucrose, gene_annotations, by = "gene_fam")

} else {
  # If no definitions were found at all, just add empty annotation columns.
  annotated_de_results_hydrogel_vs_sucrose <- candidate_genes_hydrogel_vs_sucrose |>
    mutate(
      name = NA_character_,
      symbol = NA_character_,
      pathway = NA_character_,
      module = NA_character_,
      brite = NA_character_
    )
}

print(annotated_de_results_hydrogel_vs_sucrose)

```

## Combined Plot

```{r}
# --- Combined Plot: Day 1, Hydrogel vs Sucrose ---

# 1. Define the specific sample order for this plot
sample_order_hydrogel <- de_data_hydrogel_vs_sucrose |>
  arrange(treatment) |>
  pull(sample_id) |>
  unique()

# 2. Create the focused compositional bar plot
bar_plot_hydrogel_vs_sucrose <- final_data |>
  filter(sample_id %in% sample_order_hydrogel) |>
  mutate(
    g_s_highlight = ifelse(str_detect(g_s, "s__Enterococcus_faecalis"), "s__Enterococcus_faecalis", "Other"),
    sample_id = factor(sample_id, levels = sample_order_hydrogel),
    treatment = factor(treatment, levels = c( "Biapenem, Plain Hydrogel", "Biapenem, Sucrose"))
  ) |>
  group_by(sample_id, treatment, g_s_highlight) |>
  summarise(relative_abundance = sum(relative_abundance, na.rm = TRUE), .groups = 'drop') |>
  ggplot(aes(x = sample_id, y = relative_abundance, fill = g_s_highlight)) +
  geom_col(position = "fill") +
  scale_fill_manual(values = c("s__Enterococcus_faecalis" = "#4DAF4A", "Other" = "#999999")) +
  facet_grid(. ~ treatment, scales = "free_x", space = "free_x") +
  labs(y = "Relative Abundance", fill = "Taxa") +
  theme_bw() +
  theme(
    axis.title.x = element_blank(),
    #axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.position = "bottom"
  )

# 3. Create the heatmap of candidate genes
# First, prepare the data and define the gene order in a separate step for clarity.
heatmap_prep_data <- de_data_hydrogel_vs_sucrose |>
  filter(gene_fam %in% candidate_genes_hydrogel_vs_sucrose$gene_fam) |>
  left_join(annotated_de_results_hydrogel_vs_sucrose, by = "gene_fam") |>
  mutate(
    name_clean = str_remove(name, "\\s\\[EC:.*\\]$"),
    gene_label = paste0(gene_fam, " | ", name_clean)
  ) |> 
  filter(sample_id != 'MR4')

# Define the order of genes for the heatmap's y-axis based on log2 fold change.
gene_order <- heatmap_prep_data |>
  # We only need one row per gene to determine the order.
  distinct(gene_label, log2_fold_change) |>
  # Arrange by ascending fold change.
  arrange(log2_fold_change) |>
  # Pull out the gene labels as a character vector. This vector is now correctly ordered.
  pull(gene_label)

# Now, create the final data for plotting.
heatmap_data_hydrogel_vs_sucrose <- heatmap_prep_data |>
  filter(gene_fam %in% candidate_genes_hydrogel_vs_sucrose$gene_fam) |>
  left_join(select(annotated_de_results_hydrogel_vs_sucrose, gene_fam, name), by = "gene_fam") |>
  # Group by gene to calculate z-score for each gene across all samples.
  group_by(gene_fam) |>
  mutate(
    # Calculate the z-score of the normalized TPM.
    z_score = as.numeric(scale(normalized_TPM))
  ) |>
  ungroup() |>
  mutate(
    # Apply the pre-defined order to the gene_label factor.
    gene_label = factor(gene_label, levels = gene_order),
    sample_id = factor(sample_id, levels = sample_order_hydrogel),
    treatment = factor(treatment, levels = c( "Biapenem, Plain Hydrogel", "Biapenem, Sucrose"))
  )

heatmap_plot_hydrogel_vs_sucrose <- ggplot(heatmap_data_hydrogel_vs_sucrose, aes(x = sample_id, y = gene_label, fill = z_score)) +
  geom_tile(color = "white", linewidth = 0.5) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  # Move the gene labels to the right side of the plot.
  scale_y_discrete(position = "right") +
  facet_grid(. ~ treatment, scales = "free_x", space = "free_x") +
  labs(
    x = "Sample",
    y = "",
    # Update the legend title
    fill = "Z-score (Normalized TPM)"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 8),
    # Ensure the y-axis text on the right is formatted.
    axis.text.y.right = element_text(size = 8),
    strip.text = element_text(face = "bold"),
    legend.position = "bottom"
  )

# 4. Combine plots using cowplot
combined_hydrogel_plot <- plot_grid(
  bar_plot_hydrogel_vs_sucrose,
  heatmap_plot_hydrogel_vs_sucrose,
  ncol = 1,
  align = 'v',
  rel_heights = c(1, 1.5)
)

# 5. Add a title
final_hydrogel_plot_with_title <- ggdraw() +
  draw_plot(combined_hydrogel_plot, 0, 0, 1, 0.95) +
  draw_label(
    "Enterococcus Composition and Gene Expression on Day 1",
    x = 0.5, y = 0.99, vjust = 1, fontface = 'bold'
  ) +
  draw_label(
    "Comparison between Biapenem + Sucrose and Biapenem + Hydrogel",
    x = 0.5, y = 0.97, vjust = 1, size = 10
  )

print(final_hydrogel_plot_with_title)

ggsave('../data/R48_combined_plot_Day 1 Comparison between Biapenem + Sucrose and Biapenem + Hydrogel.pdf', width = 7, height = 8, plot = final_hydrogel_plot_with_title)
```

# Day 3 data 

```{r}

```

