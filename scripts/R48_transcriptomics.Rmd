---
title: "Transcriptomics"
output: html_document
date: "2025-10-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

some mice are sacrificed at day 1 and some at day 3. normalized TPM is what needs to be used. 

```{r}
library(tidyverse)
# The fs package is great for working with the file system in a way that works
# across different operating systems (Windows, macOS, Linux).
library(fs)
library(janitor)
library(KEGGREST)
```


```{r}
data_folder <- "../data/taxo_normalized_rna_kos/"
metadata_file <- "../data/sample_metadata.csv"

# --- Script Logic ---
# Get a list of all files in the specified folder that end with ".tsv".
# dir_ls() from the fs package finds the files, and the glob argument acts as a filter.
file_paths <- dir_ls(data_folder, glob = "*.tsv")

combined_data <- map_dfr(file_paths, read_tsv, .id = "source_file") |>
  # This next step just cleans up the source_file column to only show the filename
  # itself, rather than the full path (e.g., "MR1.tsv" instead of "path/to/your/data_folder/MR1.tsv").
  mutate(source_file = path_file(source_file))|>
  mutate(sample_id = str_remove(source_file, ".tsv"))


# --- Metadata Integration ---
# Read the metadata. Based on your screenshot, it looks like a CSV.
# We'll also select only the first four columns as you requested.
metadata <- read_csv(metadata_file) |>
  clean_names() |>
  select(1:4)

final_data <- left_join(combined_data, metadata, by = "sample_id") |> select(-source_file, -...1) |> rename(relative_abundance = relvative_abundance)
# final_data table doesn't just list which bacteria are present. The columns like RNA_TPM and normalized_TPM measure the expression level of specific genes (gene_fam).

# A high TPM value for a gene involved in metabolizing sucrose in a sample from the "PBS, Sucrose" group means the bacteria are actively eating the sucrose you provided.
# 
# A high TPM value for an antibiotic resistance gene in the "Biapenem" group means the bacteria are actively fighting off the antibiotic to survive.
```

# composition from the shallow shotgun

```{r}
# --- Visualization of Microbial Composition ---

# To make the plot readable, it's often best to visualize only the most abundant taxa.
# Here, we find the top 10 most abundant taxa across the entire dataset.
top_taxa <- final_data |>
  group_by(g_s) |>
  summarise(total_abundance = sum(relative_abundance, na.rm = TRUE)) |>
  slice_max(order_by = total_abundance, n = 10) |>
  pull(g_s)

# Prepare the data for plotting. This involves a few steps:
# 1. Lump less abundant taxa into an "Other" category.
# 2. Convert the 'treatment' column to a factor with a specific order for the plot facets.
# 3. Group by the key variables and sum the abundances, which aggregates the new "Other" category.
plot_data <- final_data |>
  mutate(
    g_s_display = ifelse(g_s %in% top_taxa, as.character(g_s), "Other"),
    treatment = factor(treatment, levels = c("Not Treated", "PBS, Sucrose", "Biapenem, Plain Hydrogel", "Biapenem, Sucrose"))
  ) |>
  group_by(sample_id, timepoint_day, treatment, g_s_display) |>
  summarise(relative_abundance = sum(relative_abundance, na.rm = TRUE), .groups = 'drop')

# --- Custom Color Palette ---
# Define a set of contrasting colors. You can adjust these hex codes.
# This palette excludes "gray" for the main taxa.
contrasting_colors <- c(
  "#E41A1C", "#377EB8", "#FFFF33", "#984EA3", "#FF7F00",
  "#4DAF4A", "#A65628", "#F781BF", "#999999", "blue" # Example, you might need more if > 9 taxa
)

# Determine the number of unique top taxa to assign colors.
num_top_taxa <- length(setdiff(unique(plot_data$g_s_display), "Other"))

# Create the full color mapping, ensuring "Other" is specifically gray.
# We'll use the first `num_top_taxa` colors for the main taxa.
color_map <- c(setNames(contrasting_colors[1:num_top_taxa], sort(setdiff(unique(plot_data$g_s_display), "Other"))),
               "Other" = "gray70") # A light gray for 'Other'

# Create the faceted bar plot.
composition_plot <- ggplot(plot_data, aes(x = sample_id, y = relative_abundance, fill = g_s_display)) +
  # geom_col creates the bars; position="fill" makes each bar a stacked percentage plot (100% height).
  geom_col(position = "fill") +
  # Apply the custom color palette.
  scale_fill_manual(values = color_map) +
  # facet_grid creates the panel of plots. Rows are timepoints, columns are treatments.
  # `scales = "free_x"` and `space = "free_x"` ensure that each panel only shows the relevant samples.
  facet_grid(timepoint_day ~ treatment, scales = "free_x", space = "free_x") +
  # Add labels and a title.
  labs(
    title = "Microbial Composition Across Treatments and Timepoints",
    x = "Sample",
    y = "Relative Abundance",
    fill = "Taxa (Top 10 + Other)"
  ) +
  # Use a clean black and white theme.
  theme_bw() +
  # Customize the theme for better readability.
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    strip.text = element_text(face = "bold"),
    legend.position = "bottom"
  )

# Print the plot to the R viewer.
print(composition_plot)
ggsave('../data/R48_composition_plot.pdf', width = 13, plot = composition_plot, height = 10)

# You can now work with the 'final_data' data frame for your analysis.
# For example, to save it to a new CSV file:
write_csv(final_data, "../data/R48_final_combined_output.csv")
```

# statistical test

```{r}
# --- Differential Expression Analysis  ---
# Goal: Find genes in Enterococcus that are differentially expressed between
# "Biapenem, Plain Hydrogel" at Day 3 and the "Not Treated" control group.

# First, filter the data to only include the relevant bacterium and treatment groups.
de_data <- final_data |>
  filter(
    # The name may need to be adjusted to exactly match your data.
    str_detect(g_s, "s__Enterococcus_faecalis"),
    treatment %in% c("Biapenem, Sucrose", "PBS, Sucrose"),
    # We are comparing both groups at the same timepoint.
    timepoint_day == 1
  ) 
```


```{r}
# Pre-filtering step based on RNA_TPM.
# It's good practice to remove genes with very low expression.
# A common threshold is to keep genes with RNA_TPM > 10 in at least as many
# samples as the smallest group size (which is 4 in this case).
genes_to_keep <- de_data |>
  group_by(gene_fam) |>
  filter(RNA_TPM > 10) |>
  summarise(n_samples_expr = n(), .groups = 'drop') |>
  filter(n_samples_expr >= 4) |>
  pull(gene_fam)

# Apply the filter to our data.
de_data_filtered <- de_data |>
  filter(gene_fam %in% genes_to_keep)

# Now, calculate the average expression and run a Wilcoxon test for each gene, using RNA_TPM.
de_results <- de_data_filtered |>
  group_by(gene_fam) |>
  # Ensure there are still observations in both groups after filtering.
  filter(n_distinct(treatment) > 1) |>
  summarise(
    # Calculate the average expression for each group using RNA_TPM.
    mean_expr_treated = mean(RNA_TPM[treatment == "Biapenem, Sucrose"], na.rm = TRUE),
    mean_expr_control = mean(RNA_TPM[treatment == "PBS, Sucrose"], na.rm = TRUE),
    # Handle the "present vs. absent" case explicitly. If a gene is completely
    # absent in the control group, we consider this highly significant.
    p_value = {
      if (mean_expr_control == 0) {
        0
      } else {
        # Perform the Wilcoxon test on the RNA_TPM values.
        test_res <- try(wilcox.test(RNA_TPM ~ treatment), silent = TRUE)
        if (inherits(test_res, "try-error")) NA_real_ else test_res$p.value
      }
    }
  ) |>
  # Ungroup to ensure subsequent operations apply to the whole data frame.
  ungroup() |>
  # Calculate the log2 fold change. A pseudocount of 1 is added to avoid log(0).
  mutate(
    log2_fold_change = log2((mean_expr_treated + 1) / (mean_expr_control + 1))
  ) |>
  # Arrange the results to see the most significant changes first.
  arrange(p_value)

# Print the top differentially expressed genes.
print(head(de_results))

# You can now explore the `de_results` table.
# Genes with a high absolute log2_fold_change and a low p_value (e.g., < 0.05)
# are the most interesting candidates for follow-up.

# For example, to find genes that are significantly upregulated in the treated group:
upregulated_genes <- de_results |>
  filter( log2_fold_change > median(de_results$log2_fold_change))

```

# annotation

```{r}
# --- Annotate Upregulated Genes with Functions ---

# Take the list of upregulated genes.
ko_ids <- de_results$gene_fam


# **FIX**: Replace batch queries with a more robust single-query loop.
# This is slower but prevents one bad ID from crashing the whole process.
kegg_results <- list() # Initialize an empty list to store successful results.

# Loop over each ID.
for (id in ko_ids) {
  # Use tryCatch to handle any errors that might occur for a single ID.
  result <- tryCatch({
    keggGet(id)
  }, error = function(e) {
    # If an error occurs, print a message to the console and return NULL.
    message(paste("Could not retrieve info for:", id, "\nError:", e$message))
    return(NULL)
  })

  # If the query was successful (not NULL), add it to our results list.
  if (!is.null(result)) {
    kegg_results <- c(kegg_results, result)
  }
}


# A function to parse the complex list structure from keggGet.
# It will extract multiple fields and flatten them into a single-row tibble.
extract_kegg_info <- function(kegg_entry) {
  # A small helper function to safely extract and collapse a field into a single string.
  # The `%||%` operator is a handy shortcut for `if (is.null(x)) y else x`.
  flatten_field <- function(field_name) {
    # Safely get the content of a field.
    content <- kegg_entry[[field_name]] %||% NA_character_
    # Paste all elements together, separated by a semicolon.
    paste(content, collapse = "; ")
  }

  # Build a one-row data frame (tibble) with all the desired information.
  tibble(
    gene_fam = str_remove(kegg_entry$ENTRY %||% NA_character_, "ko:"),
    name = kegg_entry$NAME %||% NA_character_,
    symbol = flatten_field("SYMBOL"),
    pathway = flatten_field("PATHWAY"),
    module = flatten_field("MODULE"),
    brite = flatten_field("BRITE")
  )
}


# Process the results into a clean table.
# We check if there are any results before trying to process them.
if (length(kegg_results) > 0) {
  # Apply the new parsing function to every entry in our results list.
  # map_dfr row-binds all the resulting one-row tibbles into a single data frame.
  gene_annotations <- map_dfr(kegg_results, extract_kegg_info)

  # Join these rich annotations back to our original results table.
  annotated_de_results <- left_join(de_results, gene_annotations, by = "gene_fam")

} else {
  # If no definitions were found at all, just add empty annotation columns.
  annotated_de_results <- de_results |>
    mutate(
      name = NA_character_,
      symbol = NA_character_,
      pathway = NA_character_,
      module = NA_character_,
      brite = NA_character_
    )
}


print(annotated_de_results)

annotated_de_results |> write_tsv('../data/R48_annotated_de_results.tsv')
```

# heatmap : Enterococcus is doing ..

```{r}
annotated_de_results <- read_tsv('../data/R48_annotated_de_results.tsv')

# --- Heatmap Visualization ---

# Manually define which genes belong to which category for the heatmap.

# 1. Define categories for specific metabolic pathways manually.
pts_genes <- tibble(
  gene_fam = c("K08483", "K02795"),
  category = "Phosphotransferase System"   #'PTS' is the keyword
)

# "Galactose metabolism" in the pathway, and "Glycolysis / Gluconeogenesis;" in the pathway
# Find genes related to Central Metabolism by searching for specific pathways.
central_metab_genes <- annotated_de_results |>
  filter(str_detect(pathway, "Galactose metabolism|Glycolysis / Gluconeogenesis")) |>
  select(gene_fam) |>
  mutate(category = "Central Metabolism")

# 2. Find genes for "Building Essential Components" based on keywords.
# Find all genes with "ribosomal" in their name from the annotated results.
ribosomal_genes <- annotated_de_results |>
  filter(str_detect(name, "ribosomal")) |>
  select(gene_fam) |>
  mutate(category = "Building Essential Components")

# Find all genes with "Arginine" in their pathway description.
arginine_genes <- annotated_de_results |>
  filter(str_detect(pathway, "Arginine")) |>
  select(gene_fam) |>
  mutate(category = "Building Essential Components")


# 3. Combine all categories into a single data frame.
# We bind the rows and then use `distinct` to avoid any duplicates if a gene fits multiple criteria.
gene_categories <- bind_rows(
  pts_genes,
  central_metab_genes,
  ribosomal_genes,
  arginine_genes
) |>
  distinct()


# Prepare the data for the heatmap.
heatmap_data <- de_data |>
  # Keep only the genes we have categorized.
  inner_join(gene_categories, by = "gene_fam") |>
  # Add the gene names from our annotation table for better labels.
  left_join(select(annotated_de_results, gene_fam, name), by = "gene_fam") |>
  # Create a more descriptive label for the heatmap rows.
  mutate(
    gene_label = paste0(gene_fam, " | ", name),
    # Log-transform RNA_TPM for better color scaling in the heatmap. Adding 1 avoids log(0).
    log2_tpm = log2(RNA_TPM + 1)
  )

# Create the heatmap using ggplot2.
heatmap_plot <- ggplot(heatmap_data, aes(x = sample_id, y = gene_label, fill = log2_tpm)) +
  # geom_tile creates the colored squares of the heatmap.
  geom_tile(color = "white", linewidth = 0.5) +
  # Use facet_grid to group the samples by treatment and the genes by category.
  # `scales = "free"` and `space = "free"` make the panels adjust to their contents.
  facet_grid(category ~ treatment, scales = "free", space = "free") +
  # Use the Viridis color scale, which is good for colorblind viewers and prints well in grayscale.
  scale_fill_viridis_c(option = "plasma") +
  # Add labels and a title.
  labs(
    title = "Heatmap of Upregulated Enterococcus Genes",
    subtitle = "Day 1: Biapenem + Sucrose vs. PBS + Sucrose",
    x = "Sample",
    y = "Gene",
    fill = "Log2(RNA TPM + 1)"
  ) +
  # Use a minimal theme.
  theme_minimal() +
  # Customize theme elements for readability.
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 8),
    axis.text.y = element_text(size = 8),
    strip.text.y = element_text(angle = 0, face = "bold"),
    strip.text.x = element_text(face = "bold"),
    legend.position = "bottom"
  )

# Print the heatmap.
print(heatmap_plot)

ggsave('../data/R48_heatmap_plot_TPM_Day 1 Biapenem + Sucrose vs. PBS + Sucrose.pdf', width = 10, height = 8, plot = heatmap_plot)
```

