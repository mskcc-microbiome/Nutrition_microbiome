---
title: "abx * sugar and compositonal change"
output: html_document
date: "2025-07-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(brms)   
library(broom.mixed)
library(tidybayes)
library(patchwork)
library(ape)  
library(ggridges)
library(vegan)
library(ggrepel) # For better label placement
library(RColorBrewer)
```

Model the magnitude of compositional disruption itself. This is done by using a beta-diversity metric (like Bray-Curtis distance) from each patient's baseline sample as a continuous outcome variable. 

```{r}
joined <- read_csv('../data/R06_joined_diet_stool_distance_to_earliest.csv')

meta <- read_csv('../data/153_combined_META.csv') %>% 
  mutate(intensity = factor(intensity, levels = c('nonablative','reduced','ablative'))) %>%
  mutate(pid = factor(pid)) %>%
    # This divides all the new intake columns by 100.
  mutate(across(starts_with("fg_"), ~ .x / 100))

# find the meta data of the following stool samples (not the earliest one)

n <- nrow(joined)

data <- joined %>% 
  inner_join(meta %>% rename(sampleid2 = sampleid), by = join_by(sampleid2, pid)) 

# how many samples from how many patients
n_samples <- data %>% distinct(sampleid2) %>% nrow
n_patients <- data %>% distinct(pid) %>% nrow

```

```{r}
full_data <- data
# Calculate counts for the full, unfiltered dataset
unfiltered_counts <- full_data %>%
  summarise(
    num_patients = n_distinct(pid),
    num_samples = n_distinct(sampleid2)
  ) %>%
  mutate(Condition = "Unfiltered")

# Calculate counts for the sdrt1 <= 0 filter
filter1_counts <- full_data %>%
  filter(sdrt1 <= 0) %>%
  summarise(
    num_patients = n_distinct(pid),
    num_samples = n_distinct(sampleid2)
  ) %>%
  mutate(Condition = "earliest sample day <= 0")

# Calculate counts for the sdrt1 <= 3 filter
filter2_counts <- full_data %>%
  filter(sdrt1 <= 3) %>%
  summarise(
    num_patients = n_distinct(pid),
    num_samples = n_distinct(sampleid2)
  ) %>%
  mutate(Condition = "earliest sample day <= 3")

# Combine the three summaries into a single dataframe
summary_df <- bind_rows(unfiltered_counts, filter1_counts, filter2_counts) %>%
  # Pivot the data into a "long" format suitable for ggplot2's grouped bar charts
  pivot_longer(
    cols = c(num_patients, num_samples),
    names_to = "Metric",
    values_to = "Count"
  ) %>%
  # Clean up the metric names for better plot labels
  mutate(
    Metric = if_else(Metric == "num_patients", "Patients", "Samples"),
    # Convert Condition to a factor to control the order on the plot
    Condition = factor(Condition, levels = c("Unfiltered", "earliest sample day <= 0", "earliest sample day <= 3"))
  )

# Finally, create the plot using ggplot2
ggplot(summary_df, aes(x = Metric, y = Count, fill = Condition)) +
  # Use geom_bar with stat="identity" because we are providing the y-values directly.
  # position="dodge" creates the side-by-side grouped bars.
  geom_bar(stat = "identity", position = "dodge") +
  # Add text labels on top of each bar for clarity.
  # position_dodge ensures the labels are correctly placed above their respective bars.
  geom_text(
    aes(label = Count),
    position = position_dodge(width = 0.9),
    vjust = -0.5, # Adjust vertical position to be just above the bar
    size = 3.5
  ) +
  # Use a nice color palette for the different conditions
  scale_fill_brewer(palette = "Pastel1") +
  # Add informative labels and a title
  labs(
    title = "Patient and Sample Counts After Filtering",
    subtitle = "Comparison of counts for different earliest sample day value thresholds",
    x = "",
    y = "Total Count",
    fill = "Filter Condition"
  ) +
  # Use a clean, minimal theme
  theme_minimal(base_size = 12) +
  # Make some final theme adjustments
  theme(
    plot.title = element_text(face = "bold", size = 16),
    legend.position = "top"
  )
```


# use all of the samples

```{r}
all_food_vars <- meta %>% select(starts_with('fg')) %>% colnames()

# Create the interaction terms for all food variables in this iteration
interaction_terms <- paste(all_food_vars, "empirical", sep = ":")

# Build the full formula string dynamically
formula_string <- paste(
  "stool_dist ~ 0 + intensity + empirical + TPN + EN +",
  paste(interaction_terms, collapse = " + "),
  "+ (1 | pid) + (1 | timebin)"
)

# Convert the string to a formula object
formula <- brms::bf(as.formula(formula_string))

# Build the priors by adding them together.
# This single prior() call applies to all coefficients listed in `all_food_coefs`.
priors <-
  prior(normal(0, 0.5), class = 'b') + # General prior for all food effects
  # Specific priors that override the general one for non-food covariates
  prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE") +
  prior(normal(0, 0.1), class = 'b', coef = "ENTRUE") +
  prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE")

# Fit the model (using fewer iterations for this example to run quickly)
model_fit <- brm(
  formula = formula,
  data = data   ,
  #prior = priors,
  #family = Beta(link = "logit"), # Use the Beta family
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  iter = 4000, warmup = 1000,
  chains = 2, cores = 10, # Adjust cores as needed
  seed = 123,
  silent = 2
)

results_df <- tidy(model_fit, conf.int = TRUE)
```
## the interval forest plot

```{r}
# This pipe filters for the fixed effects and creates clean, human-readable labels.
cleaned_effects <- results_df %>%
  # Keep only the fixed effects
  filter(effect == "fixed") %>%
  # Create a new column to distinguish main effects from interactions
  mutate(
    effect_type = if_else(str_detect(term, ":"), "Interaction", "Main Effect"),
    # Create clean labels for plotting
    clean_term = term %>%
      str_remove_all("empiricalFALSE:|avg_intake_|TRUE$") %>%
      str_replace("empiricalTRUE:", "abx * ") %>%
      str_replace_all("_", " ")
  )

# Separate into two dataframes for two separate plots
main_effects_df <- cleaned_effects %>% filter(effect_type == "Main Effect")
interaction_df <- cleaned_effects %>% filter(effect_type == "Interaction") %>%
  # Create a new column to identify significant results
  # The condition is TRUE if conf.low and conf.high have the same sign (i.e., don't cross zero)
  mutate(is_significant = (conf.low * conf.high) > 0)


# Plot A: Main Clinical Covariates
plot_main_effects <- ggplot(main_effects_df, aes(x = estimate, y = fct_reorder(clean_term, estimate))) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray50") +
  geom_pointrange(aes(xmin = conf.low, xmax = conf.high), color = "gray50", linewidth = 1, size = 0.7) +
  labs(
    title = '', # Use the name of the list element as the title
    subtitle = "Main Clinical Effects",
    x = "Coefficient Estimate",
    y = "Covariate"
  ) +
  theme_bw(base_size = 12)

```

## heatmap plot

```{r}
# --- 1. Data Preparation ---
# We'll extract all interaction effects and create a single, unique label for each effect.
posterior_draws <- model_fit %>%
  gather_draws(`b_empirical.*:fg_.*`, regex = TRUE) %>%
  mutate(
    # Create a clear label for the two conditions we are comparing.
    condition = if_else(
      str_detect(.variable, "empiricalTRUE"),
      "Abx *",
      ""
    ),
    # Clean up the variable name to get just the food group.
    food_group = str_remove_all(.variable, "b_empirical(TRUE|FALSE):fg_"),
    # Create a unique identifier for each effect by combining food group and condition.
    # This will be our new y-axis.
    effect_label = paste(condition, food_group)
  )

# --- 2. Calculate the Sorting Order ---
# We want to sort the plot based on the median of ALL effects combined.
# This calculates the order and saves it as a character vector.
sorting_order <- posterior_draws %>%
  group_by(effect_label) %>%
  summarise(median_effect = median(.value)) %>%
  arrange(median_effect) %>%
  pull(effect_label) # pull() extracts the single column.

# --- 3. Apply the Sorting Order to All Plotting Data ---
# We apply the calculated order to our main data frame.
posterior_draws_ordered <- posterior_draws %>%
  mutate(effect_label = factor(effect_label, levels = sorting_order))

# --- 4. Create the Forest Plot (Left Panel) ---
# This plot shows the median effect and 95% credible intervals for all effects in one list.
p_forest <- ggplot(posterior_draws_ordered, aes(x = .value, y = effect_label, color = condition)) +
  stat_pointinterval(.width = .95) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  scale_color_manual(values = c("During Antibiotic Exposure" = "skyblue", "No Antibiotic Exposure" = "salmon"), name = "Condition") +
  labs(
    x = "Coefficient Estimate (Change in Bray-Curtis Distance)",
    y = "Food Group Effect"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom")


# --- 5. Create the Probability Heatmap (Right Panel) ---
# This heatmap shows the probability of a positive effect for all effects in a single column.
prob_summary_heatmap <- posterior_draws_ordered %>%
  group_by(effect_label) %>%
  summarise(prob_positive = mean(.value > 0), .groups = 'drop') %>%
  mutate(label_text = scales::percent(prob_positive, accuracy = 1))

p_heatmap <- ggplot(prob_summary_heatmap, aes(x = 1, y = effect_label, fill = prob_positive)) +
  geom_tile(color = "white", lwd = 1.5) +
  geom_text(aes(label = label_text), color = "yellow", size = 4) +
 # Use the new color scale and add a name to create a legend.
  scale_fill_gradient2(
    low = "red", mid = "white", high = "blue",
    midpoint = 0.5,
    name = "Probability of\nincreased microbiome\ndisruption", # This title will appear on the legend
    labels = scales::percent
  ) +
  labs(x = "", y = "") + # A concise label for the single column
  theme_minimal(base_size = 14) +
  theme(
    axis.text.y = element_blank(), # Remove y-axis text to align with the forest plot
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank(),
    panel.grid = element_blank(),
    axis.text.x = element_blank() # Rotate label
  )

# --- 6. Combine the Plots ---
# The patchwork package makes combining plots as simple as adding them together.
# 'plot_layout' allows us to control the relative widths of the panels.
p_bottom_combined <- p_forest + p_heatmap +
  plot_layout(widths = c(5, 1))  # Make the forest plot 5x wider than the heatmap
  # plot_annotation(
  #   title = "Food Group Effects on Microbiome Disruption",
  #   subtitle = "Sorted by median effect across all conditions."
  # )

# Display the final combined plot
p_bottom_combined
```


```{r}
# quantify the pd of abx * sweets
posterior_draws <- as_draws_df(model_fit)

# Calculate the probability that the coefficient for 'abx * fg sweets' is positive
pd <- mean(posterior_draws$`b_empiricalTRUE:fg_sweets` > 0)

# how to understand the empirical crossing zero
# In a model with interaction terms (like yours), the "main effect" for a variable like empiric no longer represents its overall average effect. Instead, it represents the effect of antibiotics for a hypothetical patient who consumed zero grams of all food groups in your model (zero sweets, zero grains, zero milk, etc.).

#Since it's highly unlikely any patient ate absolutely nothing, this "main effect" is an estimate for an unrealistic scenario, which is why it's not very meaningful on its own and can appear non-significant.

# abx effects while having all those different types of foods......

# this compositional change, This is a measure of turnover or directional change, not just collapse. Imagine the microbiome as a point on a map. Antibiotics will definitely cause it to move, but the distance it moves might not be the same for everyone.
# This is where your interaction terms become critical. Your model is showing that the distance of the shift caused by antibiotics depends heavily on what the patient is eating. For example, antibiotics might push the microbiome 5 "units" away. But antibiotics + sweets might push it 10 "units" away.
#Because the effect of antibiotics is sliced up and distributed among all the interaction terms, the "main effect" of empiric (which represents the shift for a patient eating nothing) becomes non-significant.
```

# stool_dist viz

```{r}
p_dist_violin <- ggplot(full_data, aes(x = stool_dist, y = as.factor(empirical))) +
  # Add the jittered points first, so they are in the background.
  # 'height = 0.2' controls the vertical spread of the points.
  geom_jitter(
    #aes(color = as.factor(empirical)),
    height = 0.2,
    alpha = 0.3,
    show.legend = FALSE
  ) +
  # Overlay the boxplot. 'outlier.shape = NA' hides the default outlier points
  # because we are already showing all points with geom_jitter.
  geom_violin(
    fill = "white",
    alpha = 0.5,
    outlier.shape = NA
  ) +

  # Use a clear color scheme.
  scale_color_manual(values = c("TRUE" = "skyblue", "FALSE" = "salmon")) +
  # Add informative labels.
  labs(
    x = "Bray-Curtis Distance from Baseline",
    y = "Antibiotic Exposure"
  ) +
  # Use a clean theme for publication.
  theme_minimal(base_size = 14)


```
The above plot shows that, overall, antibiotics are associated with a greater shift from baseline. The magnitude of that shift is highly variable and is significantly influenced by diet, which is why the model assigns significance to the diet-antibiotic interactions rather than to the antibiotic term alone.

# assemble

```{r}
# --- 4. Stack All Three Plots Vertically (A, B, C) ---
# Using the '/' operator from patchwork stacks plots vertically.
# We can also control the relative heights and add tags.
final_plot <- p_dist_violin / plot_main_effects / p_bottom_combined +
  plot_layout(heights = c(1.5, 1, 4), guides = "collect") + # Adjust heights for balance
  plot_annotation(
    #title = "Full Model of Microbiome Disruption",
    tag_levels = 'A' # Automatically label plots A, B, C
  ) &
  theme(plot.tag = element_text(size = 18, face = "bold"))
# Display the final stacked plot

library(cowplot)
title <- ggdraw() + 
  draw_label("Rebuttal fig X",fontface = 'bold',x = 0,hjust = 0) +
  theme(plot.margin = margin(0, 0, 0, 3))

combined <- plot_grid(
  title, final_plot,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
) +theme(plot.margin = unit(c(1,1,1,1), "cm"))

ggsave('../data/R30_composition_model.pdf',
      width = 8.5, height = 11, units = "in", device = 'pdf', 
      dpi = 300)    
```

# using the diet dist

```{r}
library(lme4)
library(lmerTest)
# Your new linear mixed-effects model formula
dist2 <- lmer(stool_dist ~ diet_dist * empirical + intensity + TPN + EN + (1 | pid), data = full_data)
summary(dist2)
#The significant negative interaction term (-0.19) means that the relationship between diet change and microbiome disruption is weaker in patients on antibiotics (slope of +0.40) compared to those not on antibiotics (slope of +0.59). This suggests antibiotics create a "ceiling effect" on microbiome disruption.
```

# pcoa axis idea

## Identify Other "Dominators"

```{r}
asv_relab_97 <- read_csv('../data/171_quality_asv_relab_pident97_genus.csv')

# --- 1. Aggregate ASVs to Genus Level ---
# Sums up all ASVs belonging to the same genus within each sample.
# It also filters out any ASVs that couldn't be assigned a genus (NA).
genus_relab <- asv_relab_97 %>%
  filter(!is.na(genus)) %>%
  group_by(sampleid, genus) %>%
  summarize(genus_relative = sum(count_relative, na.rm = TRUE), .groups = 'drop')

# --- 2. Find the *single* most abundant genus for each sample ---
# For each sample, this finds the row with the highest relative abundance.
# 'slice_max' robustly handles this, 'with_ties = FALSE' picks one if there's a tie.
dominant_taxa <- genus_relab %>%
  group_by(sampleid) %>%
  slice_max(order_by = genus_relative, n = 1, with_ties = FALSE) %>%
  ungroup()

# --- 3. Create the 'domination_status' metadata column ---
# This is the key table: one row per sample, with the domination status.
# It checks if the top genus is > 30% relative abundance.
# If not, it's classified as 'Diverse/None'.
domination_metadata_partial <- dominant_taxa %>%
  mutate(
    domination_status = if_else(
      genus_relative > 0.30,
      as.character(genus),  # If dominant, use the genus name
      "Diverse/None"        # If not, label as diverse
    )
  ) %>%
  # Select only the columns we need for a metadata file
  select(sampleid, domination_status, top_genus_relab = genus_relative)

# --- 4. Ensure all samples are included ---
# Some samples might have been dropped (e.g., if all their ASVs were NA).
# This step joins the domination data back to a complete list of all samples.
# Any sample not in our 'domination_metadata_partial' list will be
# labeled 'Diverse/None'.

# Get all unique sample IDs from the start
all_samples <- asv_relab_97 %>%
  distinct(sampleid)

# Left-join to ensure all samples are present
sample_metadata_with_domination <- all_samples %>%
  left_join(domination_metadata_partial, by = "sampleid") %>%
  # 'replace_na' correctly labels any missing/filtered samples
  mutate(
    domination_status = replace_na(domination_status, "Diverse/None")
  )

# --- 5. Create the Domination Leaderboard ---
# This counts how many samples fall into each category.
domination_leaderboard <- sample_metadata_with_domination %>%
  count(domination_status, sort = TRUE, name = "sample_count")

# --- Display the results ---
print("--- Domination Leaderboard ---")
print(domination_leaderboard)

print("\n--- Sample Metadata with Domination Status (first 10 rows) ---")
print(head(sample_metadata_with_domination, 10))
```

```{r}
# -----------------------------------------------------------------
# --- 6. Create a "Top 10" domination status for cleaner plotting ---
# -----------------------------------------------------------------
# Get the names of the top 10 most frequent domination statuses
top_10_statuses <- domination_leaderboard %>%
  slice_head(n = 10) %>%
  pull(domination_status)

# Add a new column to the metadata that recodes rare dominators as 'Other'
sample_metadata_with_domination <- sample_metadata_with_domination %>%
  mutate(
    domination_status_limited = if_else(
      domination_status %in% top_10_statuses,
      as.character(domination_status), # Keep it if it's in the top 10
      "Other"                         # Otherwise, recode to 'Other'
    )
  )

print("\n--- New Top 10 Leaderboard ---")
print(count(sample_metadata_with_domination, domination_status_limited, sort = TRUE))
```


```{r}
# -----------------------------------------------------------------
# --- 7. Reshape Data for PCoA ---
# -----------------------------------------------------------------
# Create a "wide" data frame: samples as rows, genera as columns.
# This is the required format for vegan::vegdist.
genus_relab_wide <- genus_relab %>%
  pivot_wider(
    id_cols = sampleid,
    names_from = genus,
    values_from = genus_relative,
    values_fill = 0 # Critically, fill non-observed genera with 0
  )

# vegan needs a matrix with sample IDs as rownames, not a column
# 'column_to_rownames' is a handy way to do this
genus_matrix <- genus_relab_wide %>%
  tibble::column_to_rownames("sampleid")

# --- 8. Calculate Bray-Curtis Distance & Run PCoA ---
# Calculate the distance matrix
bray_dist <- vegdist(genus_matrix, method = "bray")

# Perform the Principal Coordinates Analysis (PCoA)
pcoa_results <- pcoa(bray_dist)

# --- 9. Format PCoA Results for Plotting ---
# Extract the PCoA scores (the coordinates for each sample)
pcoa_scores <- as.data.frame(pcoa_results$vectors)

# 'pcoa_scores' has sample IDs as rownames. Move them to a column for joining.
pcoa_scores_with_ids <- pcoa_scores %>%
  tibble::rownames_to_column("sampleid")

# Join PCoA scores with our 'domination_status' metadata
# This creates the final dataframe for plotting
plot_data <- pcoa_scores_with_ids %>%
  left_join(sample_metadata_with_domination, by = "sampleid") %>%
  # Filter out any samples that might be in metadata but not in PCoA
  # (e.g., if they had 0 reads)
  filter(!is.na(domination_status_limited))

# Calculate the percent of variance explained by the first two axes
variance_explained <- pcoa_results$values$Relative_eig[1:2] * 100

# -----------------------------------------------------------------
# --- 10. Create the (cleaner) PCoA Plot with Manual Colors ---
# -----------------------------------------------------------------

# --- 10a. Create a manual color palette ---

# Get the unique, sorted list of the top 10 statuses for consistent coloring
all_plot_statuses <- plot_data %>%
  distinct(domination_status_limited) %>%
  pull()

# Define the "special" statuses that we want to color manually
special_statuses <- c("Enterococcus", "Diverse/None", "Other")

# Get the list of the *other* genera that need colors from a palette
genera_to_color <- setdiff(all_plot_statuses, special_statuses)

# Get the "Dark2" palette. It has 8 colors, which should be enough for the
# 7 other top genera (10 total - 3 special).
# 'n' must be at least 3 for brewer.pal
n_colors_needed <- length(genera_to_color)
palette_dark2 <- brewer.pal(n = max(3, n_colors_needed), name = "Dark2")

# Assign the first N colors from the palette to our N genera
contrasting_colors <- palette_dark2[1:n_colors_needed]
names(contrasting_colors) <- genera_to_color

# Create the final named vector by combining the palette
# with our manually specified colors.
final_color_vector <- c(
  contrasting_colors,              # Colors for the other top genera
  "Enterococcus" = "red",    # Manually set to Dark Green
  "Diverse/None" = "#333333",    # Manually set to Black
  "Other" = "#999999"            # Manually set to Medium Gray
)


# --- 10b. Generate the plot ---
pcoa_plot <- ggplot(
  plot_data,
  # Set up the axes and color
  aes(
    x = Axis.1,
    y = Axis.2,
    color = domination_status_limited # Use the new "limited" column
  )
) +
  geom_point(size = 2, alpha = 0.7) +
  
  # Manually apply our new color scale
  scale_color_manual(
    values = final_color_vector,
    name = "Domination Status (Top 10)" # Updated legend title
  ) +
  
  # Add labels showing variance explained
  labs(
    title = "Bray-Curtis PCoA (Genus Level) by Domination Status",
    x = sprintf("Axis 1 (%.2f%%)", variance_explained[1]),
    y = sprintf("Axis 2 (%.2f%%)", variance_explained[2])
  ) +
  theme_bw() + # A clean, classic theme
  # Center the plot title
  theme(plot.title = element_text(hjust = 0.5)) + coord_fixed()

# Display the plot
print(pcoa_plot)
ggsave('../data/R30_pcoa_domination.pdf', width = 8, height = 8)
```

