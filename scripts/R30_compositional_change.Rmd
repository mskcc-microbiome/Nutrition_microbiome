---
title: "abx * sugar and compositonal change"
output: html_document
date: "2025-07-11"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(brms)   
library(broom.mixed)
library(tidybayes)
library(patchwork)
library(ggridges)
library(ggrepel) # For better label placement
```

Model the magnitude of compositional disruption itself. This is done by using a beta-diversity metric (like Bray-Curtis distance) from each patient's baseline sample as a continuous outcome variable. 

```{r}
joined <- read_csv('../data/R06_joined_diet_stool_distance_to_earliest.csv')

meta <- read_csv('../data/153_combined_META.csv')

# find the meta data of the following stool samples (not the earliest one)

n <- nrow(joined)

data <- joined %>% 
  inner_join(meta %>% rename(sampleid2 = sampleid), by = join_by(sampleid2, pid)) 

# how many samples from how many patients
n_samples <- data %>% distinct(sampleid2) %>% nrow
n_patients <- data %>% distinct(pid) %>% nrow

```

```{r}
full_data <- data
# Calculate counts for the full, unfiltered dataset
unfiltered_counts <- full_data %>%
  summarise(
    num_patients = n_distinct(pid),
    num_samples = n_distinct(sampleid2)
  ) %>%
  mutate(Condition = "Unfiltered")

# Calculate counts for the sdrt1 <= 0 filter
filter1_counts <- full_data %>%
  filter(sdrt1 <= 0) %>%
  summarise(
    num_patients = n_distinct(pid),
    num_samples = n_distinct(sampleid2)
  ) %>%
  mutate(Condition = "earliest sample day <= 0")

# Calculate counts for the sdrt1 <= 3 filter
filter2_counts <- full_data %>%
  filter(sdrt1 <= 3) %>%
  summarise(
    num_patients = n_distinct(pid),
    num_samples = n_distinct(sampleid2)
  ) %>%
  mutate(Condition = "earliest sample day <= 3")

# Combine the three summaries into a single dataframe
summary_df <- bind_rows(unfiltered_counts, filter1_counts, filter2_counts) %>%
  # Pivot the data into a "long" format suitable for ggplot2's grouped bar charts
  pivot_longer(
    cols = c(num_patients, num_samples),
    names_to = "Metric",
    values_to = "Count"
  ) %>%
  # Clean up the metric names for better plot labels
  mutate(
    Metric = if_else(Metric == "num_patients", "Patients", "Samples"),
    # Convert Condition to a factor to control the order on the plot
    Condition = factor(Condition, levels = c("Unfiltered", "earliest sample day <= 0", "earliest sample day <= 3"))
  )

# Finally, create the plot using ggplot2
ggplot(summary_df, aes(x = Metric, y = Count, fill = Condition)) +
  # Use geom_bar with stat="identity" because we are providing the y-values directly.
  # position="dodge" creates the side-by-side grouped bars.
  geom_bar(stat = "identity", position = "dodge") +
  # Add text labels on top of each bar for clarity.
  # position_dodge ensures the labels are correctly placed above their respective bars.
  geom_text(
    aes(label = Count),
    position = position_dodge(width = 0.9),
    vjust = -0.5, # Adjust vertical position to be just above the bar
    size = 3.5
  ) +
  # Use a nice color palette for the different conditions
  scale_fill_brewer(palette = "Pastel1") +
  # Add informative labels and a title
  labs(
    title = "Patient and Sample Counts After Filtering",
    subtitle = "Comparison of counts for different earliest sample day value thresholds",
    x = "",
    y = "Total Count",
    fill = "Filter Condition"
  ) +
  # Use a clean, minimal theme
  theme_minimal(base_size = 12) +
  # Make some final theme adjustments
  theme(
    plot.title = element_text(face = "bold", size = 16),
    legend.position = "top"
  )
```


# use all of the samples

```{r}
all_food_vars <- meta %>% select(starts_with('fg')) %>% colnames()

# Create the interaction terms for all food variables in this iteration
interaction_terms <- paste(all_food_vars, "empirical", sep = ":")

# Build the full formula string dynamically
formula_string <- paste(
  "stool_dist ~ 0 + intensity + empirical + TPN + EN +",
  paste(interaction_terms, collapse = " + "),
  "+ (1 | pid) + (1 | timebin)"
)

# Convert the string to a formula object
formula <- brms::bf(as.formula(formula_string))

# Build the priors by adding them together.
# This single prior() call applies to all coefficients listed in `all_food_coefs`.
priors <-
  prior(normal(0, 0.5), class = 'b') + # General prior for all food effects
  # Specific priors that override the general one for non-food covariates
  prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE") +
  prior(normal(0, 0.1), class = 'b', coef = "ENTRUE") +
  prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE")

# Fit the model (using fewer iterations for this example to run quickly)
model_fit <- brm(
  formula = formula,
  data = data   ,
  #prior = priors,
  #family = Beta(link = "logit"), # Use the Beta family
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  iter = 4000, warmup = 1000,
  chains = 2, cores = 10, # Adjust cores as needed
  seed = 123,
  silent = 2
)

results_df <- tidy(model_fit, conf.int = TRUE)
```
```{r}
# This pipe filters for the fixed effects and creates clean, human-readable labels.
cleaned_effects <- results_df %>%
  # Keep only the fixed effects
  filter(effect == "fixed") %>%
  # Create a new column to distinguish main effects from interactions
  mutate(
    effect_type = if_else(str_detect(term, ":"), "Interaction", "Main Effect"),
    # Create clean labels for plotting
    clean_term = term %>%
      str_remove_all("empiricalFALSE:|avg_intake_|TRUE$") %>%
      str_replace("empiricalTRUE:", "abx * ") %>%
      str_replace_all("_", " ")
  )

# Separate into two dataframes for two separate plots
main_effects_df <- cleaned_effects %>% filter(effect_type == "Main Effect")
interaction_df <- cleaned_effects %>% filter(effect_type == "Interaction") %>%
  # Create a new column to identify significant results
  # The condition is TRUE if conf.low and conf.high have the same sign (i.e., don't cross zero)
  mutate(is_significant = (conf.low * conf.high) > 0)

```

## ridgeline plot

```{r}
# We'll extract all interaction effects and create clean labels for plotting.
posterior_draws <- model_fit %>%
  gather_draws(`b_empirical.*:fg_.*`, regex = TRUE) %>%
  mutate(
    # Create a clear label for the two conditions we are comparing.
    condition = if_else(
      str_detect(.variable, "empiricalTRUE"), 
      "During Antibiotic Exposure", 
      "No Antibiotic Exposure"
    ),
    # Clean up the variable name to get just the food group.
    food_group = str_remove_all(.variable, "b_empirical(TRUE|FALSE):fg_")
  )

# --- 2. Calculate the Sorting Order ---
# We want to sort the plot based on the median effect size during antibiotic exposure.
# This calculates the order and saves it as a character vector.
sorting_order <- posterior_draws %>%
  filter(condition == "During Antibiotic Exposure") %>%
  group_by(food_group) %>%
  summarise(median_effect = median(.value)) %>%
  arrange(median_effect) %>%
  pull(food_group) # pull() extracts the single column.

# --- 3. Apply the Sorting Order ---
# Now, we apply that calculated order to our main data frame.
# We do this by converting the 'food_group' column to a factor with specific levels.
# ggplot will respect this factor order when it builds the plot.
posterior_draws_ordered <- posterior_draws %>%
  mutate(
    food_group = factor(food_group, levels = sorting_order)
  )

# Create a data frame for the POSITIVE annotations.
prob_annotations_pos <- posterior_draws_ordered %>%
  group_by(food_group, condition) %>%
  summarise(
    prob_positive = mean(.value > 0),
    .groups = 'drop'
  ) %>%
  mutate(
    label_text = paste0(scales::percent(prob_positive, accuracy = 1), " > 0"),
    x_pos = 0.004 # Fixed x position for positive labels
  )

# Create a data frame for the NEGATIVE annotations.
prob_annotations_neg <- posterior_draws_ordered %>%
  group_by(food_group, condition) %>%
  summarise(
    prob_negative = mean(.value < 0),
    .groups = 'drop'
  ) %>%
  mutate(
    label_text = paste0(scales::percent(prob_negative, accuracy = 1), "< 0 "),
    x_pos = -0.002 # Fixed x position for negative labels
  )


# --- 4. Create the Faceted Plot ---
ggplot(posterior_draws_ordered, aes(x = .value, y = food_group)) +

  # Add a faint, complete outline of the density ridge on top for context.
  geom_density_ridges(fill = NA, color = "black", size = 0.2) +
  # Add the point estimate and 95% credible interval.
  stat_pointinterval(.width = .95, size = 0.4, position = position_nudge(y = -0.1)) +
 # Add the text annotations for the POSITIVE probabilities.
  geom_text(
    data = prob_annotations_pos,
    aes(x = x_pos, label = label_text),
    size = 3.5,
    hjust = 0, # Left-align text
    nudge_y = 0.3,
    color = "blue4"
  ) +
  # Add the text annotations for the NEGATIVE probabilities.
  geom_text(
    data = prob_annotations_neg,
    aes(x = x_pos, label = label_text),
    size = 3.5,
    hjust = 1, # Right-align text
    nudge_y = 0.3,
    color = "red4"
  ) +
  # Add a vertical line at zero for reference.
  geom_vline(xintercept = 0, linetype = "dashed") +
  # This is the key to creating the two side-by-side panels.
  facet_wrap(~ condition, scales = "free_x") +
  # Manually set the colors for our positive/negative fills.
  scale_fill_manual(
    name = "Effect Direction",
    values = c("Positive" = "skyblue", "Negative" = "salmon")
  ) +
  # Add informative labels and a clean theme.
  labs(
    title = "Food Group Effects on Microbiome Disruption",
    subtitle = "Sorted by median effect during antibiotic exposure. Annotations show probability of a positive effect.",
    x = "Coefficient Estimate (Change in Bray-Curtis Distance)",
    y = "Food Group"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 12),
    panel.spacing = unit(2, "lines")
  )

ggsave('../data/R30_ridgeline_panels.jpg', width = 12, height = 15)
```


```{r}
# quantify the pd of abx * sweets
posterior_draws <- as_draws_df(model_fit)

# Calculate the probability that the coefficient for 'abx * fg sweets' is positive
pd <- mean(posterior_draws$`b_empiricalTRUE:fg_sweets` > 0)

# how to understand the empirical crossing zero
# In a model with interaction terms (like yours), the "main effect" for a variable like empiric no longer represents its overall average effect. Instead, it represents the effect of antibiotics for a hypothetical patient who consumed zero grams of all food groups in your model (zero sweets, zero grains, zero milk, etc.).

#Since it's highly unlikely any patient ate absolutely nothing, this "main effect" is an estimate for an unrealistic scenario, which is why it's not very meaningful on its own and can appear non-significant.

# abx effects while having all those different types of foods......

# this compositional change, This is a measure of turnover or directional change, not just collapse. Imagine the microbiome as a point on a map. Antibiotics will definitely cause it to move, but the distance it moves might not be the same for everyone.
# This is where your interaction terms become critical. Your model is showing that the distance of the shift caused by antibiotics depends heavily on what the patient is eating. For example, antibiotics might push the microbiome 5 "units" away. But antibiotics + sweets might push it 10 "units" away.
#Because the effect of antibiotics is sliced up and distributed among all the interaction terms, the "main effect" of empiric (which represents the shift for a patient eating nothing) becomes non-significant.
```

# stool_dist viz

```{r}
library(gghalves) # For creating the raincloud plot effect

ggplot(full_data, aes(x = empirical, y = stool_dist, fill = empirical)) +
  # Add the 'rain' - the individual data points (jittered)
  geom_half_point(
    side = "l", # Show points on the left
    aes(color = empirical),
    shape = 16,
    size = 1.5,
    alpha = 0.4
  ) +
  # Add the 'cloud' - the density distribution
  geom_half_violin(
    side = "r", # Show the density plot on the right
    nudge = 0.05,
    trim = FALSE,
    alpha = 0.7
  ) +
  # Add the boxplot in the middle
  geom_boxplot(
    width = 0.15,
    outlier.shape = NA, # Hide outliers since we are plotting all points
    alpha = 0.7
  ) +
  # Flip the coordinates for better readability
  coord_flip() +
  # Add a statistical comparison of the means (Wilcoxon test)
  ggpubr::stat_compare_means(
    method = "wilcox.test",
    label = "p.signif",
    label.x = 1.5,
    label.y = 1.4
  ) +
  # Customize colors and remove legends that are not needed
  scale_color_manual(values = c("Exposed" = "#D55E00", "Not Exposed" = "#0072B2"), guide = "none") +
  scale_fill_manual(values = c("Exposed" = "#D55E00", "Not Exposed" = "#0072B2"), guide = "none") +
  # Add informative labels and a title
  labs(
    title = "Variability in Microbiome Disruption by Antibiotic Exposure",
    subtitle = "The spread of distances from baseline is larger in antibiotic-exposed samples",
    x = "",
    y = "Bray-Curtis Distance from Baseline"
  ) +
  # Use a clean theme
  theme_minimal(base_size = 12) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    panel.grid.major.y = element_blank(), # Clean up the background
    panel.grid.minor.y = element_blank()
  )
```
The above plot shows that, overall, antibiotics are associated with a greater shift from baseline. The magnitude of that shift is highly variable and is significantly influenced by diet, which is why the model assigns significance to the diet-antibiotic interactions rather than to the antibiotic term alone.

# using the diet dist

```{r}
library(lme4)
library(lmerTest)
# Your new linear mixed-effects model formula
dist2 <- lmer(stool_dist ~ diet_dist * empirical + intensity + TPN + EN + (1 | pid), data = full_data)
summary(dist2)
#The significant negative interaction term (-0.19) means that the relationship between diet change and microbiome disruption is weaker in patients on antibiotics (slope of +0.40) compared to those not on antibiotics (slope of +0.59). This suggests antibiotics create a "ceiling effect" on microbiome disruption.
```

