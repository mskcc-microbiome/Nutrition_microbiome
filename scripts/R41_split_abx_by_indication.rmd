---
title: "Stratifying broad spectrum abx by indication"
output: html_document
date: "2025-09-22"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(cowplot)
library(broom.mixed)
library(brms)   
library(ggpubr)
library(tidybayes)
library(brmstools)
library(bayesplot)
library(ggtext)
rstan::rstan_options(auto_write = TRUE)
theme_set(theme_tidybayes() + panel_border())
ncores <- parallel::detectCores()
```

```{r}
annotated_df <- read_rds('../data/meds_annotated_2025-09-20.rds') %>% select(-mrn, -drug_category_for_this_study)

stool_samples_df <- read_csv('../data/153_combined_META.csv') %>% select(pid, sdrt, sampleid)
```
```{r}
# This chain of operations checks each stool sample to see if there was an
# exposure to *any* drug category in the two days prior to collection.

# First, determine all actual exposure events.
all_exposures <- stool_samples_df %>%
  # Join every sample with every drug the corresponding patient ever received.
  left_join(annotated_df, by = "pid") %>%
  # Figure out if the drug administration period overlaps with the two-day window before the sample.
  # The `!is.na(drug_category_2)` handles samples from patients who never had any drugs.
  mutate(
    is_exposed = !is.na(drug_category_2) & (startday <= sdrt - 1 & stopday >= sdrt - 2)
  ) %>%
  # Keep only the rows that represent a true exposure event.
  filter(is_exposed) %>%
  # Select the essential columns and ensure each sample/category pair is unique.
  distinct(pid, sdrt, sampleid, drug_category_2) %>%
  # Add a helper column that will become the TRUE values in our final wide table.
  mutate(had_exposure = TRUE)

# Now, reshape the data from a long format to a wide format.
# This creates a separate column for each drug category.
exposure_wide_df <- all_exposures %>%
  pivot_wider(
    id_cols = c(pid, sdrt, sampleid), # These columns will be the unique identifiers for rows.
    names_from = drug_category_2,      # The values from this column will become the new column names.
    values_from = had_exposure         # The values from this column will fill the new category columns.
  )

# Finally, join the wide exposure data back to the original full list of samples.
# This ensures that samples with no exposures are still included in the final result.
final_exposure_summary <- stool_samples_df %>%
  left_join(exposure_wide_df, by = c("pid", "sdrt", "sampleid")) %>%
  # For any drug category a sample was not exposed to, the value will be NA after the join.
  # Replace all these NAs with FALSE to make the table clean and easy to read.
  mutate(across(where(is.logical), ~replace_na(., FALSE)))

# Print the final results to the console.
print(final_exposure_summary)


# --- Tally Exposures ---
# This section calculates how many samples were exposed to 0, 1, 2, or more
# drug categories concurrently.
exposure_tally <- final_exposure_summary %>%
  # For each row, calculate the total number of TRUE values across the exposure columns.
  # This gives the count of concurrent exposures for that specific sample.
  mutate(
    exposure_count = rowSums(across(where(is.logical)))
  ) %>%
  # Group by the exposure count and tally how many samples fall into each group.
  count(exposure_count, name = "number_of_samples")

# Print the tally to the console.
print(exposure_tally)
```
```{r}
# --- Analyze Concurrent Exposures ---
# This section identifies the specific combination of exposures for samples
# that were exposed to exactly two categories.
samples_with_two_exposures <- final_exposure_summary %>%
  # Calculate the number of exposures for each sample.
  mutate(
    exposure_count = rowSums(across(where(is.logical)))
  ) %>%
  # Filter to keep only those samples with exactly two exposures.
  filter(exposure_count == 2) %>%
  # Reshape the data from wide to long format to make it easier to work with.
  pivot_longer(
    cols = -c(pid, sdrt, sampleid, exposure_count), # Pivot all columns except the identifiers.
    names_to = "drug_category",
    values_to = "is_exposed"
  ) %>%
  # Keep only the rows that represent an actual exposure.
  filter(is_exposed) %>%
  # Group by each unique sample.
  group_by(pid, sdrt, sampleid) %>%
  # Combine the names of the two drug categories into a single string.
  summarise(
    exposure_combination = paste(drug_category, collapse = " & "),
    .groups = "drop" # Ungroup after summarizing.
  )

# Print the list of samples with two exposures and their specific combination.
print(samples_with_two_exposures)

samples_with_two_exposures %>% count(exposure_combination)
```

```{r}
# --- Stratify Exposures Based on Clinical Hierarchy ---
# This section addresses the reviewer's comment by creating a single, stratified
# exposure category for each sample based on a clinical hierarchy.
# This simplifies downstream analysis and accounts for infection-related indications.
stratified_exposure <- final_exposure_summary %>%
  mutate(
    # The case_when() function allows for assigning a value based on a series of conditions.
    # It works like a sequence of if-else statements.
    exposure_type = case_when(
      # Highest priority: If there's an exposure for a bloodstream infection, classify it as such.
      #If a sample has bsi_treatment and cdiff_treatment (less common, but possible),  For now, we can prioritize BSI as it's a systemic infection.
      `broad_spectrum_bsi_treatment` == TRUE ~ "bsi_treatment",
      
      # Next priority: If there's an exposure for a C. diff infection.
      `broad_spectrum_cdiff_treatment` == TRUE ~ "cdiff_treatment",
      
      # Next priority: If there's an empiric exposure (and no BSI or C. diff).
      `broad_spectrum_empiric` == TRUE ~ "empiric",
      
      # Default case: If none of the above are true, the sample is unexposed.
      TRUE ~ "no_broad_spectrum_exposure"
    )
  ) %>%
  # Select the key identifier columns and the new stratified exposure column.
  select(pid, sdrt, sampleid, exposure_type)

# Tally the number of samples and unique patients in each new, stratified category.
stratified_tally_detailed <- stratified_exposure %>%
  group_by(exposure_type) %>%
  summarise(
    number_of_samples = n(),
    number_of_patients = n_distinct(pid),
    .groups = "drop"
  )

stratified_tally_detailed
```
# remove the bsi_treatment and cdiff_treatment exposed samples and do the model

```{r}
meta <- read_csv('../data/153_combined_META.csv') %>% 
  mutate(intensity = factor(intensity, levels = c('nonablative','reduced','ablative'))) %>%
  mutate(pid = factor(pid)) %>%
    # This divides all the new intake columns by 100.
  mutate(across(starts_with("fg_"), ~ .x / 100)) %>% 
  inner_join(stratified_exposure %>% filter(exposure_type %in% c('empiric','no_broad_spectrum_exposure')) %>% select(sampleid, exposure_type)) %>% 
  mutate(exposure_type = factor(exposure_type, levels = c('no_broad_spectrum_exposure','empiric'))) %>% 
  mutate(timebin = cut_width(sdrt, 7, boundary=0, closed = 'left')) 
```


```{r}
# Get all food group variable names
all_food_vars <- meta %>% select(starts_with('fg')) %>% colnames()

# Create the interaction terms with the new 'exposure_type' variable
interaction_terms <- paste(all_food_vars, "exposure_type", sep = ":")

# Build the full formula string dynamically
# Replaced 'empirical' with 'exposure_type'
formula_string <- paste(
  "log(simpson_reciprocal) ~ 0 + intensity + exposure_type + TPN + EN +",
  paste(interaction_terms, collapse = " + "),
  "+ (1 | pid) + (1 | timebin)"
)

# Convert the string to a formula object
formula <- brms::bf(as.formula(formula_string))

# Build the priors.
# Note the change in the coefficient name for the antibiotic effect from
# "empiricalTRUE" to "exposure_typeempiric". brms creates this name by
# combining the variable name ('exposure_type') and the non-reference level ('empiric').
priors <-
    prior(normal(0, 1), class = 'b') + # General prior for all food effects
    # Specific priors that override the general one for non-food covariates
    prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE") +
    prior(normal(0, 0.1), class = 'b', coef = "ENTRUE") +
    prior(normal(0, 0.5), class = 'b', coef = "exposure_typeempiric") +
    prior(normal(2, .1), class = 'b', coef = "intensityablative") +
    prior(normal(2, .1), class = 'b', coef = "intensityreduced") +
    prior(normal(2, .1), class = 'b', coef = "intensitynonablative")

# Fit the model
model_fit <- brm(
  formula = formula,
  data = meta,
  prior = priors,
  warmup = 1000, iter = 3000,
  chains = 2, cores = ncores,
  seed = 123,
  silent = 2,
  control = list(adapt_delta = 0.99)
)

results_df <- tidy(model_fit, conf.int = TRUE) %>% 
  mutate(conf.low = round(conf.low, 2),
         conf.high = round(conf.high, 2))
```
## forest figure

```{r}
# the above figure but make it the way the other figure look like 
key <- read_csv('../data/food_group_color_key_final.csv', col_types = 'ccccc')

replacement_dictionary <- setNames(key$shortname, key$fg1_name)

level_order <- rev(c(
    "empiric only", "EN", "TPN",
    "empiric only * Sweets", "Sweets",
    "empiric only * Grains", "Grains",
    "empiric only * Milk", "Milk",
    "empiric only * Eggs", "Eggs",
    "empiric only * Legumes", "Legumes",
    "empiric only * Meats", "Meats",
    "empiric only * Fruits", "Fruits",
    "empiric only * Oils", "Oils",
    "empiric only * Vegetables", "Vegetables"
))

cleaned_effects <- results_df %>%
  # Keep only the fixed effects
  filter(effect == "fixed") %>%
  # Create a new column to distinguish main effects from interactions
  mutate(
    effect_type = if_else(str_detect(term, ":"), "Interaction", "Main Effect"),
    # Create clean labels for plotting
    clean_term = term %>%
      str_replace("exposure_typeempiric$", "empiric_only") %>%
      str_remove_all("exposure_typeno_broad_spectrum_exposure:|avg_intake_|TRUE$") %>%
      str_replace_all( replacement_dictionary) %>% 
      str_replace("exposure_typeempiric:", "empiric_only * ") %>%
      str_replace_all("_", " ")
  ) %>% 
  filter(!str_detect(clean_term, 'intensity')) %>%
  # Create a new column to identify significant results
  # The condition is TRUE if conf.low and conf.high have the same sign (i.e., don't cross zero)
  mutate(is_significant = (conf.low * conf.high) >= 0) %>% 
  mutate(clean_term = factor(clean_term, levels = level_order))

shading_df <- cleaned_effects %>%
  mutate(y_numeric = as.numeric(clean_term)) %>%
  filter(str_detect(clean_term, "\\*")) # Filter for interaction terms

plot_stratify <- ggplot(cleaned_effects, aes(x = estimate, y = clean_term)) +
  geom_rect(
    data = shading_df,
    aes(ymin = y_numeric - 0.5, ymax = y_numeric + 0.5, xmin = -Inf, xmax = Inf),
    fill = "#FBEADC", # A light orange/peach color like the example
    alpha = 0.7,
    inherit.aes = FALSE
   ) +
   # Add a vertical line at zero, which represents "no effect"
  geom_vline(xintercept = 0, linetype = "solid", color = "blue",size = 0.8) +
   # Use geom_pointrange to show the estimate (point) and confidence interval (line)
   geom_pointrange(
   aes(xmin = conf.low, xmax = conf.high, color = is_significant),
     size = 0.25,linewidth = 1,
  ) +
  scale_color_manual(
    values = c(
      "TRUE" = "red",
      "FALSE" = "black"
    ), name = "Effect Status" # Legend title
  ) +
  scale_y_discrete( labels = function(x) { ifelse(str_detect(x, '\\*'),  str_glue("<b style='color:royalblue'>{x}</b>"), as.character(x)) }) +
  # Add labels and a clean theme
  labs(
    x = "ln(diversity) change",
    title = "Predictor effects on diversity,\nexcluding samples exposed to C. diff and BSI treatment",
    y = ''
  ) +
  theme_classic(base_size = 11) +
  theme(legend.position = "none", axis.text.y = element_markdown())
  
plot_stratify  
```
