---
title: "Stratifying broad spectrum abx by indication"
output: html_document
date: "2025-09-22"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(cowplot)
library(broom.mixed)
library(brms)   
library(ggpubr)
library(tidybayes)
library(brmstools)
library(bayesplot)
library(gt)
library(ggtext)
rstan::rstan_options(auto_write = TRUE)
theme_set(theme_tidybayes() + panel_border())
ncores <- parallel::detectCores()
```

```{r}
annotated_df <- read_rds('../data/meds_annotated_2025-09-20.rds') %>% select(-mrn, -drug_category_for_this_study)

stool_samples_df <- read_csv('../data/153_combined_META.csv') %>% select(pid, sdrt, sampleid)
```
```{r}
# This chain of operations checks each stool sample to see if there was an
# exposure to *any* drug category in the two days prior to collection.

# First, determine all actual exposure events.
all_exposures <- stool_samples_df %>%
  # Join every sample with every drug the corresponding patient ever received.
  left_join(annotated_df, by = "pid") %>%
  # Figure out if the drug administration period overlaps with the two-day window before the sample.
  # The `!is.na(drug_category_2)` handles samples from patients who never had any drugs.
  mutate(
    is_exposed = !is.na(drug_category_2) & (startday <= sdrt - 1 & stopday >= sdrt - 2)
  ) %>%
  # Keep only the rows that represent a true exposure event.
  filter(is_exposed) %>%
  # Select the essential columns and ensure each sample/category pair is unique.
  distinct(pid, sdrt, sampleid, drug_category_2) %>%
  # Add a helper column that will become the TRUE values in our final wide table.
  mutate(had_exposure = TRUE)

# Now, reshape the data from a long format to a wide format.
# This creates a separate column for each drug category.
exposure_wide_df <- all_exposures %>%
  pivot_wider(
    id_cols = c(pid, sdrt, sampleid), # These columns will be the unique identifiers for rows.
    names_from = drug_category_2,      # The values from this column will become the new column names.
    values_from = had_exposure         # The values from this column will fill the new category columns.
  )

# Finally, join the wide exposure data back to the original full list of samples.
# This ensures that samples with no exposures are still included in the final result.
final_exposure_summary <- stool_samples_df %>%
  left_join(exposure_wide_df, by = c("pid", "sdrt", "sampleid")) %>%
  # For any drug category a sample was not exposed to, the value will be NA after the join.
  # Replace all these NAs with FALSE to make the table clean and easy to read.
  mutate(across(where(is.logical), ~replace_na(., FALSE)))

# Print the final results to the console.
print(final_exposure_summary)


# --- Tally Exposures ---
# This section calculates how many samples were exposed to 0, 1, 2, or more
# drug categories concurrently.
exposure_tally <- final_exposure_summary %>%
  # For each row, calculate the total number of TRUE values across the exposure columns.
  # This gives the count of concurrent exposures for that specific sample.
  mutate(
    exposure_count = rowSums(across(where(is.logical)))
  ) %>%
  # Group by the exposure count and tally how many samples fall into each group.
  count(exposure_count, name = "number_of_samples")

# Print the tally to the console.
print(exposure_tally)
```
```{r}
# --- Analyze Concurrent Exposures ---
# This section identifies the specific combination of exposures for samples
# that were exposed to exactly two categories.
samples_with_two_exposures <- final_exposure_summary %>%
  # Calculate the number of exposures for each sample.
  mutate(
    exposure_count = rowSums(across(where(is.logical)))
  ) %>%
  # Filter to keep only those samples with exactly two exposures.
  filter(exposure_count == 2) %>%
  # Reshape the data from wide to long format to make it easier to work with.
  pivot_longer(
    cols = -c(pid, sdrt, sampleid, exposure_count), # Pivot all columns except the identifiers.
    names_to = "drug_category",
    values_to = "is_exposed"
  ) %>%
  # Keep only the rows that represent an actual exposure.
  filter(is_exposed) %>%
  # Group by each unique sample.
  group_by(pid, sdrt, sampleid) %>%
  # Combine the names of the two drug categories into a single string.
  summarise(
    exposure_combination = paste(drug_category, collapse = " & "),
    .groups = "drop" # Ungroup after summarizing.
  )

# Print the list of samples with two exposures and their specific combination.
print(samples_with_two_exposures)

samples_with_two_exposures %>% count(exposure_combination)
```

```{r}
# --- Stratify Exposures Based on Clinical Hierarchy ---
# This section addresses the reviewer's comment by creating a single, stratified
# exposure category for each sample based on a clinical hierarchy.
# This simplifies downstream analysis and accounts for infection-related indications.
stratified_exposure <- final_exposure_summary %>%
  mutate(
    # The case_when() function allows for assigning a value based on a series of conditions.
    # It works like a sequence of if-else statements.
    exposure_type = case_when(
      # Highest priority: If there's an exposure for a bloodstream infection, classify it as such.
      #If a sample has bsi_treatment and cdiff_treatment (less common, but possible),  For now, we can prioritize BSI as it's a systemic infection.
      `broad_spectrum_bsi_treatment` == TRUE ~ "bsi_treatment",
      
      # Next priority: If there's an exposure for a C. diff infection.
      `broad_spectrum_cdiff_treatment` == TRUE ~ "cdiff_treatment",
      
      # Next priority: If there's an empiric exposure (and no BSI or C. diff).
      `broad_spectrum_empiric` == TRUE ~ "empiric",
      
      # Default case: If none of the above are true, the sample is unexposed.
      TRUE ~ "no_broad_spectrum_exposure"
    )
  ) %>%
  # Select the key identifier columns and the new stratified exposure column.
  select(pid, sdrt, sampleid, exposure_type)

# Tally the number of samples and unique patients in each new, stratified category.
stratified_tally_detailed <- stratified_exposure %>%
  group_by(exposure_type) %>%
  summarise(
    number_of_samples = n(),
    number_of_patients = n_distinct(pid),
    .groups = "drop"
  )

stratified_tally_detailed
```
## tally two abx categories

```{r}
# Filter for the relevant exposure types and make the names more presentable for the table.
table_data <- stratified_tally_detailed %>%
  mutate(exposure_type = case_when(
    exposure_type == "empiric" ~ "Empiric only",
    exposure_type == "no_broad_spectrum_exposure" ~ "No broad-spectrum exposure",
    exposure_type == "bsi_treatment" ~ "BSI treatment",
    exposure_type == "cdiff_treatment" ~ "C. diff treatment"
    # Reorder the levels for the table display
  )) %>%
  mutate(exposure_type = factor(exposure_type, levels = c("Empiric only", "No broad-spectrum exposure",'C. diff treatment','BSI treatment'))) %>%
  arrange(exposure_type)

# Calculate totals for the filtered data to compute percentages.
total_samples <- sum(stratified_tally_detailed$number_of_samples)
total_patients <- sum(stratified_tally_detailed$number_of_patients)

# Create new columns that combine the count and the calculated percentage.
table_data_with_pct <- table_data %>%
  mutate(
    samples_display = sprintf("%d (%.1f%%)", number_of_samples, (number_of_samples / total_samples) * 100),
    patients_display = sprintf("%d (%.1f%%)", number_of_patients, (number_of_patients / total_patients) * 100)
  )


# --- Table Creation and Styling ---
# Use the gt package to build and format the table from the prepared data.
exposure_table_tally <- table_data_with_pct %>%
  # Select only the columns needed for the final table.
  select(exposure_type, samples_display, patients_display) %>%
  gt() %>%
  # Add a main title to the table.
  # tab_header(
  #   title = md("**Antibiotic Exposure Summary**"),
  #   subtitle = "Samples and patients in the empiric vs. no-exposure groups"
  # ) %>%
  # Apply the light pink fill to the entire row for 'Empiric only'.
  tab_style(
    style = cell_text(color = "gray20"),
    locations = cells_body(
      rows = exposure_type == "Empiric only"
    )
  ) %>%
  # Apply the light gray fill to the entire row for 'No broad-spectrum exposure'.
  tab_style(
    style = cell_text(color = "gray20"),
    locations = cells_body(
      rows = exposure_type == "No broad-spectrum exposure"
    )
  ) %>%
  # Make the column headers more descriptive.
  cols_label(
    exposure_type = "Exposure Type",
    samples_display = "Number of Samples",
    patients_display = "Number of Patients"
  ) %>%
  # Center the numeric values for better readability.
  cols_align(
    align = "center",
    columns = c(samples_display, patients_display)
  ) %>%
    # Style the column headers to be bold.
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels(columns = everything())
  ) %>%
  # Add some final styling options for a polished look.
  opt_table_font(font = "sans-serif") %>%
  opt_table_outline() %>% 
  gt::gtsave(filename = "../data/R41_number_tally.png") 
```

# remove the bsi_treatment and cdiff_treatment exposed samples and do the model

```{r}
meta <- read_csv('../data/153_combined_META.csv') %>% 
  mutate(intensity = factor(intensity, levels = c('nonablative','reduced','ablative'))) %>%
  mutate(pid = factor(pid)) %>%
    # This divides all the new intake columns by 100.
  mutate(across(starts_with("fg_"), ~ .x / 100)) %>% 
  inner_join(stratified_exposure %>% filter(exposure_type %in% c('empiric','no_broad_spectrum_exposure')) %>% select(sampleid, exposure_type)) %>% 
  mutate(exposure_type = factor(exposure_type, levels = c('no_broad_spectrum_exposure','empiric'))) %>% 
  mutate(timebin = cut_width(sdrt, 7, boundary=0, closed = 'left')) 
```


```{r}
# Get all food group variable names
all_food_vars <- meta %>% select(starts_with('fg')) %>% colnames()

# Create the interaction terms with the new 'exposure_type' variable
interaction_terms <- paste(all_food_vars, "exposure_type", sep = ":")

# Build the full formula string dynamically
# Replaced 'empirical' with 'exposure_type'
formula_string <- paste(
  "log(simpson_reciprocal) ~ 0 + intensity + exposure_type + TPN + EN +",
  paste(interaction_terms, collapse = " + "),
  "+ (1 | pid) + (1 | timebin)"
)

# Convert the string to a formula object
formula <- brms::bf(as.formula(formula_string))

# Build the priors.
# Note the change in the coefficient name for the antibiotic effect from
# "empiricalTRUE" to "exposure_typeempiric". brms creates this name by
# combining the variable name ('exposure_type') and the non-reference level ('empiric').
priors <-
    prior(normal(0, 1), class = 'b') + # General prior for all food effects
    # Specific priors that override the general one for non-food covariates
    prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE") +
    prior(normal(0, 0.1), class = 'b', coef = "ENTRUE") +
    prior(normal(0, 0.5), class = 'b', coef = "exposure_typeempiric") +
    prior(normal(2, .1), class = 'b', coef = "intensityablative") +
    prior(normal(2, .1), class = 'b', coef = "intensityreduced") +
    prior(normal(2, .1), class = 'b', coef = "intensitynonablative")

# Fit the model
model_fit <- brm(
  formula = formula,
  data = meta,
  prior = priors,
  warmup = 1000, iter = 3000,
  chains = 2, cores = ncores,
  seed = 123,
  silent = 2,
  control = list(adapt_delta = 0.99)
)

results_df <- tidy(model_fit, conf.int = TRUE) %>% 
  mutate(conf.low = round(conf.low, 2),
         conf.high = round(conf.high, 2))
```
## forest figure

```{r}
# the above figure but make it the way the other figure look like 
key <- read_csv('../data/food_group_color_key_final.csv', col_types = 'ccccc')

replacement_dictionary <- setNames(key$shortname, key$fg1_name)

level_order <- rev(c(
    "empiric only", "EN", "TPN",
    "empiric only * Sweets", "Sweets",
    "empiric only * Grains", "Grains",
    "empiric only * Milk", "Milk",
    "empiric only * Eggs", "Eggs",
    "empiric only * Legumes", "Legumes",
    "empiric only * Meats", "Meats",
    "empiric only * Fruits", "Fruits",
    "empiric only * Oils", "Oils",
    "empiric only * Vegetables", "Vegetables"
))

cleaned_effects <- results_df %>%
  # Keep only the fixed effects
  filter(effect == "fixed") %>%
  # Create a new column to distinguish main effects from interactions
  mutate(
    effect_type = if_else(str_detect(term, ":"), "Interaction", "Main Effect"),
    # Create clean labels for plotting
    clean_term = term %>%
      str_replace("exposure_typeempiric$", "empiric_only") %>%
      str_remove_all("exposure_typeno_broad_spectrum_exposure:|avg_intake_|TRUE$") %>%
      str_replace_all( replacement_dictionary) %>% 
      str_replace("exposure_typeempiric:", "empiric_only * ") %>%
      str_replace_all("_", " ")
  ) %>% 
  filter(!str_detect(clean_term, 'intensity')) %>%
  # Create a new column to identify significant results
  # The condition is TRUE if conf.low and conf.high have the same sign (i.e., don't cross zero)
  mutate(is_significant = (conf.low * conf.high) >= 0) %>% 
  mutate(clean_term = factor(clean_term, levels = level_order))

shading_df <- cleaned_effects %>%
  mutate(y_numeric = as.numeric(clean_term)) %>%
  filter(str_detect(clean_term, "\\*")) # Filter for interaction terms

plot_stratify <- ggplot(cleaned_effects, aes(x = estimate, y = clean_term)) +
  geom_rect(
    data = shading_df,
    aes(ymin = y_numeric - 0.5, ymax = y_numeric + 0.5, xmin = -Inf, xmax = Inf),
    fill = "#FBEADC", # A light orange/peach color like the example
    alpha = 0.7,
    inherit.aes = FALSE
   ) +
   # Add a vertical line at zero, which represents "no effect"
  geom_vline(xintercept = 0, linetype = "solid", color = "blue",size = 0.8) +
   # Use geom_pointrange to show the estimate (point) and confidence interval (line)
   geom_pointrange(
   aes(xmin = conf.low, xmax = conf.high, color = is_significant),
     size = 0.25,linewidth = 1,
  ) +
  scale_color_manual(
    values = c(
      "TRUE" = "red",
      "FALSE" = "black"
    ), name = "Effect Status" # Legend title
  ) +
  scale_y_discrete( labels = function(x) { ifelse(str_detect(x, '\\*'),  str_glue("<b style='color:royalblue'>{x}</b>"), as.character(x)) }) +
  # Add labels and a clean theme
  labs(
    x = "ln(diversity) change",
    title = "Predictor effects on diversity,\nexcluding samples exposed to C. diff and BSI treatment",
    y = ''
  ) +
  theme_classic(base_size = 11) +
  theme(legend.position = "none", axis.text.y = element_markdown())
  
plot_stratify  
```
## sweets_raw of the included samples 

```{r}
sweets_raw <- meta %>% 
  mutate(log_div = log(simpson_reciprocal)) %>% 
  ggscatter(x = 'fg_sweets', y = 'log_div', color = 'exposure_type',
            ylab = 'log(diversity)',xlab = 'Sweets consumed (grams)',
            alpha = 0.35, shape = 16, size = 1,
            add = "reg.line",  # Add regressin line
           add.params = list(color = 'exposure_type', fill = 'exposure_type', alpha = 0.3, size = 1.5), # Customize line
           conf.int = TRUE, # Add confidence interval
           cor.coef = TRUE, # Add correlation coefficient.
           cor.coeff.args = list(method = "spearman",  label.sep = "\n", cor.coef.name = c("rho"),p.accuracy = 0.01, r.accuracy = 0.01,label.x.npc = .7, label.y.npc = "bottom", size = 3.5)) +
  scale_x_sqrt() +
  scale_y_sqrt() +
  scale_fill_manual('antibiotics', values = c('gray20','maroon'), labels=c('No broad-spectrum abx exposure', 'Empiric only')) +
  scale_colour_manual('antibiotics',values = c('gray20','maroon'), labels=c('No broad-spectrum abx exposure', 'Empiric only')) +
  facet_wrap(~ exposure_type, labeller = 'label_both', dir = 'h') +
  theme(aspect.ratio = 1/1.15, 
        legend.position = 'top',
         strip.background = element_blank(),
        strip.text.x = element_blank(), 
     axis.text=element_text(size=9), axis.title=element_text(size=9)) 

sweets_raw
```


## assemble 

```{r}
table_tally <- ggdraw() + draw_image("../data/R41_number_tally.png", scale = 1.2)


final_plot <- plot_grid( table_tally ,  plot_stratify , 
                nrow  =2,
                 rel_heights = c(.9,2),
                labels = 'auto',
                align = 'vh', axis = 'lrtb')


title <- ggdraw() + 
  draw_label("Rebuttal Fig X",fontface = 'bold', x = 0,hjust = 0) +
  theme(plot.margin = margin(0, 0, 0, 0))

combined <- plot_grid(
  title, final_plot,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
) +theme(plot.margin = unit(c(1,6,3,1), "cm"))

ggsave('../data/R41_remove_2_abx_stratification.pdf',
      width = 8.5, height = 11, units = "in", device = 'pdf', 
      dpi = 300)       
```

