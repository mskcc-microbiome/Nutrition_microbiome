---
title: "Macronutrients with diversity or genus"
output: html_document  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Previous 2 day results** 

```{r}
library(tidyverse)
library(ggpubr)
library(tidybayes)  
library(brms)
library(rstan)
library(cowplot)
library(rmcorr)      # For the repeated-measures correlation
library(corrplot) 
library(broom.mixed)
library(tidybayes)
library(brmstools)
library(bayesplot)
library(gt)
library(ggtext)
options(mc.cores = parallel::detectCores())
ncores = parallel::detectCores()
rstan_options(auto_write = TRUE)
axis_text_size <- 10
axis_title_size <- 10
```

# alpha diversity and macronutrients (fat) model

```{r}
clr_res <- read_csv('../data/171_genus_CLR_res.csv')

clr_wide <- clr_res %>% 
  spread('genus','clr')
```


```{r}
# to change the df a little bit 
# the ave_XXX value were already divided by 100
full <- read_csv('../data/090_all_samples1009_meta_p2d_fg9_dietall_genera90_pid.csv') %>% 
  mutate(abx = if_else(empirical == 'TRUE', 1, 0),
         TPN = if_else(TPN == 'TRUE', 1, 0),
         EN = if_else(EN == 'TRUE', 1, 0)) %>% 
  mutate(intensity = factor(intensity, levels = c('nonablative','reduced','ablative'))) %>%
  mutate(      ave_fiber_e= ave_fiber*abx,
               ave_carb_e = ave_carb*abx,
               ave_Protein_e= ave_Protein*abx,
                ave_fat_e=ave_fat*abx,
                ave_Sugars_e=ave_Sugars*abx) %>% 
  select(sampleid:ave_carb, intensityAblative:ave_Sugars_e) %>% 
  full_join(clr_wide)
```


```{r}
alpha_macro_fat <- log(simpson_reciprocal) ~ 0 +
                ave_fiber_e +
                ave_fat_e +
                ave_Sugars_e +
                ave_fiber +
                ave_fat +
                ave_Sugars +
               abx+
               intensity +
                TPN+
                EN+
               (1 | pid) +
                (1 | timebin)
get_prior(formula = alpha_macro_fat, data = full)

priors_alpha_macro_fat <- c(
            # for the macro nutrients
            prior(normal(0, 1), class = 'b', coef = "ave_fiber"),
            prior(normal(0, 1), class = 'b', coef = "ave_fat"),
            prior(normal(0, 1), class = 'b', coef = "ave_Sugars"),
            # for the interaction terms
            prior(normal(0, 1), class = 'b', coef = "ave_fiber_e"),
            prior(normal(0, 1), class = 'b', coef = "ave_fat_e"),
            prior(normal(0, 1), class = 'b', coef = "ave_Sugars_e"),
            # for the TPN 
            prior(normal(0, 0.1), class = 'b', coef = "TPN"),
            # for the EN
            prior(normal(0, 0.1), class = 'b', coef = "EN"),
            # for the empirical 
            prior(normal(0, 0.5), class = 'b', coef = "abx"),
            # for the intensity 
            prior(normal(2, .1), class = 'b', coef = "intensityablative"),
            prior(normal(2, .1), class = 'b', coef = "intensityreduced"),
            prior(normal(2, .1), class = 'b', coef = "intensitynonablative"))

# vet the prior 
model_alpha_macro_fat  <- brm( alpha_macro_fat,  
              data = full, 
              warmup = 1000, iter = 3000, 
              prior = priors_alpha_macro_fat,
               control = list(adapt_delta = 0.99),
              cores = ncores,
              chains = 2, 
              seed = 125, sample_prior = T)


post_res <- suppressWarnings(posterior_samples(model_alpha_macro_fat))
post_res %>%  write_csv('../results/090_model_alpha_macro_fat_post_interaction.csv')

# prior_df <- prior_draws(model_alpha_macro_fat) 
# prior_df %>% 
#   write_csv('../data/090_model_alpha_macro_fat_prior_interaction.csv')

```

# conditional effects plot 

```{r}
full_original <- full %>%
  mutate(ave_fiber = ave_fiber*100,
       ave_fat = ave_fat*100,
       ave_Protein = ave_Protein*100,
       ave_Sugars = ave_Sugars*100,
       ave_carb = ave_carb*100,
       ave_cal = ave_cal*1000
       )%>% 
  #mutate(intensity = factor(intensity, levels = c('nonablative','reduced','ablative'))) %>% 
  mutate(timebin = cut_width(sdrt, 7, boundary=0, closed = 'left')) %>%
  mutate(pid = factor(pid)) %>% 
  mutate(
         TPN = if_else(TPN == 1, T, F),
         EN = if_else(EN == 1, T, F)) %>% 
  mutate(intensityAblative = if_else(intensity == 'ablative', T, F),
         intensityNonablative = if_else(intensity == 'nonablative', T, F),
         intensityReduced = if_else(intensity == 'reduced', T, F))

alpha_macro_fat_original <- log(simpson_reciprocal) ~ 0 +
               empirical+
               intensityAblative + 
                intensityNonablative +
                intensityReduced +
                ave_fiber:empirical +
                ave_fat:empirical  +
                ave_Sugars:empirical  +
                TPN+
                EN+
               (1 | pid) +
                (1 | timebin)  



priors_alpha_macro_fat__original <- c(
             # for the macronutrients terms
            prior(normal(0, 1), class = 'b', coef = "empiricalFALSE:ave_fiber"),
            prior(normal(0, 1), class = 'b', coef = "empiricalFALSE:ave_fat"),
            prior(normal(0, 1), class = 'b', coef = "empiricalFALSE:ave_Sugars"),
            # for the interaction terms
            prior(normal(0, 1), class = 'b', coef = "empiricalTRUE:ave_fiber"),
            prior(normal(0, 1), class = 'b', coef = "empiricalTRUE:ave_fat"),
            prior(normal(0, 1), class = 'b', coef = "empiricalTRUE:ave_Sugars"),
            # for the TPN 
            prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE"),
            # for the EN
            prior(normal(0, 0.1), class = 'b', coef = "ENTRUE"),
            # for the empirical 
            prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE"),
            prior(normal(0, 0.5), class = 'b', coef = "empiricalFALSE"),
            # for the intensity 
            prior(normal(2, .1), class = 'b', coef = "intensityAblativeTRUE"),
            prior(normal(2, .1), class = 'b', coef = "intensityReducedTRUE"),
            prior(normal(2, .1), class = 'b', coef = "intensityNonablativeTRUE"))


model_alpha_macro_fat_original  <- brm( alpha_macro_fat_original,  
              data = full_original, 
              warmup = 1000, iter = 3000, 
              prior = priors_alpha_macro_fat__original,
               control = list(adapt_delta = 0.99),
              cores = ncores,
              chains = 2, 
              seed = 125, sample_prior = T)

dat_conditional_macro <- conditional_effects(model_alpha_macro_fat_original, surface = T)

condi_dat_macro <- dat_conditional_macro %>% 
  keep(.p = str_detect(names(.), ':')) %>% 
  bind_rows(.id = 'grp')     


# to make the conditional plot like F2
library(wesanderson) 
key <- read_csv('../data/food_group_color_key_final.csv', col_types = 'ccccc')

palette <- wes_palette("Royal1", 2)
# the color for the strip background
strip_color <- wes_palette("Royal1", 3)[3]
```

### plot     

```{r}
conditional3 <- condi_dat_macro %>%   
  mutate(var = if_else(str_detect(grp, 'fiber'), 'Fiber', if_else(str_detect(grp, 'fat'), 'Fat', 'Sugars'))) %>% 
  ggplot() +
  geom_smooth(aes(x = effect1__, y = estimate__, ymin = lower__, ymax = upper__, fill = effect2__, color = effect2__),
              stat = "identity",
              alpha = .6, linewidth = 1.5)+ 
  scale_fill_manual('antibiotics', values = palette, labels=c('not exposed', 'exposed')) +
  scale_colour_manual('antibiotics', values = palette, labels=c('not exposed', 'exposed')) +
  facet_wrap(~ var, nrow = 1, scales = 'free_x') +
  labs(y = 'Predicted log(diversity)', x = 'Macronutreints consumed (grams)') +
  theme_classic() +
  theme(legend.position = 'none', legend.title = element_text(size = 8, face="bold"),
        legend.text = element_text( size=8, face="bold"),
        legend.background=element_rect(fill = alpha("white", 0)),
       legend.key=element_rect(fill = alpha("white", 0)),
       panel.background = element_rect(fill = "#6B8E2320"),
        aspect.ratio = 1/1.5, 
        strip.background = element_rect(color="white", fill='#6B8E2340', size=1.5,linetype="solid"),
     axis.text=element_text(size=8), axis.title=element_text(size=axis_text_size))    +
  guides(fill = guide_legend(direction = "vertical"), color = guide_legend(direction = "vertical"))
conditional3  %>% write_rds('../intermediate_data//090_conditional3.RDS') 
```

# macro genera     

```{r}
# priors <- c(  # for the macro nutrients
#             prior(normal(0, 1), class = 'b', coef = "ave_fiber"),
#             prior(normal(0, 1), class = 'b', coef = "ave_fat"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Sugars"),
#             # for the interaction terms
#             prior(normal(0, 1), class = 'b', coef = "ave_fiber_e"),
#             prior(normal(0, 1), class = 'b', coef = "ave_fat_e"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Sugars_e"),
#             # for the TPN 
#             prior(normal(0, 0.1), class = 'b', coef = "TPN"),
#             # for the EN
#             prior(normal(0, 0.1), class = 'b', coef = "EN"),
#             # for the empirical 
#             prior(normal(0, 0.5), class = 'b', coef = "abx")
#             )
# 
# # I want to only include the genus that are more prevalent and abundant, and most likely exist in human gut
# meta <- read_csv('../data/153_combined_META.csv')
# 
# cts <- read_csv('../data/022_ALL173_stool_samples_genus_counts.csv') %>% 
#   filter(sampleid %in% meta$sampleid) 
# thre <- seq(0.0001, 0.002, 0.0001)
# thre %>% 
#   set_names(thre) %>% 
#   map_dfr(function(num){
#     cts %>% 
#     group_by(genus) %>% 
#     count(relab > num) %>% 
#     rename(criteria = names(.)[2]) %>% 
#     filter(criteria == 'TRUE') %>% 
#     arrange(-n) %>% 
#     filter(genus != 'NA') %>% 
#     mutate(perc = round(n/nrow(meta)*100, 0)) %>% 
#     filter(perc > 10) %>% 
#       nrow
#   }) %>% 
#   gather('thre', 'num')
# 
# target_genera <-  cts %>% 
#   group_by(genus) %>% 
#   count(relab > 0.002) %>% 
#   rename(criteria = names(.)[2]) %>% 
#   filter(criteria == 'TRUE') %>% 
#   arrange(-n) %>% 
#   filter(genus != 'NA') %>% 
#   mutate(perc = round(n/nrow(meta)*100, 0)) %>% 
#   filter(perc > 10) %>% 
#   pull(genus) 
# #target_genera %>% write_csv('../data/087_more_abundant_0.002_genus_33.csv')
# 
# macro_genus_interaction <- target_genera %>% 
#   set_names(target_genera) %>% 
#   purrr::map(function(genus) {
#     print(str_glue('{genus} is RUNNING!\n'))
#     mod =  brm( as.formula(str_glue(
#               '{genus}  ~ 
#               0 +
#                 ave_fiber_e +
#                 ave_fat_e +
#                 ave_Sugars_e +
#                 ave_fiber +
#                 ave_fat +
#                 ave_Sugars +
#                abx+
#                intensity +
#                 TPN+
#                 EN+
#                (1 | pid) +
#                 (1 | timebin)')),  
#                 data = full, 
#               warmup = 1000, iter = 3000, 
#               prior = priors,
#               cores = ncores, 
#               chains = 2, 
#               control = list(adapt_delta = 0.99),
#               seed = 456) 
#   })
# 
# post_df <- macro_genus_interaction %>% 
#   imap(~ (suppressWarnings(posterior_samples(.x)) ))  %>% 
#   bind_rows(.id = 'genus')  
# post_df %>% 
#   write_csv('../data/090_target_genus_macro_model_post_interaction.csv')


```

# macro and protein and genus

```{r}
# priors <- c(  # for the macro nutrients
#             prior(normal(0, 1), class = 'b', coef = "ave_fiber"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Sugars"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Protein"),
#             # for the interaction terms
#             prior(normal(0, 1), class = 'b', coef = "ave_fiber_e"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Sugars_e"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Protein_e"),
#             # for the TPN 
#             prior(normal(0, 0.1), class = 'b', coef = "TPN"),
#             # for the EN
#             prior(normal(0, 0.1), class = 'b', coef = "EN"),
#             # for the empirical 
#             prior(normal(0, 0.5), class = 'b', coef = "abx")
#             )
# 
# protein_macro_genus_interaction <- target_genera %>% 
#   set_names(target_genera) %>% 
#   purrr::map(function(genus) {
#     print(str_glue('{genus} is RUNNING!\n'))
#     mod =  brm( as.formula(str_glue(
#               '{genus}  ~ 
#               0 +
#                 ave_fiber_e +
#                 ave_Protein_e +
#                 ave_Sugars_e +
#                 ave_fiber +
#                 ave_Protein +
#                 ave_Sugars +
#                abx+
#                intensity +
#                 TPN+
#                 EN+
#                (1 | pid) +
#                 (1 | timebin)')),  
#                 data = full, 
#               warmup = 1000, iter = 3000, 
#               prior = priors,
#               cores = ncores, 
#               chains = 2, 
#               control = list(adapt_delta = 0.99),
#               seed = 456) 
#   })
# 
# post_df <- protein_macro_genus_interaction %>% 
#   imap(~ (suppressWarnings(posterior_samples(.x)) ))  %>% 
#   bind_rows(.id = 'genus')  
# post_df %>% 
#   write_csv('../data/090_target_protein_genus_macro_model_post_interaction.csv')
```
 
# _pairwise correlation of the macronutrients 

```{r}
# --- Part 1: Load and Aggregate Data ---

# Define the new, simpler names for the macronutrient columns
macro_cols_new <- c("Protein", "Fat", "Starch", "Fibers", "Sugars")

# Load the dataset
# Make sure the "152_combined_DTB.csv" file is in the same
# directory as this R script, or provide the full path.
dtb <- read_csv("../data/152_combined_DTB.csv") |> 
  mutate(starch_g = Carbohydrates_g - Fibers_g - Sugars_g)

# Aggregate food intake to get daily totals per patient.

#
# The 'sum(..., na.rm = TRUE)' part handles the "impute zero" request.
# If a patient ate other foods on that day but 0 of one macro,
# the sum for that macro will correctly be 0 (not NA).
daily_macros <- dtb |>
  group_by(pid, fdrt) |>
  summarise(
    Protein = sum(Protein_g, na.rm = TRUE),
    Fat = sum(Fat_g, na.rm = TRUE),
    Starch = sum(starch_g, na.rm = TRUE),
    Fibers = sum(Fibers_g, na.rm = TRUE),
    Sugars = sum(Sugars_g, na.rm = TRUE),
    .groups = 'drop' # Ungroups the data after summarising
  ) |>
  # The rmcorr() function requires at least 2 observations (days)
  # per participant ('pid') to calculate a correlation.
  # This section filters out any participants with only one day of data.
  add_count(pid) |> # Add a column 'n' with the count of days per pid
  filter(n > 1) |>  # Keep only pids with more than 1 day
  select(-n)        # Remove the temporary 'n' column

# Display the first few rows of the aggregated data to check
print("--- Aggregated Daily Macronutrients (Head) ---")
print(head(daily_macros))
```


```{r}
# --- Part 2: Calculate Pairwise Repeated-Measures Correlation ---

# Get all unique combinations (pairs) of the macronutrient names
pairs <- combn(macro_cols_new, 2, simplify = FALSE)

# Now, we "map" over (loop through) each pair and run the
# repeated-measures correlation (rmcorr).
# This correctly accounts for the non-independent, repeated data
# from the same patient, which a standard Pearson correlation would not.
rmcorr_results <- pairs |>
  map(\(pair) {
    m1_name <- pair[1] # First measure in the pair
    m2_name <- pair[2] # Second measure in the pair

    # Run the rmcorr analysis
    # rmcorr() conveniently takes the column names as strings
    result <- rmcorr(
      participant = pid,
      measure1 = m1_name,
      measure2 = m2_name,
      dataset = daily_macros |> mutate(pid = factor(pid))
    )

    # Return a tidy data frame (tibble) of the key results
    tibble(
      measure1 = m1_name,
      measure2 = m2_name,
      r = result$r,      # The correlation coefficient
      p_value = result$p,  # The p-value
      df = result$df     # Degrees of freedom
    )
  }) |>
  list_rbind() # Combine all the individual pair results into one big table

# Print the correlation results to the console
print("--- Pairwise Repeated-Measures Correlations (rmcorr) ---")
print(rmcorr_results)
```


```{r}
# # --- Part 3: Visualize the Correlation Matrix ---
# 
# # To create a "staircase" plot, we first need to build a
# # full, symmetric matrix from our 'rmcorr_results' (which is
# # just the lower triangle).
# 
# # 1. Create the reverse pairs (e.g., Fat vs Protein)
# rmcorr_results_reversed <- rmcorr_results |>
#   rename(
#     measure1 = measure2,
#     measure2 = measure1
#   )
# 
# # 2. Create the diagonal entries (e.g., Protein vs Protein)
# #    The correlation of a variable with itself is always 1.
# rmcorr_results_diag <- tibble(
#   measure1 = macro_cols_new,
#   measure2 = macro_cols_new,
#   r = 1
# )
# 
# # 3. Combine all parts: original, reversed, and diagonal
# full_corr_data <- bind_rows(
#   rmcorr_results,
#   rmcorr_results_reversed,
#   rmcorr_results_diag
# )
# 
# # 4. Pivot the data from a long format to a wide matrix format
# #    that corrplot() expects.
# corr_matrix <- full_corr_data |>
#   select(measure1, measure2, r) |>
#   pivot_wider(
#     names_from = measure2,
#     values_from = r
#   ) |>
#   column_to_rownames(var = "measure1") |> # Set row names
#   as.matrix()                           # Convert to matrix
# 
# # 5. Ensure the matrix rows and columns are in the original,
# #    logical order (Protein, Fat, etc.), not alphabetical.
# corr_matrix_ordered <- corr_matrix[macro_cols_new, macro_cols_new]
# 
# # 6. Generate the plot!
# print("--- Generating Correlation Plot ---")
# 
# # We create a little margin at the top for the title
# par(mar = c(0, 0, 2, 0)) # bottom, left, top, right
# 
# # REMOVED: No longer creating 'col_inverted'. We will use the
# # default corrplot colors (Blue-White-Red).
# 
# # DEFINE the correct color palette:
# # We are forcing a "Blue -> White -> Red" scale
# # This maps -1 (lowest) to Blue, 0 to White, and +1 (highest) to Red.
# col_palette <- colorRampPalette(c("#00007F", "green", "#7F0000"))(200)
# 
# # Define the colors for the text labels (tl.col)
# # We want "Fat", "Fibers", and "Sugars" to be forestgreen,
# # and all others to be black.
# label_colors <- ifelse(
#   macro_cols_new %in% c("Fat", "Fibers", "Sugars"), 
#   "black", 
#   "black"
# )
# 
# corrplot(
#   corr_matrix_ordered,
#   method = "color",       # Use color to represent correlation strength
#   type = "lower",         # Show only the lower triangle ("stair case")
#   addCoef.col = "black",  # Add the correlation coefficient values
#   tl.col = label_colors,  # <-- FIXED: Use the custom label colors
#   tl.srt = 45,            # Rotate text labels 45 degrees
#   diag = FALSE,           # Don't plot the diagonal (self-correlation)
#  col = col_palette, 
#   title = "Pairwise Repeated-Measures Correlations (rmcorr)",
#   mar = c(0, 0, 1, 0)     # Adjust plot margins
# )
# 
# # Reset plotting parameters to default
# par(mar = c(5.1, 4.1, 4.1, 2.1)) 
```
```{r}
# --- Part 6: Generate and Combine Plots with ggplot2 & patchwork ---
#
# Instead of corrplot (base R), we will build the plot in ggplot2
# so it can be combined with other ggplot objects.
#
# We only need the lower triangle + the diagonal for a staircase plot
plot_data_lower_tri <- rmcorr_results |>
  # Ensure the factors are in the correct, non-alphabetical order
  mutate(
    measure1 = factor(measure1, levels = macro_cols_new),
    measure2 = factor(measure2, levels = macro_cols_new)
  )


# Create the ggplot correlation plot
p_corrplot <- ggplot(plot_data_lower_tri, aes(x = measure1, y = measure2, fill = r)) +
  geom_tile(color = "white") + # Add white borders to the tiles
  geom_text(aes(label = round(r, 2)), color = "black", size = 3.5) +
  # Use the same "Blue-White-Red" color scale, centered at 0
  scale_fill_gradient2(
    low = "#15294B", 
    mid = "yellow", 
    high = "red",
    midpoint = 0.4,
    limit = c(0, 1), # Force the scale to be from -1 to 1
    name = "r"
  ) +
  # Force the y-axis to be in the "matrix" order (reversed)
  scale_y_discrete(limits = rev(macro_cols_new)) +
  scale_x_discrete(position = "top") + # Move x-axis labels to the top
  theme_minimal() + # Use a clean theme
  theme(
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 0),
    panel.grid = element_blank(),
    legend.position = "right"
  ) +
  labs(title = "Pairwise Repeated-Measures Correlations (rmcorr)") +
  coord_fixed() # Ensure tiles are square

p_corrplot
```


# calculate the pariwise correlation for the summarized values that will be use in the model

```{r}
#  calculate the prior two day average 
stool_samples_df <- read_csv('../data/153_combined_META.csv') %>%
  select(pid, sdrt, sampleid, simpson_reciprocal, empirical, intensity, EN, TPN)

daily_intake_summary <- daily_macros |> 
  gather('macronutrient','gram', Protein:Sugars)

stool_samples_with_window <- stool_samples_df %>%
  mutate(
    window_start = sdrt - 2,
    window_end = sdrt - 1
  )

# Perform the join and calculate the averages.
final_model_data <- stool_samples_with_window %>%
  left_join(
    daily_intake_summary,
    by = join_by(
      pid,
      window_start <= fdrt,
      window_end >= fdrt
    )
  ) %>%
  # Reshape the data into the final wide format needed for modeling.
  pivot_wider(
    id_cols = c(pid, sdrt), # The columns that identify a unique stool sample
    names_from = macronutrient,
    values_from = gram,
    values_fn = ~ sum(.x, na.rm = TRUE) / 2, # The function to apply: sum and average
    values_fill = 0, # If a category wasn't eaten, its value is 0
    names_prefix = "avg_intake_" # Adds a clear prefix to the new columns
  ) %>%
  # This divides all the new intake columns by 100 for easier model interpretation.
  mutate(across(starts_with("avg_intake_"), ~ .x / 100)) %>%
  # Joins back the original stool sample info.
  right_join(stool_samples_df, by = c("pid", "sdrt")) %>% 
  mutate(timebin = cut_width(sdrt, 7, boundary=0, closed = 'left')) %>% 
  mutate(intensity = factor(intensity, levels = c('nonablative','reduced','ablative'))) %>% 
  mutate(pid = factor(pid)) 
```


```{r}
macro_cols_p2d <- final_model_data %>% select(starts_with('avg_intake_')) |> colnames()

pairs <- combn(macro_cols_p2d, 2, simplify = FALSE)

# Now, we "map" over (loop through) each pair and run the
# repeated-measures correlation (rmcorr).
# This correctly accounts for the non-independent, repeated data
# from the same patient, which a standard Pearson correlation would not.
rmcorr_results_p2d <- pairs |>
  map(\(pair) {
    m1_name <- pair[1] # First measure in the pair
    m2_name <- pair[2] # Second measure in the pair

    # Run the rmcorr analysis
    # rmcorr() conveniently takes the column names as strings
    result <- rmcorr(
      participant = pid,
      measure1 = m1_name,
      measure2 = m2_name,
      dataset = final_model_data
    )

    # Return a tidy data frame (tibble) of the key results
    tibble(
      measure1 = m1_name,
      measure2 = m2_name,
      r = result$r,      # The correlation coefficient
      p_value = result$p,  # The p-value
      df = result$df     # Degrees of freedom
    )
  }) |>
  list_rbind()
rmcorr_results_p2d
```

# model with all 5 macronutreints in it

```{r}
all_macro_vars <- macro_cols_p2d

# Create the interaction terms for all food variables in this iteration
interaction_terms <- paste(all_macro_vars, "empirical", sep = ":")

# Build the full formula string dynamically
formula_string <- paste(
  "log(simpson_reciprocal) ~ 0 + intensity + empirical + TPN + EN +",
  paste(interaction_terms, collapse = " + "),
  "+ (1 | pid) + (1 | timebin)"
)

# Convert the string to a formula object
formula <- brms::bf(as.formula(formula_string))

# Build the priors by adding them together.
# This single prior() call applies to all coefficients listed in `all_food_coefs`.
priors <-
    prior(normal(0, 1), class = 'b') + # General prior for all food effects
    # Specific priors that override the general one for non-food covariates
    prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE") +
    prior(normal(0, 0.1), class = 'b', coef = "ENTRUE") +
    prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE") +
    prior(normal(2, .1), class = 'b', coef = "intensityablative") +
    prior(normal(2, .1), class = 'b', coef = "intensityreduced") +
    prior(normal(2, .1), class = 'b', coef = "intensitynonablative")

# Fit the model (using fewer iterations for this example to run quickly)
model_fit <- brm(
  formula = formula,
  data = final_model_data,
  prior = priors,
    warmup = 1000, iter = 3000,
    chains = 4, cores = 4,
    seed = 123,
    silent = 2,
  control = list(adapt_delta = 0.99)
)

results_df <- tidy(model_fit, conf.int = TRUE) %>%
  mutate(conf.low = round(conf.low, 2),
         conf.high = round(conf.high, 2)) 
```
```{r}

level_order <- rev(c(
    "abx", "EN", "TPN",
    "abx * Sugars", "Sugars",
    "abx * Fiber", "Fiber",
    "abx * Fat", "Fat",
    "abx * Starch", "Starch",
    "abx * Protein", "Protein"
))

cleaned_effects <- results_df %>%
  # Keep only the fixed effects
  filter(effect == "fixed") %>%
  # Create a new column to distinguish main effects from interactions
  mutate(
    effect_type = if_else(str_detect(term, ":"), "Interaction", "Main Effect"),
    # Create clean labels for plotting
    clean_term = case_when(
      # Main effects (antibiotics, EN, TPN)
      # 'empiricalTRUE' seems to correspond to 'abx' in your model
      term == "empiricalTRUE" ~ "abx",
      term == "ENTRUE" ~ "EN",
      term == "TPNTRUE" ~ "TPN",
      
      # Interaction terms (abx * nutrient)
      term == "empiricalTRUE:avg_intake_Starch" ~ "abx * Starch",
      term == "empiricalTRUE:avg_intake_Fat" ~ "abx * Fat",
      term == "empiricalTRUE:avg_intake_Fibers" ~ "abx * Fiber",
      term == "empiricalTRUE:avg_intake_Protein" ~ "abx * Protein",
      term == "empiricalTRUE:avg_intake_Sugars" ~ "abx * Sugars",
      
      # Nutrient-only terms (the 'FALSE' condition)
      # These seem to be the main nutrient effects without the interaction.
      term == "empiricalFALSE:avg_intake_Starch" ~ "Starch",
      term == "empiricalFALSE:avg_intake_Fat" ~ "Fat",
      term == "empiricalFALSE:avg_intake_Fibers" ~ "Fiber",
      term == "empiricalFALSE:avg_intake_Protein" ~ "Protein",
      term == "empiricalFALSE:avg_intake_Sugars" ~ "Sugars",
      
      # A fallback rule. If a term doesn't match any of the above,
      # it will just keep its original name.
      TRUE ~ term 
    )
  ) %>%
  filter(!str_detect(clean_term, 'intensity')) %>%
  # Create a new column to identify significant results
  # The condition is TRUE if conf.low and conf.high have the same sign (i.e., don't cross zero)
  mutate(is_significant = (conf.low * conf.high) > 0,
         clean_term = factor(clean_term, levels = level_order))


```


```{r}
shading_df <- cleaned_effects %>%
  mutate(y_numeric = as.numeric(clean_term)) %>%
  filter(str_detect(clean_term, "\\*")) # Filter for interaction terms

plot_forest <- ggplot(cleaned_effects, aes(x = estimate, y = clean_term)) +
  geom_rect(
    data = shading_df,
    aes(ymin = y_numeric - 0.5, ymax = y_numeric + 0.5, xmin = -Inf, xmax = Inf),
    fill = "#d8dcc8", # A light orange/peach color like the example
    alpha = 0.7,
    inherit.aes = FALSE
   ) +
   # Add a vertical line at zero, which represents "no effect"
  geom_vline(xintercept = 0, linetype = "solid", color = "blue",size = 0.8) +
   # Use geom_pointrange to show the estimate (point) and confidence interval (line)
   geom_pointrange(
   aes(xmin = conf.low, xmax = conf.high, color = is_significant),
     size = 0.25,linewidth = 1,
  ) +
  scale_color_manual(
    values = c(
      "TRUE" = "red",
      "FALSE" = "black"
    ), name = "Effect Status" # Legend title
  ) +
  scale_y_discrete( labels = function(x) { ifelse(str_detect(x, '\\*'),  str_glue("<b style='color:royalblue'>{x}</b>"), as.character(x)) }) +
  # Add labels and a clean theme
  labs(
    x = "ln(diversity) change",
    title = "Predictor effects on diversity",
    #subtitle = "Sensitivity Analysis: Capped at max 5 samples per patient",
    y = ''
  ) +
  theme_classic(base_size = 11) +
  theme(legend.position = "none", axis.text.y = element_markdown(),plot.margin = unit(c(1, 10, 1, 1), "cm"))


final_plot <- plot_grid(p_corrplot , 
                      plot_forest,  
                ncol  = 1,
                labels = 'auto',
                rel_heights = c(1,1),
                align = 'vh', axis = 'l')


title <- ggdraw() + 
  draw_label("Rebuttal Fig X",fontface = 'bold', x = 0,hjust = 0) +
  theme(plot.margin = margin(0, 0, 0, 0))

combined <- plot_grid(
  title, final_plot,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
) +theme(plot.margin = unit(c(1,1,2,1), "cm"))

ggsave('../data/090_macronutrient_correlation.pdf',
      width = 8.5, height = 11, units = "in", device = 'pdf', 
      dpi = 300)       
```
