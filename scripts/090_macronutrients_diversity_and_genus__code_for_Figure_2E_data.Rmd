---
title: "Macronutrients with diversity or genus"
output: html_document  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Previous 2 day results** 

```{r}
library(tidyverse)
library(ggpubr)
library(tidybayes)  
library(brms)
library(rstan)
library(cowplot)
library(rmcorr)      # For the repeated-measures correlation
library(corrplot) 
options(mc.cores = parallel::detectCores())
ncores = parallel::detectCores()
rstan_options(auto_write = TRUE)
axis_text_size <- 10
axis_title_size <- 10
```

# alpha diversity and macronutrients (fat) model

```{r}
clr_res <- read_csv('../data/171_genus_CLR_res.csv')

clr_wide <- clr_res %>% 
  spread('genus','clr')
```


```{r}
# to change the df a little bit 
# the ave_XXX value were already divided by 100
full <- read_csv('../data/090_all_samples1009_meta_p2d_fg9_dietall_genera90_pid.csv') %>% 
  mutate(abx = if_else(empirical == 'TRUE', 1, 0),
         TPN = if_else(TPN == 'TRUE', 1, 0),
         EN = if_else(EN == 'TRUE', 1, 0)) %>% 
  mutate(intensity = factor(intensity, levels = c('nonablative','reduced','ablative'))) %>%
  mutate(      ave_fiber_e= ave_fiber*abx,
               ave_carb_e = ave_carb*abx,
               ave_Protein_e= ave_Protein*abx,
                ave_fat_e=ave_fat*abx,
                ave_Sugars_e=ave_Sugars*abx) %>% 
  select(sampleid:ave_carb, intensityAblative:ave_Sugars_e) %>% 
  full_join(clr_wide)
```


```{r}
alpha_macro_fat <- log(simpson_reciprocal) ~ 0 +
                ave_fiber_e +
                ave_fat_e +
                ave_Sugars_e +
                ave_fiber +
                ave_fat +
                ave_Sugars +
               abx+
               intensity +
                TPN+
                EN+
               (1 | pid) +
                (1 | timebin)
get_prior(formula = alpha_macro_fat, data = full)

priors_alpha_macro_fat <- c(
            # for the macro nutrients
            prior(normal(0, 1), class = 'b', coef = "ave_fiber"),
            prior(normal(0, 1), class = 'b', coef = "ave_fat"),
            prior(normal(0, 1), class = 'b', coef = "ave_Sugars"),
            # for the interaction terms
            prior(normal(0, 1), class = 'b', coef = "ave_fiber_e"),
            prior(normal(0, 1), class = 'b', coef = "ave_fat_e"),
            prior(normal(0, 1), class = 'b', coef = "ave_Sugars_e"),
            # for the TPN 
            prior(normal(0, 0.1), class = 'b', coef = "TPN"),
            # for the EN
            prior(normal(0, 0.1), class = 'b', coef = "EN"),
            # for the empirical 
            prior(normal(0, 0.5), class = 'b', coef = "abx"),
            # for the intensity 
            prior(normal(2, .1), class = 'b', coef = "intensityablative"),
            prior(normal(2, .1), class = 'b', coef = "intensityreduced"),
            prior(normal(2, .1), class = 'b', coef = "intensitynonablative"))

# vet the prior 
model_alpha_macro_fat  <- brm( alpha_macro_fat,  
              data = full, 
              warmup = 1000, iter = 3000, 
              prior = priors_alpha_macro_fat,
               control = list(adapt_delta = 0.99),
              cores = ncores,
              chains = 2, 
              seed = 125, sample_prior = T)


post_res <- suppressWarnings(posterior_samples(model_alpha_macro_fat))
post_res %>%  write_csv('../results/090_model_alpha_macro_fat_post_interaction.csv')

# prior_df <- prior_draws(model_alpha_macro_fat) 
# prior_df %>% 
#   write_csv('../data/090_model_alpha_macro_fat_prior_interaction.csv')

```

# conditional effects plot 

```{r}
full_original <- full %>%
  mutate(ave_fiber = ave_fiber*100,
       ave_fat = ave_fat*100,
       ave_Protein = ave_Protein*100,
       ave_Sugars = ave_Sugars*100,
       ave_carb = ave_carb*100,
       ave_cal = ave_cal*1000
       )%>% 
  #mutate(intensity = factor(intensity, levels = c('nonablative','reduced','ablative'))) %>% 
  mutate(timebin = cut_width(sdrt, 7, boundary=0, closed = 'left')) %>%
  mutate(pid = factor(pid)) %>% 
  mutate(
         TPN = if_else(TPN == 1, T, F),
         EN = if_else(EN == 1, T, F)) %>% 
  mutate(intensityAblative = if_else(intensity == 'ablative', T, F),
         intensityNonablative = if_else(intensity == 'nonablative', T, F),
         intensityReduced = if_else(intensity == 'reduced', T, F))

alpha_macro_fat_original <- log(simpson_reciprocal) ~ 0 +
               empirical+
               intensityAblative + 
                intensityNonablative +
                intensityReduced +
                ave_fiber:empirical +
                ave_fat:empirical  +
                ave_Sugars:empirical  +
                TPN+
                EN+
               (1 | pid) +
                (1 | timebin)  



priors_alpha_macro_fat__original <- c(
             # for the macronutrients terms
            prior(normal(0, 1), class = 'b', coef = "empiricalFALSE:ave_fiber"),
            prior(normal(0, 1), class = 'b', coef = "empiricalFALSE:ave_fat"),
            prior(normal(0, 1), class = 'b', coef = "empiricalFALSE:ave_Sugars"),
            # for the interaction terms
            prior(normal(0, 1), class = 'b', coef = "empiricalTRUE:ave_fiber"),
            prior(normal(0, 1), class = 'b', coef = "empiricalTRUE:ave_fat"),
            prior(normal(0, 1), class = 'b', coef = "empiricalTRUE:ave_Sugars"),
            # for the TPN 
            prior(normal(0, 0.1), class = 'b', coef = "TPNTRUE"),
            # for the EN
            prior(normal(0, 0.1), class = 'b', coef = "ENTRUE"),
            # for the empirical 
            prior(normal(0, 0.5), class = 'b', coef = "empiricalTRUE"),
            prior(normal(0, 0.5), class = 'b', coef = "empiricalFALSE"),
            # for the intensity 
            prior(normal(2, .1), class = 'b', coef = "intensityAblativeTRUE"),
            prior(normal(2, .1), class = 'b', coef = "intensityReducedTRUE"),
            prior(normal(2, .1), class = 'b', coef = "intensityNonablativeTRUE"))


model_alpha_macro_fat_original  <- brm( alpha_macro_fat_original,  
              data = full_original, 
              warmup = 1000, iter = 3000, 
              prior = priors_alpha_macro_fat__original,
               control = list(adapt_delta = 0.99),
              cores = ncores,
              chains = 2, 
              seed = 125, sample_prior = T)

dat_conditional_macro <- conditional_effects(model_alpha_macro_fat_original, surface = T)

condi_dat_macro <- dat_conditional_macro %>% 
  keep(.p = str_detect(names(.), ':')) %>% 
  bind_rows(.id = 'grp')     


# to make the conditional plot like F2
library(wesanderson) 
key <- read_csv('../data/food_group_color_key_final.csv', col_types = 'ccccc')

palette <- wes_palette("Royal1", 2)
# the color for the strip background
strip_color <- wes_palette("Royal1", 3)[3]
```

### plot     

```{r}
conditional3 <- condi_dat_macro %>%   
  mutate(var = if_else(str_detect(grp, 'fiber'), 'Fiber', if_else(str_detect(grp, 'fat'), 'Fat', 'Sugars'))) %>% 
  ggplot() +
  geom_smooth(aes(x = effect1__, y = estimate__, ymin = lower__, ymax = upper__, fill = effect2__, color = effect2__),
              stat = "identity",
              alpha = .6, linewidth = 1.5)+ 
  scale_fill_manual('antibiotics', values = palette, labels=c('not exposed', 'exposed')) +
  scale_colour_manual('antibiotics', values = palette, labels=c('not exposed', 'exposed')) +
  facet_wrap(~ var, nrow = 1, scales = 'free_x') +
  labs(y = 'Predicted log(diversity)', x = 'Macronutreints consumed (grams)') +
  theme_classic() +
  theme(legend.position = 'none', legend.title = element_text(size = 8, face="bold"),
        legend.text = element_text( size=8, face="bold"),
        legend.background=element_rect(fill = alpha("white", 0)),
       legend.key=element_rect(fill = alpha("white", 0)),
       panel.background = element_rect(fill = "#6B8E2320"),
        aspect.ratio = 1/1.5, 
        strip.background = element_rect(color="white", fill='#6B8E2340', size=1.5,linetype="solid"),
     axis.text=element_text(size=8), axis.title=element_text(size=axis_text_size))    +
  guides(fill = guide_legend(direction = "vertical"), color = guide_legend(direction = "vertical"))
conditional3  %>% write_rds('../intermediate_data//090_conditional3.RDS') 
```

# macro genera     

```{r}
# priors <- c(  # for the macro nutrients
#             prior(normal(0, 1), class = 'b', coef = "ave_fiber"),
#             prior(normal(0, 1), class = 'b', coef = "ave_fat"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Sugars"),
#             # for the interaction terms
#             prior(normal(0, 1), class = 'b', coef = "ave_fiber_e"),
#             prior(normal(0, 1), class = 'b', coef = "ave_fat_e"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Sugars_e"),
#             # for the TPN 
#             prior(normal(0, 0.1), class = 'b', coef = "TPN"),
#             # for the EN
#             prior(normal(0, 0.1), class = 'b', coef = "EN"),
#             # for the empirical 
#             prior(normal(0, 0.5), class = 'b', coef = "abx")
#             )
# 
# # I want to only include the genus that are more prevalent and abundant, and most likely exist in human gut
# meta <- read_csv('../data/153_combined_META.csv')
# 
# cts <- read_csv('../data/022_ALL173_stool_samples_genus_counts.csv') %>% 
#   filter(sampleid %in% meta$sampleid) 
# thre <- seq(0.0001, 0.002, 0.0001)
# thre %>% 
#   set_names(thre) %>% 
#   map_dfr(function(num){
#     cts %>% 
#     group_by(genus) %>% 
#     count(relab > num) %>% 
#     rename(criteria = names(.)[2]) %>% 
#     filter(criteria == 'TRUE') %>% 
#     arrange(-n) %>% 
#     filter(genus != 'NA') %>% 
#     mutate(perc = round(n/nrow(meta)*100, 0)) %>% 
#     filter(perc > 10) %>% 
#       nrow
#   }) %>% 
#   gather('thre', 'num')
# 
# target_genera <-  cts %>% 
#   group_by(genus) %>% 
#   count(relab > 0.002) %>% 
#   rename(criteria = names(.)[2]) %>% 
#   filter(criteria == 'TRUE') %>% 
#   arrange(-n) %>% 
#   filter(genus != 'NA') %>% 
#   mutate(perc = round(n/nrow(meta)*100, 0)) %>% 
#   filter(perc > 10) %>% 
#   pull(genus) 
# #target_genera %>% write_csv('../data/087_more_abundant_0.002_genus_33.csv')
# 
# macro_genus_interaction <- target_genera %>% 
#   set_names(target_genera) %>% 
#   purrr::map(function(genus) {
#     print(str_glue('{genus} is RUNNING!\n'))
#     mod =  brm( as.formula(str_glue(
#               '{genus}  ~ 
#               0 +
#                 ave_fiber_e +
#                 ave_fat_e +
#                 ave_Sugars_e +
#                 ave_fiber +
#                 ave_fat +
#                 ave_Sugars +
#                abx+
#                intensity +
#                 TPN+
#                 EN+
#                (1 | pid) +
#                 (1 | timebin)')),  
#                 data = full, 
#               warmup = 1000, iter = 3000, 
#               prior = priors,
#               cores = ncores, 
#               chains = 2, 
#               control = list(adapt_delta = 0.99),
#               seed = 456) 
#   })
# 
# post_df <- macro_genus_interaction %>% 
#   imap(~ (suppressWarnings(posterior_samples(.x)) ))  %>% 
#   bind_rows(.id = 'genus')  
# post_df %>% 
#   write_csv('../data/090_target_genus_macro_model_post_interaction.csv')


```

# macro and protein and genus

```{r}
# priors <- c(  # for the macro nutrients
#             prior(normal(0, 1), class = 'b', coef = "ave_fiber"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Sugars"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Protein"),
#             # for the interaction terms
#             prior(normal(0, 1), class = 'b', coef = "ave_fiber_e"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Sugars_e"),
#             prior(normal(0, 1), class = 'b', coef = "ave_Protein_e"),
#             # for the TPN 
#             prior(normal(0, 0.1), class = 'b', coef = "TPN"),
#             # for the EN
#             prior(normal(0, 0.1), class = 'b', coef = "EN"),
#             # for the empirical 
#             prior(normal(0, 0.5), class = 'b', coef = "abx")
#             )
# 
# protein_macro_genus_interaction <- target_genera %>% 
#   set_names(target_genera) %>% 
#   purrr::map(function(genus) {
#     print(str_glue('{genus} is RUNNING!\n'))
#     mod =  brm( as.formula(str_glue(
#               '{genus}  ~ 
#               0 +
#                 ave_fiber_e +
#                 ave_Protein_e +
#                 ave_Sugars_e +
#                 ave_fiber +
#                 ave_Protein +
#                 ave_Sugars +
#                abx+
#                intensity +
#                 TPN+
#                 EN+
#                (1 | pid) +
#                 (1 | timebin)')),  
#                 data = full, 
#               warmup = 1000, iter = 3000, 
#               prior = priors,
#               cores = ncores, 
#               chains = 2, 
#               control = list(adapt_delta = 0.99),
#               seed = 456) 
#   })
# 
# post_df <- protein_macro_genus_interaction %>% 
#   imap(~ (suppressWarnings(posterior_samples(.x)) ))  %>% 
#   bind_rows(.id = 'genus')  
# post_df %>% 
#   write_csv('../data/090_target_protein_genus_macro_model_post_interaction.csv')
```
 
# pairwise correlation of the macronutrients 

```{r}
# --- Part 1: Load and Aggregate Data ---

# Define the new, simpler names for the macronutrient columns
macro_cols_new <- c("Protein", "Fat", "Carbohydrates", "Fibers", "Sugars")

# Load the dataset
# Make sure the "152_combined_DTB.csv" file is in the same
# directory as this R script, or provide the full path.
dtb <- read_csv("../data/152_combined_DTB.csv")

# Aggregate food intake to get daily totals per patient.

#
# The 'sum(..., na.rm = TRUE)' part handles the "impute zero" request.
# If a patient ate other foods on that day but 0 of one macro,
# the sum for that macro will correctly be 0 (not NA).
daily_macros <- dtb |>
  group_by(pid, fdrt) |>
  summarise(
    Protein = sum(Protein_g, na.rm = TRUE),
    Fat = sum(Fat_g, na.rm = TRUE),
    Carbohydrates = sum(Carbohydrates_g, na.rm = TRUE),
    Fibers = sum(Fibers_g, na.rm = TRUE),
    Sugars = sum(Sugars_g, na.rm = TRUE),
    .groups = 'drop' # Ungroups the data after summarising
  ) |>
  # The rmcorr() function requires at least 2 observations (days)
  # per participant ('pid') to calculate a correlation.
  # This section filters out any participants with only one day of data.
  add_count(pid) |> # Add a column 'n' with the count of days per pid
  filter(n > 1) |>  # Keep only pids with more than 1 day
  select(-n)        # Remove the temporary 'n' column

# Display the first few rows of the aggregated data to check
print("--- Aggregated Daily Macronutrients (Head) ---")
print(head(daily_macros))
```


```{r}
# --- Part 2: Calculate Pairwise Repeated-Measures Correlation ---

# Get all unique combinations (pairs) of the macronutrient names
pairs <- combn(macro_cols_new, 2, simplify = FALSE)

# Now, we "map" over (loop through) each pair and run the
# repeated-measures correlation (rmcorr).
# This correctly accounts for the non-independent, repeated data
# from the same patient, which a standard Pearson correlation would not.
rmcorr_results <- pairs |>
  map(\(pair) {
    m1_name <- pair[1] # First measure in the pair
    m2_name <- pair[2] # Second measure in the pair

    # Run the rmcorr analysis
    # rmcorr() conveniently takes the column names as strings
    result <- rmcorr(
      participant = pid,
      measure1 = m1_name,
      measure2 = m2_name,
      dataset = daily_macros |> mutate(pid = factor(pid))
    )

    # Return a tidy data frame (tibble) of the key results
    tibble(
      measure1 = m1_name,
      measure2 = m2_name,
      r = result$r,      # The correlation coefficient
      p_value = result$p,  # The p-value
      df = result$df     # Degrees of freedom
    )
  }) |>
  list_rbind() # Combine all the individual pair results into one big table

# Print the correlation results to the console
print("--- Pairwise Repeated-Measures Correlations (rmcorr) ---")
print(rmcorr_results)
```


```{r}
# --- Part 3: Visualize the Correlation Matrix ---

# To create a "staircase" plot, we first need to build a
# full, symmetric matrix from our 'rmcorr_results' (which is
# just the lower triangle).

# 1. Create the reverse pairs (e.g., Fat vs Protein)
rmcorr_results_reversed <- rmcorr_results |>
  rename(
    measure1 = measure2,
    measure2 = measure1
  )

# 2. Create the diagonal entries (e.g., Protein vs Protein)
#    The correlation of a variable with itself is always 1.
rmcorr_results_diag <- tibble(
  measure1 = macro_cols_new,
  measure2 = macro_cols_new,
  r = 1
)

# 3. Combine all parts: original, reversed, and diagonal
full_corr_data <- bind_rows(
  rmcorr_results,
  rmcorr_results_reversed,
  rmcorr_results_diag
)

# 4. Pivot the data from a long format to a wide matrix format
#    that corrplot() expects.
corr_matrix <- full_corr_data |>
  select(measure1, measure2, r) |>
  pivot_wider(
    names_from = measure2,
    values_from = r
  ) |>
  column_to_rownames(var = "measure1") |> # Set row names
  as.matrix()                           # Convert to matrix

# 5. Ensure the matrix rows and columns are in the original,
#    logical order (Protein, Fat, etc.), not alphabetical.
corr_matrix_ordered <- corr_matrix[macro_cols_new, macro_cols_new]

# 6. Generate the plot!
print("--- Generating Correlation Plot ---")

# We create a little margin at the top for the title
par(mar = c(0, 0, 2, 0)) # bottom, left, top, right

# REMOVED: No longer creating 'col_inverted'. We will use the
# default corrplot colors (Blue-White-Red).

# DEFINE the correct color palette:
# We are forcing a "Blue -> White -> Red" scale
# This maps -1 (lowest) to Blue, 0 to White, and +1 (highest) to Red.
col_palette <- colorRampPalette(c("#00007F", "yellow", "#7F0000"))(200)

# Define the colors for the text labels (tl.col)
# We want "Fat", "Fibers", and "Sugars" to be forestgreen,
# and all others to be black.
label_colors <- ifelse(
  macro_cols_new %in% c("Fat", "Fibers", "Sugars"), 
  "forestgreen", 
  "forestgreen"
)

corrplot(
  corr_matrix_ordered,
  method = "color",       # Use color to represent correlation strength
  type = "lower",         # Show only the lower triangle ("stair case")
  addCoef.col = "black",  # Add the correlation coefficient values
  tl.col = label_colors,  # <-- FIXED: Use the custom label colors
  tl.srt = 45,            # Rotate text labels 45 degrees
  diag = FALSE,           # Don't plot the diagonal (self-correlation)
 col = col_palette, 
  title = "Pairwise Repeated-Measures Correlations (rmcorr)",
  mar = c(0, 0, 1, 0)     # Adjust plot margins
)

# Reset plotting parameters to default
par(mar = c(5.1, 4.1, 4.1, 2.1)) 
```

