---
title: "All two batches of the RNA-seq of the GF mouse experiments"
output: html_document
date: "2025-10-15"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(ggpubr)
library(edgeR)
library(DESeq2)
library(ggrepel)
library(cowplot)
library(patchwork)
library(ashr)
library(fgsea)       # For GSEA
library(msigdbr)     # To get MSigDB gene sets
library(AnnotationDbi)
library(org.Mm.eg.db)
library(ggupset)
library(pheatmap)      # For creating the heatmap
library(viridis)  
library(RColorBrewer) 
library(gridExtra)
library(tidyverse)
```

# merge counts and meta data 

```{r}
# --- 1. Load Raw Count Data ---
# Read the two raw count matrices from the uploaded TSV files.
# The `read_tsv` function from the readr package (part of tidyverse) is used.
counts_b1 <- read_tsv("../data/raw_counts_matrix.tsv")
counts_b2 <- read_tsv("../data/raw_counts_matrix_batch2.tsv")

# --- 2. Merge Count Matrices ---
# The goal is to combine the two matrices into one, aligning genes by their ID.
# A full_join ensures that all genes from both batches are kept.
merged_counts_df <- full_join(counts_b1, counts_b2, by = "Geneid") %>%
  # After joining, genes present in only one batch will have NAs in the columns
  # from the other batch. Replace these NAs with 0.
  mutate(across(where(is.numeric), ~replace_na(., 0))) %>%
  # It's good practice to make the gene IDs the row names for analysis matrices.
  column_to_rownames("Geneid")

# --- 3. Create the Combined Metadata Table ---
# This step involves parsing the complex sample names to extract experimental variables.

# Get all the sample names (column names) from the merged matrix
all_sample_ids <- colnames(merged_counts_df)
# Get the sample names from each batch to assign a 'batch' variable
b1_sample_ids <- colnames(counts_b1)[-1]
b2_sample_ids <- colnames(counts_b2)[-1]

# Create the metadata table
meta_table <- tibble(sample_id = all_sample_ids) %>%
  mutate(
    # Assign a batch label to each sample
    batch = case_when(
      sample_id %in% b1_sample_ids ~ "batch1",
      sample_id %in% b2_sample_ids ~ "batch2"
    ),
    
    # Extract the tissue type (LI or SI) from the sample name,
    # accounting for different naming conventions in batch 1 and batch 2.
    tissue = case_when(
      str_detect(sample_id, "_LI_") | str_starts(sample_id, "LI_") ~ "large_intestine",
      str_detect(sample_id, "_SI_") | str_starts(sample_id, "SI_") ~ "small_intestine"
    ),
    
    # Extract the mouse group identifier (e.g., "1_10", "4_3")
    mouse_group = str_extract(sample_id, "\\d+_\\d+"),
    
    # Assign treatment and water based on the first digit of the mouse group
    treatment = case_when(
      str_starts(mouse_group, "1_") ~ "E. faecalis",
      str_starts(mouse_group, "2_") ~ "E. faecalis",
      str_starts(mouse_group, "3_") ~ "PBS",
      str_starts(mouse_group, "4_") ~ "PBS"
    ),
    
    water = case_when(
      str_starts(mouse_group, "1_") ~ "sucrose_water",
      str_starts(mouse_group, "2_") ~ "regular_water",
      str_starts(mouse_group, "3_") ~ "sucrose_water",
      str_starts(mouse_group, "4_") ~ "regular_water"
    )
  )

# --- 4. Save the New Files ---
# The merged data is now ready to be used in downstream analyses like DESeq2.

# Save the merged raw counts matrix to a new TSV file
# We convert the rownames back to a column for saving.
as.data.frame(merged_counts_df) %>%
  rownames_to_column("Geneid") %>%
  write_tsv("../data/R49_merged_raw_counts.tsv")

# Save the new metadata table to a CSV file
write_csv(meta_table, "../data/R49_combined_meta_table.csv")

# --- 5. Display Summary ---
# Print the dimensions and first few rows to verify the results.
print("Dimensions of merged count matrix:")
print(dim(merged_counts_df))
print("Head of new metadata table:")
print(head(meta_table))

# how many mice in each treatment group two batches combined
meta_table %>% count(treatment, water, tissue)
```
# data-driven filtering 

```{r}
raw_counts_matrix <- merged_counts_df %>% as.matrix()
cpm_matrix <- cpm(raw_counts_matrix)

# ---  Calculate Genes Kept at Different Thresholds ---
# Define the range of CPM thresholds to test.
cpm_thresholds <- seq(0.5, 10, by = 0.5)

# This function will count how many genes pass the filter for a given threshold.
# The rule is: at least 3 samples must be >= the threshold.
count_genes_kept <- function(threshold, cpm_data) {
  # 'apply' goes through each row (gene) of the matrix.
  # For each row, it checks how many sample values are >= the threshold.
  # The result is a vector of TRUE/FALSE for each gene.
  genes_to_keep <- apply(cpm_data, 1, function(gene_row) {
    sum(gene_row >= threshold) >= 4
  })
  # Finally, sum up the TRUE values to get the total number of genes kept.
  return(sum(genes_to_keep))
}

# Apply the function to every threshold in our sequence.
genes_left <- map_int(cpm_thresholds, ~count_genes_kept(., cpm_matrix))

# Combine the thresholds and the gene counts into a results table.
results_df <- tibble(
  cpm_threshold = cpm_thresholds,
  genes_remaining = genes_left
)

# Create the plot.
ggplot(results_df, aes(x = cpm_threshold, y = genes_remaining)) +
  geom_line(color = "dodgerblue", size = 1) +
  geom_point(color = "dodgerblue", size = 2) +
  labs(
    title = "Effect of CPM Threshold on Gene Filtering",
    x = "CPM Threshold (gene kept if expressed in at least 4 samples)",
    y = "Number of Genes Remaining"
  ) +
  theme_minimal() +
  # Add grid lines for easier reading of values.
  theme(panel.grid.major = element_line(color = "grey85"),
        panel.grid.minor = element_line(color = "grey90"))
# 3 is a good elbow point
```

# filter on the CPM

```{r}
# --- Filter Lowly Expressed Genes based on CPM ---
# Remove genes with very low counts across all samples before analysis to improve statistical power.

# Calculate library sizes (total reads per sample)
library_sizes <- colSums(merged_counts_df)

# Calculate CPM (Counts Per Million)
cpm_matrix <- t(t(merged_counts_df) / library_sizes * 1e6)

# Define the filtering threshold based on the elbow plot
cpm_threshold <- 3
# A common rule is to keep genes that are expressed above the threshold in at least
# the number of samples in the smallest experimental group. We'll use 4. 
min_samples <- 4

# Identify genes that meet the criteria
genes_to_keep <- rowSums(cpm_matrix >= cpm_threshold) >= min_samples

# Filter the original raw counts matrix to keep only these genes
filtered_raw_counts_matrix <- merged_counts_df[genes_to_keep, ]
```

# batch effects?

The goal of checking for a batch effect is to see if the technical variation between sequencing runs is driving the differences in your data, rather than the biological variation you're interested in.

If you were to include the PBS samples (which are only in batch 1), you would be looking at a confounded experiment. Any separation you see in a PCA plot wouldn't be clear. Is the separation because of the biological difference between PBS and E. faecalis, or is it because of the technical difference between batch 1 and batch 2? You can't tell them apart.

By creating a dataset that only contains the E. faecalis-treated samples from both batches, you hold the biology constant and can cleanly visualize the technical variable you care about: the batch.

```{r}
# --- Visualize Batch Effects using PCA ---
# To check for batch effects, it's best to use samples with the same biological condition
# that are present in both batches. In this case, it's the 'E. faecalis' treated samples.

# Filter the metadata to get only the E. faecalis samples
meta_faecalis <- meta_table %>%
  filter(treatment == "E. faecalis")

# Filter the raw counts matrix to match these samples
counts_faecalis <- filtered_raw_counts_matrix[, meta_faecalis$sample_id]

# Now, split by tissue and generate a PCA for each
# Small Intestine
meta_si_faecalis <- meta_faecalis %>% filter(tissue == "small_intestine")
counts_si_faecalis <- counts_faecalis[, meta_si_faecalis$sample_id]

dds_si_batch <- DESeqDataSetFromMatrix(
  countData = counts_si_faecalis,
  colData = meta_si_faecalis,
  design = ~ batch
)
vst_si_batch <- vst(dds_si_batch, blind = TRUE)
pca_si_batch <- plotPCA(vst_si_batch, intgroup = "batch") +
  ggtitle("SI: E. faecalis Samples - Batch Effect") +
  theme_minimal() + coord_fixed()

# Large Intestine
meta_li_faecalis <- meta_faecalis %>% filter(tissue == "large_intestine")
counts_li_faecalis <- counts_faecalis[, meta_li_faecalis$sample_id]

dds_li_batch <- DESeqDataSetFromMatrix(
  countData = counts_li_faecalis,
  colData = meta_li_faecalis,
  design = ~ batch
)
vst_li_batch <- vst(dds_li_batch, blind = TRUE)
pca_li_batch <- plotPCA(vst_li_batch, intgroup = "batch") +
  ggtitle("LI: E. faecalis Samples - Batch Effect") +
  theme_minimal() + coord_fixed()

# Arrange the two PCA plots side-by-side and save
batch_effect_plot <- plot_grid(pca_si_batch, pca_li_batch, ncol = 2, labels = c("A", "B"))
save_plot("../data/R49_pca_batch_effect_visualization.jpg", batch_effect_plot, base_height = 6, base_width = 12)

# Display the final plot
print(batch_effect_plot)
```

# PCA Visualization with Batch Correction    
 
```{r}
#  ---  PCA Visualization of Treatment Effects within each Tissue (Batch Corrected) ---

# Create a full DESeqDataSet object for the entire filtered dataset
dds_full <- DESeqDataSetFromMatrix(
  countData = filtered_raw_counts_matrix,
  colData = meta_table,
  design = ~ batch + tissue + treatment + water 
)

# Apply variance stabilizing transformation
vst_full <- vst(dds_full, blind = TRUE)

# Create a design matrix that includes the biological variables of interest.
design_matrix <- model.matrix(~ tissue + treatment + water, data = colData(vst_full))

# Remove the batch effect from the VST data
batch_corrected_assay <- removeBatchEffect(assay(vst_full), batch = vst_full$batch, design = design_matrix)

# Create a new DESeqTransform object with the batch-corrected data
vst_corrected <- vst_full
assay(vst_corrected) <- batch_corrected_assay

# A function to generate a 2x2 PCA grid for a given tissue
plot_tissue_pca <- function(vst_data, target_tissue) {
  
  # Subset the batch-corrected data for the target tissue
  vst_tissue <- vst_data[, vst_data$tissue == target_tissue]
  
  # Generate PCA plots colored by different factors
  pca_by_treatment <- plotPCA(vst_tissue, intgroup = "treatment") + ggtitle(paste("PCA by Treatment -", target_tissue)) + theme_minimal() + coord_fixed()
  pca_by_water <- plotPCA(vst_tissue, intgroup = "water") + ggtitle(paste("PCA by Water -", target_tissue)) + theme_minimal() + coord_fixed()
  pca_by_batch <- plotPCA(vst_tissue, intgroup = "batch") + ggtitle(paste("PCA by Batch -", target_tissue)) + theme_minimal() + coord_fixed()
  
  # Create a combined group for a full overview within the tissue
  vst_tissue$group <- factor(paste(vst_tissue$treatment, vst_tissue$water, sep = "_"))
  pca_by_group <- plotPCA(vst_tissue, intgroup = "group") + ggtitle(paste("PCA by All Groups -", target_tissue)) + theme_minimal() + coord_fixed()
  
  # Arrange the four plots into a 2x2 grid
  plot_grid(
    pca_by_treatment, pca_by_water,
    pca_by_batch, pca_by_group,
    ncol = 2, labels = "AUTO"
  )
}

# Generate and save the PCA grid for the Small Intestine
si_pca_grid <- plot_tissue_pca(vst_corrected, "small_intestine")
save_plot("../data/R49_pca_summary_small_intestine.jpg", si_pca_grid, base_height = 10, base_width = 14)
print("Small Intestine PCA Grid:")
print(si_pca_grid)

# Generate and save the PCA grid for the Large Intestine
li_pca_grid <- plot_tissue_pca(vst_corrected, "large_intestine")
save_plot("../data/R49_pca_summary_large_intestine.jpg", li_pca_grid, base_height = 10, base_width = 14)
print("Large Intestine PCA Grid:")
print(li_pca_grid)


# The PCA results show that the treatment effects are more subtle than the overall inter-mouse variability. This is precisely the scenario where DESeq2 excels at finding the real, statistically significant signals.
```

# DE analysis and shrinking 

```{r}
# ---  Differential Expression Analysis with Batch Correction ---
# This function automates the process of running DESeq2 for a specific contrast
# while accounting for the batch effect.

run_deseq_with_batch_correction <- function(full_counts, full_meta, target_tissue, analysis_type) {
  
  # Determine which samples and which variable to use for the contrast
  if (analysis_type == "Colonization") {
    # Compare PBS vs E. faecalis within regular water samples
    meta_subset <- full_meta %>% filter(tissue == target_tissue, water == "regular_water")
    design_formula <- ~ batch + treatment
    contrast_info <- c("treatment", "E. faecalis", "PBS")
  } else if (analysis_type == "Sucrose") {
    # Compare sucrose vs regular water within E. faecalis samples
    meta_subset <- full_meta %>% filter(tissue == target_tissue, treatment == "E. faecalis")
    design_formula <- ~ batch + water
    contrast_info <- c("water", "sucrose_water", "regular_water")
  } else {
    stop("Invalid analysis_type. Choose 'Colonization' or 'Sucrose'.")
  }
  
  # Subset the counts matrix to match the selected metadata
  counts_subset <- full_counts[, meta_subset$sample_id]
  
  # Create the DESeqDataSet object with batch in the design
  dds <- DESeqDataSetFromMatrix(
    countData = counts_subset,
    colData = meta_subset,
    design = design_formula
  )
  
  # Run the DESeq2 analysis
  dds <- DESeq(dds)
  
  # Get the results for the specific contrast
  results <- results(dds, contrast = contrast_info)
  
  # Apply LFC shrinkage for more accurate fold changes
  shrunken_results <- lfcShrink(dds, contrast = contrast_info, type = "ashr")
  
  return(shrunken_results)
}
```

# add gene symbols  

```{r}
# ---  Annotate and Save DESeq2 Results ---

# A helper function to convert a DESeqResults object to an annotated dataframe
annotate_results <- function(deseq_results) {
  as.data.frame(deseq_results) %>%
    rownames_to_column("ensembl_version") %>%
    mutate(
      # Clean the Ensembl ID by removing the version number for mapping
      ensembl_id = str_remove(ensembl_version, "\\..*"),
      # Map the clean Ensembl IDs to gene symbols
      symbol = mapIds(
        org.Mm.eg.db,
        keys = ensembl_id,
        column = "SYMBOL",
        keytype = "ENSEMBL",
        multiVals = "first"
      )
    ) %>%
    # Reorder columns for better readability
    select(ensembl_id, symbol, everything())
}


# Run all four analyses
# Colonization Effect
shrunken_si_col <- run_deseq_with_batch_correction(filtered_raw_counts_matrix, meta_table, "small_intestine", "Colonization")
shrunken_li_col <- run_deseq_with_batch_correction(filtered_raw_counts_matrix, meta_table, "large_intestine", "Colonization")

# Sucrose Effect
shrunken_si_suc <- run_deseq_with_batch_correction(filtered_raw_counts_matrix, meta_table, "small_intestine", "Sucrose")
shrunken_li_suc <- run_deseq_with_batch_correction(filtered_raw_counts_matrix, meta_table, "large_intestine", "Sucrose")

# Annotate each of the results dataframes
annotated_si_col <- annotate_results(shrunken_si_col)
annotated_li_col <- annotate_results(shrunken_li_col)
annotated_si_suc <- annotate_results(shrunken_si_suc)
annotated_li_suc <- annotate_results(shrunken_li_suc)

# Save the ANNOTATED shrunken results to CSV files
write_csv(annotated_si_col, "../data/R49_shrunken_results_si_colonization.csv")
write_csv(annotated_li_col, "../data/R49_shrunken_results_li_colonization.csv")
write_csv(annotated_si_suc, "../data/R49_shrunken_results_si_sucrose.csv")
write_csv(annotated_li_suc, "../data/R49_shrunken_results_li_sucrose.csv")

# Print a message to confirm completion
print("DESeq2 analyses complete. Annotated shrunken results have been saved to CSV files.")


```

# volcano plots 

```{r}
# --- 1. Load the Annotated DESeq2 Results ---
# These are the CSV files you created in the previous step.
# Make sure the file paths are correct.
results_si_col <- read_csv("../data/R49_shrunken_results_si_colonization.csv")
results_li_col <- read_csv("../data/R49_shrunken_results_li_colonization.csv")
results_si_suc <- read_csv("../data/R49_shrunken_results_si_sucrose.csv")
results_li_suc <- read_csv("../data/R49_shrunken_results_li_sucrose.csv")


# --- 2. Create a Reusable Volcano Plot Function ---
# This function takes a results dataframe and a title, and returns a ggplot object.

create_volcano_plot <- function(results_df, plot_title) {
  
  # Add a column to categorize genes as 'Upregulated', 'Downregulated', or 'Not significant'
  # based on the specified thresholds.
  results_df <- results_df %>%
    mutate(
      significance = case_when(
        padj < 0.05 & log2FoldChange > 1  ~ "Upregulated",
        padj < 0.05 & log2FoldChange < -1 ~ "Downregulated",
        TRUE                             ~ "Not significant"
      ),
      # Create a label column that only contains the symbol for significant genes
      label = if_else(significance != "Not significant", symbol, NA_character_)
    )

  # Generate the plot
  ggplot(results_df, aes(x = log2FoldChange, y = -log10(padj))) +
    # Add points for all genes, colored by their significance status
    geom_point(aes(color = significance), alpha = 0.6, size = 1.5) +
    
    # Use ggrepel to add non-overlapping labels for the significant genes
    geom_text_repel(aes(label = label),
                    size = 3.5,
                    box.padding = 0.5,
                    max.overlaps = Inf, # Allow all labels to be plotted
                    na.rm = TRUE) + # Ignore genes without a label
    
    # Define custom colors for the points
    scale_color_manual(values = c("Upregulated" = "red", "Downregulated" = "blue", "Not significant" = "grey")) +
    
    # Add dashed lines for the significance cutoffs
    geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
    geom_vline(xintercept = 1, linetype = "dashed") +
    geom_vline(xintercept = -1, linetype = "dashed") +
    
    # Set plot titles and axis labels
    labs(
      title = plot_title,
      x = "Log2 Fold Change",
      y = "-log10(Adjusted P-value)"
    ) +
    
    # Apply a clean theme and adjust the legend
    theme_minimal(base_size = 14) +
    theme(legend.position = "none") # Hide the legend for a cleaner grid
}


# --- 3. Generate Each of the Four Volcano Plots ---

# Create each plot by calling the function with the corresponding dataframe and title
p_si_col <- create_volcano_plot(results_si_col, "SI: Colonization Effect")
p_li_col <- create_volcano_plot(results_li_col, "LI: Colonization Effect")
p_si_suc <- create_volcano_plot(results_si_suc, "SI: Sucrose Effect")
p_li_suc <- create_volcano_plot(results_li_suc, "LI: Sucrose Effect")


# --- 4. Arrange the Plots into a 2x2 Grid ---
# Use cowplot's plot_grid to combine the four plots into a single figure.

final_volcano_grid <- plot_grid(
  p_si_col, p_si_suc,
  p_li_col, p_li_suc,
  ncol = 2,
  labels = "AUTO"
)

# Save the combined figure as a JPG file
save_plot("../data/R49_volcano_plots_summary.jpg", final_volcano_grid, base_height = 10, base_width = 14)

# Display the final plot
print(final_volcano_grid)

# Colonizing germ-free mice with E. faecalis will "wake up" the naive gut. The small intestine will focus on immediate defense by beefing up the mucus layer and producing bacteria-coating IgA antibodies. The large intestine, where the bacteria will primarily reside, will undergo a much more profound transformation, building out its immune infrastructure and physically remodeling its lining to learn how to permanently host a bacterial resident.
```

# GSEA

```{r}
# --- Gene Rank Preparation Function ---
# This function is updated to work with data that already contains a 'symbol' column.
prepare_ranked_list <- function(deseq_results) {
  
  # The input `deseq_results` is a dataframe/tibble from read_csv.
  # We assume it contains 'symbol', 'log2FoldChange', and 'pvalue' columns.
  results_df <- deseq_results %>%
    # Ensure symbol, pvalue and log2FoldChange are not NA
    filter(!is.na(symbol) & !is.na(pvalue) & !is.na(log2FoldChange)) %>%
    
    # *** Create a custom ranking metric ***
    # This metric combines the direction (sign of LFC) and significance (-log10 of p-value)
    mutate(rank_metric = sign(log2FoldChange) * -log10(pvalue))

  # Handle cases where one gene symbol maps to multiple entries.
  # We'll keep the one with the largest absolute rank_metric value.
  results_df <- results_df %>%
    group_by(symbol) %>%
    slice_max(order_by = abs(rank_metric), n = 1, with_ties = FALSE) %>%
    ungroup()

  # Create the final ranked list: a named vector
  ranked_list <- results_df$rank_metric
  names(ranked_list) <- results_df$symbol
  
  # Sort the list in descending order
  ranked_list <- sort(ranked_list, decreasing = TRUE)
  
  # Remove any NA values from the ranking metric
  ranked_list <- ranked_list[!is.na(ranked_list)]
  
  return(ranked_list)
}
```

```{r}
# --- Prepare Gene Sets ---
# Fetch the Hallmark (H) gene sets for mouse from the msigdbr database.
hallmark_pathways <- msigdbr(species = "Mus musculus", category = "H") %>%
  split(x = .$gene_symbol, f = .$gs_name)

# --- Prepare Gene Ranks for all four conditions ---
ranks_si_col <- prepare_ranked_list(results_si_col)
ranks_li_col <- prepare_ranked_list(results_li_col)
ranks_si_suc <- prepare_ranked_list(results_si_suc)
ranks_li_suc <- prepare_ranked_list(results_li_suc)


# --- Run GSEA for all four conditions ---
set.seed(42) # for reproducibility
fgsea_res_si_col <- fgsea(pathways = hallmark_pathways, stats = ranks_si_col, minSize=15, maxSize=500, nPermSimple = 10000)
fgsea_res_li_col <- fgsea(pathways = hallmark_pathways, stats = ranks_li_col, minSize=15, maxSize=500, nPermSimple = 10000)
fgsea_res_si_suc <- fgsea(pathways = hallmark_pathways, stats = ranks_si_suc, minSize=15, maxSize=500, nPermSimple = 10000)
fgsea_res_li_suc <- fgsea(pathways = hallmark_pathways, stats = ranks_li_suc, minSize=15, maxSize=500, nPermSimple = 10000)

# --- Process and Visualize Results ---
# Combine all results into one dataframe with identifying columns
all_fgsea_res <- bind_rows(
  fgsea_res_si_col %>% as_tibble() %>% mutate(condition = "SI - Colonization"),
  fgsea_res_li_col %>% as_tibble() %>% mutate(condition = "LI - Colonization"),
  fgsea_res_si_suc %>% as_tibble() %>% mutate(condition = "SI - Sucrose"),
  fgsea_res_li_suc %>% as_tibble() %>% mutate(condition = "LI - Sucrose")
)

# Filter for significant pathways and select top N up/down for each condition
top_pathways <- all_fgsea_res %>%
  filter(padj < 0.05) %>%
  mutate(direction = ifelse(NES > 0, "Upregulated", "Downregulated")) %>%
  group_by(condition, direction) %>%
  slice_max(order_by = abs(NES), n = 10) %>% # Get top 10 in each direction
  ungroup()

# --- Plotting Function ---
# This function creates a diverging bar plot for a single condition
create_diverging_plot <- function(data, plot_condition) {
  
  plot_data <- data %>%
    filter(condition == plot_condition)
  
  if (nrow(plot_data) == 0) {
    return(ggplot() + theme_void() + labs(title = plot_condition, subtitle = "No significant pathways"))
  }
  
  plot_data <- plot_data %>%
    mutate(
      pathway_clean = pathway %>%
        str_replace("HALLMARK_", "") %>%    # Remove the prefix.
        str_to_title() %>%                  # Convert to Title Case.
        str_replace_all("_", " ") %>%     # Replace underscores with spaces.
        str_wrap(width = 48)                # Wrap long names for readability.
    ) %>%
    mutate(pathway_clean = reorder(pathway_clean, NES))

  ggplot(plot_data, aes(x = NES, y = pathway_clean, fill = direction)) +
    geom_col(color = "black") +
    scale_fill_manual(values = c("Upregulated" = "#E64B35", "Downregulated" = "#4DBBD5"), name = "Direction") +
    labs(
      title = plot_condition,
      x = "Normalized Enrichment Score (NES)",
      y = ""
    ) +
    geom_vline(xintercept = 0, linetype = "dashed") +
    theme_bw(base_size = 12) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      panel.grid.major.y = element_blank(),
      panel.grid.minor.x = element_blank(),
      axis.text.y = element_text(size = 9)
    )
}

# --- Generate the Four Plots ---
plot_si_col <- create_diverging_plot(top_pathways, "SI - Colonization")
plot_li_col <- create_diverging_plot(top_pathways, "LI - Colonization")
plot_si_suc <- create_diverging_plot(top_pathways, "SI - Sucrose")
plot_li_suc <- create_diverging_plot(top_pathways, "LI - Sucrose")

# --- Combine Plots into a 2x2 Grid ---
final_plot <- (plot_si_col | plot_li_col) / (plot_si_suc | plot_li_suc) +
  plot_annotation(
    title = 'Hallmark Gene Set Enrichment Analysis',
    subtitle = 'Top 10 Enriched Pathways by Condition',
    theme = theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
  )

# --- Save and Display the Final Plot ---
ggsave("../data/R49_gsea_hallmark_grid.jpg", final_plot, width = 18, height = 14, dpi = 300)
print(final_plot)

# what the SI gsea and the volcano shows 
# This finding suggests a more nuanced strategy by the small intestine. Instead of a "brute-force" approach of just making more slime, it's mounting a targeted, "special forces" operation. By activating B-cells, it's preparing to produce secretory IgA antibodies. IgA acts like a coat of paint, specifically tagging the E. faecalis to prevent it from sticking to the gut wall and neutralizing it without causing excessive inflammation. This is a much more elegant way to manage a new resident than simply launching an all-out innate attack.

# and about the LI
#Unlike the small intestine, which used its energy to fuel a targeted B-cell immune response, the large intestine is in a defensive state of survival and reconstruction. The colonization has triggered a powerful inflammatory cascade that is causing cellular stress (S100g). In response, the LI has shut down all normal business (cell growth, metabolism) to conserve energy and is now using that energy for a drastic and stressful process of remodeling its own lining (EMT, Apoptosis) to cope with the new resident.The strong signal from genes like Vimentin (Vim), Collagen (Col3a1), and others involved in the extracellular matrix provides direct, single-gene evidence that validates the GSEA finding of Epithelial-to-Mesenchymal Transition (EMT).This confirms that the large intestine's primary response is not an active immune attack, but a deep, structural remodeling and wound-healing process in the face of the stress caused by the new bacterial colonization.
```

Metabolism: The small intestine is boosting its energy production to fuel an active defense, while the large intestine is shutting down its normal metabolism, indicating a more severe level of stress.

Cell Growth: Both parts of the gut are halting cell division to focus on the immediate threat.

Tissue Response: The large intestine is mounting a more aggressive and complex response, leading to significant remodeling of the gut wall itself.

The GSEA data provides the molecular "receipts" for our hypothesis:

The Small Intestine is paying for its "meet-and-greet" defense with a massive surge in energy production.

The Large Intestine is undertaking a deep, stressful, and inflammatory "reconstruction" to prepare for its long-term role as a host.

## B cell related genesets

```{r}
# --- Prepare Gene Sets ---
# Fetch the C8 cell type signature gene sets for mouse.
C7_pathways_all <- msigdbr(species = "Mus musculus", category = "C7", subcollection = 'IMMUNESIGDB')

# Filter this collection to get the B-cell specific response signatures.
b_cell_C7_pathways_filtered <- C7_pathways_all %>%
  filter(str_detect(gs_name, "B_CELL"))

#Are your B-cells just activated, or are they differentiating into full-blown antibody factories?

# What These C7 Gene Sets Represent
# Think of a B-cell's life like a career path.
# 
# Spleen B-Cell: This is like an experienced professional. It's mature, circulates, and is ready for a job, but it isn't fully committed to a single, massive project yet.
# 
# Bone Marrow Plasma Cell: This is the specialist who has taken on that one massive project. It has stopped circulating, set up a factory (often in the bone marrow), and is now dedicated 100% to producing and secreting vast quantities of antibodies. This is the final, most potent stage of a B-cell's life.
# 
# The two gene sets you found define the genetic differences between these two states:
# 
# ..._UP set: Genes that are higher in the spleen B-cell. These are genes for patrolling, signaling, and being ready for activation.
# 
# ..._DN set: Genes that are lower in the spleen B-cell. This is the crucial part—this means these genes are higher in the plasma cell. This list includes the machinery for massive protein synthesis and secretion.

# Convert the filtered dataframe into the list format required by fgsea.
b_cell_c7_pathways <- b_cell_C7_pathways_filtered %>%
  split(x = .$gene_symbol, f = .$gs_name)

# --- Prepare Gene Ranks for the Small Intestine ---
ranks_si_col <- prepare_ranked_list(results_si_col)
```


```{r}
# --- Run GSEA with the B-Cell C7 Signature Pathways ---
set.seed(42)
fgsea_res_bcell_c7 <- fgsea(
  pathways = b_cell_c7_pathways, 
  stats = ranks_si_col, 
  minSize=15, 
  maxSize=500, 
  nPermSimple = 10000
)

# --- Process and Visualize Results ---
# Filter for the most significant pathways to plot.
top_bcell_c7_pathways <- fgsea_res_bcell_c7 %>%
  as_tibble() %>%
  filter(padj < 0.05)
```


```{r}
# --- Plotting Function ---
# Cleans up the C7 pathway names for better readability.
plot_data_c7 <- top_bcell_c7_pathways %>%
  mutate(
    pathway_clean = pathway %>%
      str_remove("GSE\\d+_") %>%
      str_replace("_VS_", " vs ") %>%
      str_replace("_DN", ": Down") %>%
      str_replace("_UP", ": Up") %>%
      str_to_sentence() %>%
      str_replace_all("_", " ") %>%
      str_wrap(width = 60)
  ) %>%
  mutate(
    direction = ifelse(NES > 0, "Upregulated", "Downregulated"),
    pathway_clean = reorder(pathway_clean, NES)
  )

# Create the plot
bcell_c7_plot <- ggplot(plot_data_c7, aes(x = NES, y = pathway_clean, fill = direction)) +
  geom_col(color = "black") +
  scale_fill_manual(values = c("Upregulated" = "#E64B35", "Downregulated" = "#4DBBD5"), name = "Direction") +
  labs(
    title = "Top B-Cell Immunologic Signatures in the Small Intestine",
    subtitle = "Enrichment upon E. faecalis Colonization (C7 Gene Sets)",
    x = "Normalized Enrichment Score (NES)",
    y = ""
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size=16),
    plot.subtitle = element_text(hjust = 0.5),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.text.y = element_text(size = 10)
  )

# --- Save and Display the Final Plot ---
ggsave("../data/R49_gsea_bcell_c7_signatures_plot.jpg", bcell_c7_plot, width = 10, height = 4, dpi = 300)
print(bcell_c7_plot)

# Breaking it Down:

# This gene set contains genes that are normally UPregulated in circulating spleen B-cells compared to stationary plasma cells.
# 
# Your data shows that these "spleen B-cell" genes are being DOWNregulated in your colonized mice (a negative enrichment score).
# 
# The Conclusion: If the genes that define a spleen B-cell are going down, it means your cells are moving away from that state. They are becoming less like circulating B-cells and more like plasma cells.


#This result provides strong evidence that the B-cells in the small intestine are not just activated—they are undergoing terminal differentiation into antibody-secreting plasma cells.

# Think of it this way: to become a dedicated antibody factory (a plasma cell), a B-cell has to shut down the genetic programs for being a mobile scout (a spleen B-cell). It turns off genes for patrolling and responding to new signals and turns on the massive machinery needed for protein production. Your GSEA result has captured this "shutting down" process perfectly.
# 
# This aligns with everything else you've seen:
# 
# Volcano Plot: Shows a massive B-cell signature.
# 
# Hallmark GSEA: Shows high metabolic activity (Oxidative Phosphorylation) needed to fuel the energy-intensive process of antibody production.
# 
# This C7 GSEA: Provides the final piece of the puzzle, showing that these metabolically active B-cells are committing to becoming plasma cells.
```
### enrichment plot

```{r}
# Define the exact name of the pathway of interest.
target_pathway_name <- "GSE39916_B_CELL_SPLEEN_VS_PLASMA_CELL_BONE_MARROW_UP"

# --- Create and Save the Enrichment Plot ---
# Generate the GSEA enrichment plot for the single target pathway.
enrichment_plot <- plotEnrichment(
  pathway = b_cell_c7_pathways[[target_pathway_name]],
  stats = ranks_si_col
) + 
  labs(
    title = "Enrichment Plot",
    subtitle = "Genes downregulated in Spleen B-Cells vs. Plasma Cells",
    x = "Rank in Gene List",
    y = "Enrichment Score"
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

# --- Save and Display the Final Plot ---
ggsave("../data/R49_gsea_enrichment_plot_c7_signature.jpg", enrichment_plot, width = 8, height = 6, dpi = 300)
print(enrichment_plot)
```

# download the M7 genesets

```{r}
# --- Iteratively Run GSEA on all GMT files in a Folder ---
# This section programmatically finds all .gmt files in a directory,
# runs GSEA for each, and combines the results.

# Define the path to the folder containing your .gmt files.
geneset_folder <- "../data/geneset/" 

# Check if the directory exists
if (!dir.exists(geneset_folder)) {
  stop("The specified geneset folder does not exist: ", geneset_folder)
}

# Get a list of all files ending with .gmt in the specified folder.
gmt_files <- list.files(geneset_folder, pattern = "\\.gmt$", full.names = TRUE)

if (length(gmt_files) == 0) {
    stop("No .gmt files found in the directory: ", geneset_folder)
}

# Use purrr::map_dfr to iterate over the files, run GSEA, and row-bind the results.
all_fgsea_results <- map_dfr(gmt_files, ~{
  # Load the pathways from the current .gmt file.
  current_pathways <- gmtPathways(.x)
  
  # Run fgsea.
  fgsea(
    pathways = current_pathways,
    stats = ranks_si_col,
    minSize = 5,
    maxSize = 500,
    nPermSimple = 10000
  )
})
```


```{r}
# --- Process and Visualize Combined Results ---
# Filter the combined results for the most significant pathways to plot.
top_combined_pathways <- all_fgsea_results %>%
  as_tibble() %>%
  filter(padj < 0.05) %>%
  mutate(direction = ifelse(NES > 0, "Upregulated", "Downregulated")) %>%
  group_by(direction) %>%
  slice_max(order_by = abs(NES), n = 31) %>% # Show top 15 from each direction
  ungroup()

# --- Plotting Function ---
# Cleans up the pathway names for better readability.
plot_data_combined <- top_combined_pathways %>%
  mutate(
    pathway_clean = pathway %>%
      str_remove("CUI_B_CELL_") %>%
      str_to_sentence() %>%
      str_replace_all("_", " ") %>%
      str_wrap(width = 40)
  ) %>%
  mutate(pathway_clean = reorder(pathway_clean, NES))

# Create the plot
bcell_combined_plot <- ggplot(plot_data_combined, aes(x = NES, y = pathway_clean, color = direction)) +
  # Add the horizontal line segment from 0 to the NES value
  geom_segment(aes(x = 0, xend = NES, y = pathway_clean, yend = pathway_clean), linewidth = 0.5) +
  # Add the point at the end of the line
  geom_point(aes(size = -log10(padj))) + 
  scale_color_manual(values = c("Upregulated" = "#E64B35", "Downregulated" = "#4DBBD5"), name = "Direction") +
  scale_size_continuous(name = "-log10(Adjusted P-value)", range = c(2, 8)) + # Control the range of point sizes
  labs(
    title = "Top B-Cell Response Signatures in the Small Intestine",
    subtitle = "Combined GSEA Results from Custom Gene Sets",
    x = "Normalized Enrichment Score (NES)",
    y = ""
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size=16),
    plot.subtitle = element_text(hjust = 0.5),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.text.y = element_text(size = 10)
  )

# --- Save and Display the Final Plot ---
ggsave("../data/R49_gsea_bcell_combined_plot.jpg", bcell_combined_plot, width = 8, height = 8, dpi = 300)
print(bcell_combined_plot)

# 1. A Dominant Interferon "Alarm" is Sounding
# This is the most powerful signal in your plot. You see strong enrichment for the response signatures of multiple interferons: Ifna1, Ifnb, Ifne, Ifnk, and Ifng.
# 
# Why it matters: This confirms your earlier Hallmark GSEA result with much greater precision. It tells you that both Type I (alpha, beta, etc.) and Type II (gamma) interferons are major players. This type of signal is critical for directing B-cells to class-switch their antibodies and mature into a more potent fighting force.
# 
# 2. The Environment is Primed for Antibody Production
# You see strong enrichment for cytokines that are classic drivers of B-cell differentiation into antibody-secreting plasma cells.
# 
# Il10 response up and Il21 response up: These are two of the most important cytokines for the final stages of B-cell maturation. Seeing these signatures confirms that the local environment is providing the exact signals needed to push the activated B-cells to become antibody factories, which perfectly supports your findings from the C7 gene sets.
# 
# 3. You Are Seeing a Complex, "In-Vivo" Response
# This addresses your excellent question about seeing both "UP" and "DN" signatures for the same cytokine. Look at Interferon Alpha (Ifna1):
# 
# Ifna1 response up: This gene set is significantly enriched.
# 
# Ifna1 response dn: This gene set is also significantly enriched.
# 
# This is not a contradiction. It's a window into complex, real-world biology.
# 
# What it means: The "UP" and "DN" gene sets were defined in a clean lab experiment with only B-cells and IFN-alpha. Your experiment is in a complex gut. Your result shows that the B-cells are definitely "hearing" the IFN-alpha signal (activating the "UP" genes). However, the mix of all the other cytokines (Il10, Il21, etc.) is overriding IFN-alpha's normal ability to turn off its "DN" genes, causing them to be expressed instead. This is a sign of complex signal integration.

```

