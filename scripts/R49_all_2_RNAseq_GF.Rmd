---
title: "All two batches of the RNA-seq of the GF mouse experiments"
output: html_document
date: "2025-10-15"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(ggpubr)
library(limma) # <-- Added for removeBatchEffect
library(edgeR)
library(DESeq2)
library(ggrepel)
library(cowplot)
library(patchwork)
library(ashr)
library(fgsea)       # For GSEA
library(msigdbr)     # To get MSigDB gene sets
library(AnnotationDbi)
library(org.Mm.eg.db)
library(ggupset)
library(pheatmap)      # For creating the heatmap
library(viridis)  
library(RColorBrewer) 
library(gridExtra)
library(tidyverse)
library(gt)
```

# merge counts and meta data 

```{r}
# --- 1. Load Raw Count Data ---
# Read the two raw count matrices from the uploaded TSV files.
# The `read_tsv` function from the readr package (part of tidyverse) is used.
counts_b1 <- read_tsv("../data/raw_counts_matrix.tsv")
counts_b2 <- read_tsv("../data/raw_counts_matrix_batch2.tsv")

# --- 2. Merge Count Matrices ---
# The goal is to combine the two matrices into one, aligning genes by their ID.
# A full_join ensures that all genes from both batches are kept.
merged_counts_df <- full_join(counts_b1, counts_b2, by = "Geneid") %>%
  # After joining, genes present in only one batch will have NAs in the columns
  # from the other batch. Replace these NAs with 0.
  mutate(across(where(is.numeric), ~replace_na(., 0))) %>%
  # It's good practice to make the gene IDs the row names for analysis matrices.
  column_to_rownames("Geneid")

# --- 3. Create the Combined Metadata Table ---
# This step involves parsing the complex sample names to extract experimental variables.

# Get all the sample names (column names) from the merged matrix
all_sample_ids <- colnames(merged_counts_df)
# Get the sample names from each batch to assign a 'batch' variable
b1_sample_ids <- colnames(counts_b1)[-1]
b2_sample_ids <- colnames(counts_b2)[-1]

# Create the metadata table
meta_table <- tibble(sample_id = all_sample_ids) %>%
  mutate(
    # Assign a batch label to each sample
    batch = case_when(
      sample_id %in% b1_sample_ids ~ "batch1",
      sample_id %in% b2_sample_ids ~ "batch2"
    ),
    
    # Extract the tissue type (LI or SI) from the sample name,
    # accounting for different naming conventions in batch 1 and batch 2.
    tissue = case_when(
      str_detect(sample_id, "_LI_") | str_starts(sample_id, "LI_") ~ "large_intestine",
      str_detect(sample_id, "_SI_") | str_starts(sample_id, "SI_") ~ "small_intestine"
    ),
    
    # Extract the mouse group identifier (e.g., "1_10", "4_3")
    mouse_group = str_extract(sample_id, "\\d+_\\d+"),
    
    # Assign treatment and water based on the first digit of the mouse group
    treatment = case_when(
      str_starts(mouse_group, "1_") ~ "E. faecalis",
      str_starts(mouse_group, "2_") ~ "E. faecalis",
      str_starts(mouse_group, "3_") ~ "PBS",
      str_starts(mouse_group, "4_") ~ "PBS"
    ),
    
    water = case_when(
      str_starts(mouse_group, "1_") ~ "sucrose_water",
      str_starts(mouse_group, "2_") ~ "regular_water",
      str_starts(mouse_group, "3_") ~ "sucrose_water",
      str_starts(mouse_group, "4_") ~ "regular_water"
    )
  )

# --- 4. Save the New Files ---
# The merged data is now ready to be used in downstream analyses like DESeq2.

# Save the merged raw counts matrix to a new TSV file
# We convert the rownames back to a column for saving.
as.data.frame(merged_counts_df) %>%
  rownames_to_column("Geneid") %>%
  write_tsv("../data/R49_merged_raw_counts.tsv")

# Save the new metadata table to a CSV file
write_csv(meta_table, "../data/R49_combined_meta_table.csv")

# --- 5. Display Summary ---
# Print the dimensions and first few rows to verify the results.
print("Dimensions of merged count matrix:")
print(dim(merged_counts_df))
print("Head of new metadata table:")
print(head(meta_table))

# how many mice in each treatment group two batches combined
meta_table %>% 
  filter(treatment == 'E. faecalis') |> 
  count(treatment, water, tissue, batch) |> 
  arrange(tissue,  water, treatment, batch)
```

## the tally up of the samples count 

```{r}
summarize_sample_counts <- function(full_meta, target_tissue) {
  
  summary_table <- full_meta %>%
    # Filter for the specific tissue
    filter(tissue == target_tissue) %>%
    
    # Count samples for every combination of treatment, water, and batch
    count(treatment, water, batch) %>%
    
    # Pivot so batch1 and batch2 are columns
    # Fills with 0 if a combination doesn't exist (like PBS in batch2)
    pivot_wider(names_from = batch, values_from = n, values_fill = 0) %>%
    
    # Create the "batch1 + batch2" string format
    mutate(count_summary = paste0(batch1, " + ", batch2)) %>%
    
    # Keep only the columns we need for the final table
    select(treatment, water, count_summary) %>%
    
    # Pivot so water types are columns
    pivot_wider(names_from = water, values_from = count_summary) %>%
    
    # Order the rows as requested: E. faecalis first, then PBS
    mutate(treatment = factor(treatment, levels = c("E. faecalis", "PBS"))) %>%
    arrange(treatment) %>%
    
    # Order the columns as requested: regular_water first, then sucrose_water
    # Using any_of() prevents an error if a column (e.g., sucrose_water) is missing
    select(treatment, any_of(c("regular_water", "sucrose_water")))
  
  return(summary_table)
}

# ---  Usage ---

# 1. Generate the table for the Large Intestine
li_summary_data <- summarize_sample_counts(meta_table, "large_intestine")

print("Large Intestine Summary:")
li_summary_table <- li_summary_data %>%
  gt() %>%
  tab_header(
    title = "Large Intestine Sample Summary",
    subtitle = "Counts: batch1 + batch2"
  ) %>%
  cols_label(
    treatment = "Treatment",
    regular_water = "Regular Water",
    sucrose_water = "Sucrose Water"
  )

print(li_summary_table)

# 2. Generate the table for the Small Intestine
si_summary_data <- summarize_sample_counts(meta_table, "small_intestine")

print("Small Intestine Summary:")
si_summary_table <- si_summary_data %>%
  gt() %>%
  tab_header(
    title = "Small Intestine Sample Summary",
    subtitle = "Counts: batch1 + batch2"
  ) %>%
  cols_label(
    treatment = "Treatment",
    regular_water = "Regular Water",
    sucrose_water = "Sucrose Water"
  )

print(si_summary_table)
```


# data-driven filtering 

```{r}
raw_counts_matrix <- merged_counts_df %>% as.matrix()
cpm_matrix <- cpm(raw_counts_matrix)

# ---  Calculate Genes Kept at Different Thresholds ---
# Define the range of CPM thresholds to test.
cpm_thresholds <- seq(0.5, 10, by = 0.5)

# This function will count how many genes pass the filter for a given threshold.
# The rule is: at least 3 samples must be >= the threshold.
count_genes_kept <- function(threshold, cpm_data) {
  # 'apply' goes through each row (gene) of the matrix.
  # For each row, it checks how many sample values are >= the threshold.
  # The result is a vector of TRUE/FALSE for each gene.
  genes_to_keep <- apply(cpm_data, 1, function(gene_row) {
    sum(gene_row >= threshold) >= 4
  })
  # Finally, sum up the TRUE values to get the total number of genes kept.
  return(sum(genes_to_keep))
}

# Apply the function to every threshold in our sequence.
genes_left <- map_int(cpm_thresholds, ~count_genes_kept(., cpm_matrix))

# Combine the thresholds and the gene counts into a results table.
results_df <- tibble(
  cpm_threshold = cpm_thresholds,
  genes_remaining = genes_left
)

# Create the plot.
ggplot(results_df, aes(x = cpm_threshold, y = genes_remaining)) +
  geom_line(color = "dodgerblue", size = 1) +
  geom_point(color = "dodgerblue", size = 2) +
  labs(
    title = "Effect of CPM Threshold on Gene Filtering",
    x = "CPM Threshold (gene kept if expressed in at least 4 samples)",
    y = "Number of Genes Remaining"
  ) +
  theme_minimal() +
  # Add grid lines for easier reading of values.
  theme(panel.grid.major = element_line(color = "grey85"),
        panel.grid.minor = element_line(color = "grey90"))
# 3 is a good elbow point
```

# filter on the CPM

```{r}
# --- Filter Lowly Expressed Genes based on CPM ---
# Remove genes with very low counts across all samples before analysis to improve statistical power.

# Calculate library sizes (total reads per sample)
library_sizes <- colSums(merged_counts_df)

# Calculate CPM (Counts Per Million)
cpm_matrix <- t(t(merged_counts_df) / library_sizes * 1e6)

# Define the filtering threshold based on the elbow plot
cpm_threshold <- 3
# A common rule is to keep genes that are expressed above the threshold in at least
# the number of samples in the smallest experimental group. We'll use 4. 
min_samples <- 4

# Identify genes that meet the criteria
genes_to_keep <- rowSums(cpm_matrix >= cpm_threshold) >= min_samples

# Filter the original raw counts matrix to keep only these genes
filtered_raw_counts_matrix <- merged_counts_df[genes_to_keep, ]
```

# batch effects?

The goal of checking for a batch effect is to see if the technical variation between sequencing runs is driving the differences in your data, rather than the biological variation you're interested in.

If you were to include the PBS samples (which are only in batch 1), you would be looking at a confounded experiment. Any separation you see in a PCA plot wouldn't be clear. Is the separation because of the biological difference between PBS and E. faecalis, or is it because of the technical difference between batch 1 and batch 2? You can't tell them apart.

By creating a dataset that only contains the E. faecalis-treated samples from both batches, you hold the biology constant and can cleanly visualize the technical variable you care about: the batch.

```{r}
# --- Visualize Batch Effects using PCA ---
# To check for batch effects, it's best to use samples with the same biological condition
# that are present in both batches. In this case, it's the 'E. faecalis' treated samples.

# Filter the metadata to get only the E. faecalis samples
meta_faecalis <- meta_table %>%
  filter(treatment == "E. faecalis")

# Filter the raw counts matrix to match these samples
counts_faecalis <- filtered_raw_counts_matrix[, meta_faecalis$sample_id]

# Now, split by tissue and generate a PCA for each
# Small Intestine
meta_si_faecalis <- meta_faecalis %>% filter(tissue == "small_intestine")
counts_si_faecalis <- counts_faecalis[, meta_si_faecalis$sample_id]

dds_si_batch <- DESeqDataSetFromMatrix(
  countData = counts_si_faecalis,
  colData = meta_si_faecalis,
  design = ~ batch
)
vst_si_batch <- vst(dds_si_batch, blind = TRUE)
pca_si_batch <- plotPCA(vst_si_batch, intgroup = "batch") +
  ggtitle("SI: E. faecalis Samples - Batch Effect") +
  theme_minimal() + coord_fixed()

# Large Intestine
meta_li_faecalis <- meta_faecalis %>% filter(tissue == "large_intestine")
counts_li_faecalis <- counts_faecalis[, meta_li_faecalis$sample_id]

dds_li_batch <- DESeqDataSetFromMatrix(
  countData = counts_li_faecalis,
  colData = meta_li_faecalis,
  design = ~ batch
)
vst_li_batch <- vst(dds_li_batch, blind = TRUE)
pca_li_batch <- plotPCA(vst_li_batch, intgroup = "batch") +
  ggtitle("LI: E. faecalis Samples - Batch Effect") +
  theme_minimal() + coord_fixed()

# Arrange the two PCA plots side-by-side and save
batch_effect_plot <- plot_grid(pca_si_batch, pca_li_batch, ncol = 2, labels = c("A", "B"))
save_plot("../data/R49_pca_batch_effect_visualization.jpg", batch_effect_plot, base_height = 6, base_width = 12)

# Display the final plot
print(batch_effect_plot)
```

# PCA Visualization with Batch Correction    
 
```{r}
#  ---  PCA Visualization of Treatment Effects within each Tissue (Batch Corrected) ---

# Create a full DESeqDataSet object for the entire filtered dataset
dds_full <- DESeqDataSetFromMatrix(
  countData = filtered_raw_counts_matrix,
  colData = meta_table,
  design = ~ batch + tissue + treatment + water 
)

# Apply variance stabilizing transformation
vst_full <- vst(dds_full, blind = TRUE)

# Create a design matrix that includes the biological variables of interest.
design_matrix <- model.matrix(~ tissue + treatment + water, data = colData(vst_full))

# Remove the batch effect from the VST data
batch_corrected_assay <- removeBatchEffect(assay(vst_full), batch = vst_full$batch, design = design_matrix)

# Create a new DESeqTransform object with the batch-corrected data
vst_corrected <- vst_full
assay(vst_corrected) <- batch_corrected_assay

# A function to generate a 2x2 PCA grid for a given tissue
plot_tissue_pca <- function(vst_data, target_tissue) {
  
  # Subset the batch-corrected data for the target tissue
  vst_tissue <- vst_data[, vst_data$tissue == target_tissue]
  
  # Generate PCA plots colored by different factors
  pca_by_treatment <- plotPCA(vst_tissue, intgroup = "treatment") + ggtitle(paste("PCA by Treatment -", target_tissue)) + theme_minimal() + coord_fixed()
  pca_by_water <- plotPCA(vst_tissue, intgroup = "water") + ggtitle(paste("PCA by Water -", target_tissue)) + theme_minimal() + coord_fixed()
  pca_by_batch <- plotPCA(vst_tissue, intgroup = "batch") + ggtitle(paste("PCA by Batch -", target_tissue)) + theme_minimal() + coord_fixed()
  
  # Create a combined group for a full overview within the tissue
  vst_tissue$group <- factor(paste(vst_tissue$treatment, vst_tissue$water, sep = "_"))
  pca_by_group <- plotPCA(vst_tissue, intgroup = "group") + ggtitle(paste("PCA by All Groups -", target_tissue)) + theme_minimal() + coord_fixed()
  
  # Arrange the four plots into a 2x2 grid
  plot_grid(
    pca_by_treatment, pca_by_water,
    pca_by_batch, pca_by_group,
    ncol = 2, labels = "AUTO"
  )
}

# Generate and save the PCA grid for the Small Intestine
si_pca_grid <- plot_tissue_pca(vst_corrected, "small_intestine")
save_plot("../data/R49_pca_summary_small_intestine.jpg", si_pca_grid, base_height = 10, base_width = 14)
print("Small Intestine PCA Grid:")
print(si_pca_grid)

# Generate and save the PCA grid for the Large Intestine
li_pca_grid <- plot_tissue_pca(vst_corrected, "large_intestine")
save_plot("../data/R49_pca_summary_large_intestine.jpg", li_pca_grid, base_height = 10, base_width = 14)
print("Large Intestine PCA Grid:")
print(li_pca_grid)


# The PCA results show that the treatment effects are more subtle than the overall inter-mouse variability. This is precisely the scenario where DESeq2 excels at finding the real, statistically significant signals.
```

# DE analysis and shrinking 

```{r}
#' Map Ensembl IDs to Gene Symbols and Aggregate Counts
#'
#' This helper function takes a raw counts matrix with Ensembl IDs,
#' maps them to gene symbols, and sums up counts for any duplicate symbols.
#'
#' @param counts_matrix A raw counts matrix with Ensembl (versioned) rownames.
#' @return A matrix with gene symbols as rownames and aggregated counts.
map_and_aggregate_counts <- function(counts_matrix) {
  
  # 1. Create a mapping data frame
  ensembl_versions <- rownames(counts_matrix)
  ensembl_ids <- stringr::str_remove(ensembl_versions, "\\..*")
  
  mapping <- AnnotationDbi::select(
    org.Mm.eg.db,
    keys = ensembl_ids,
    columns = "SYMBOL",
    keytype = "ENSEMBL"
  )
  
  # 2. Join mapping with the counts
  counts_df <- as.data.frame(counts_matrix) %>%
    rownames_to_column("ensembl_version") %>%
    mutate(ensembl_id = stringr::str_remove(ensembl_version, "\\..*")) %>%
    # Join by the clean Ensembl ID
    left_join(mapping, by = c("ensembl_id" = "ENSEMBL")) %>%
    # Remove genes that didn't map to a symbol
    filter(!is.na(SYMBOL), SYMBOL != "") %>%
    # Remove metadata columns, keep only symbol and counts
    select(SYMBOL, all_of(colnames(counts_matrix))) 
    # A safer way (if sample names are not predictable):
    # select(SYMBOL, where(is.numeric)) 
    
  # 3. Aggregate counts for duplicate symbols (sum them up)
  counts_aggregated_df <- counts_df %>%
    group_by(SYMBOL) %>%
    # Sum up all numeric columns (the samples)
    summarise(across(where(is.numeric), sum)) %>%
    # Convert back to a matrix with symbols as rownames
    column_to_rownames("SYMBOL")
    
  return(as.matrix(counts_aggregated_df))
}


#' Run DESeq2 with batch correction and return results
#'
#' This function subsets data, handles the 'Colonization' contrast's
#' confounding by filtering to batch1, and returns a list containing
#' the dds object and an annotated results data frame.
#'
#' @param full_counts The full raw counts matrix (Ensembl IDs as rownames).
#' @param full_meta The full metadata table.
#' @param target_tissue The tissue to analyze (e.g., "large_intestine").
#' @param analysis_type "Colonization" or "Sucrose".
#'
#' @return A list with 'dds' (the DESeqDataSet) and 'results' (an
#'         annotated data frame of shrunken results).
run_deseq_with_batch_correction <- function(full_counts, full_meta, target_tissue, analysis_type) {
  
  # Determine which samples and which variable to use for the contrast
  if (analysis_type == "Colonization") {
    # Compare PBS vs E. faecalis within regular water samples
    # This design is confounded in batch2, so we ONLY use batch1
    meta_subset <- full_meta %>% 
      filter(tissue == target_tissue, 
             water == "regular_water",
             batch == "batch1") # Filter to batch1
    
    design_formula <- ~ treatment # Batch is no longer a variable
    contrast_info <- c("treatment", "E. faecalis", "PBS")
    
  } else if (analysis_type == "Sucrose") {
    # Compare sucrose vs regular water within E. faecalis samples
    # This design is NOT confounded and can use batch correction
    meta_subset <- full_meta %>% 
      filter(tissue == target_tissue, treatment == "E. faecalis")
    
    design_formula <- ~ batch + water # Correct for batch
    contrast_info <- c("water", "sucrose_water", "regular_water")
    
  } else {
    stop("Invalid analysis_type. Choose 'Colonization' or 'Sucrose'.")
  }
  
  # Subset the counts matrix to match the selected metadata
  counts_subset <- full_counts[, meta_subset$sample_id]
  
  # --- NEW STEP: Map IDs to Symbols and aggregate ---
  # This converts the rownames from Ensembl IDs to Gene Symbols
  counts_mapped <- map_and_aggregate_counts(counts_subset)
  
  # Create the DESeqDataSet object with batch in the design
  # We use the NEW counts_mapped matrix
  dds <- DESeqDataSetFromMatrix(
    countData = counts_mapped,
    colData = meta_subset,
    design = design_formula
  )
  
  # Run the DESeq2 analysis
  dds <- DESeq(dds)
  
  # Get the results for the specific contrast
  results_raw <- results(dds, contrast = contrast_info)
  
  # Apply LFC shrinkage for more accurate fold changes
  shrunken_results <- lfcShrink(dds, contrast = contrast_info, type = "ashr")
  
  # --- MODIFIED ANNOTATION ---
  # Rownames are already gene symbols, so we just convert to a tibble
  annotated_results <- as.data.frame(shrunken_results) %>%
    rownames_to_column("symbol") %>%
    select(symbol, everything()) # Reorder to put symbol first
  
  # Return both the dds (with symbols) and the annotated results
  return(list(dds = dds, results = annotated_results))
}



```

# add gene symbols  

```{r}


# Run all four analyses
# Colonization Effect
shrunken_si_col <- run_deseq_with_batch_correction(filtered_raw_counts_matrix, meta_table, "small_intestine", "Colonization")
shrunken_li_col <- run_deseq_with_batch_correction(filtered_raw_counts_matrix, meta_table, "large_intestine", "Colonization")

# Sucrose Effect
shrunken_si_suc <- run_deseq_with_batch_correction(filtered_raw_counts_matrix, meta_table, "small_intestine", "Sucrose")
shrunken_li_suc <- run_deseq_with_batch_correction(filtered_raw_counts_matrix, meta_table, "large_intestine", "Sucrose")

# Annotate each of the results dataframes
annotated_si_col <- annotate_results(shrunken_si_col)
annotated_li_col <- annotate_results(shrunken_li_col)
annotated_si_suc <- annotate_results(shrunken_si_suc)
annotated_li_suc <- annotate_results(shrunken_li_suc)

# Save the ANNOTATED shrunken results to CSV files
write_csv(annotated_si_col, "../data/R49_shrunken_results_si_colonization.csv")
write_csv(annotated_li_col, "../data/R49_shrunken_results_li_colonization.csv")
write_csv(annotated_si_suc, "../data/R49_shrunken_results_si_sucrose.csv")
write_csv(annotated_li_suc, "../data/R49_shrunken_results_li_sucrose.csv")

# Print a message to confirm completion
print("DESeq2 analyses complete. Annotated shrunken results have been saved to CSV files.")
```

# volcano plots 

```{r}
# --- 1. Load the Annotated DESeq2 Results ---
# These are the CSV files you created in the previous step.
# Make sure the file paths are correct.
results_si_col <- read_csv("../data/R49_shrunken_results_si_colonization.csv")
results_li_col <- read_csv("../data/R49_shrunken_results_li_colonization.csv")
results_si_suc <- read_csv("../data/R49_shrunken_results_si_sucrose.csv")
results_li_suc <- read_csv("../data/R49_shrunken_results_li_sucrose.csv")


# --- 2. Create a Reusable Volcano Plot Function ---
# This function takes a results dataframe and a title, and returns a ggplot object.

create_volcano_plot <- function(results_df, plot_title) {
  
  # Add a column to categorize genes as 'Upregulated', 'Downregulated', or 'Not significant'
  # based on the specified thresholds.
  results_df <- results_df %>%
    mutate(
      significance = case_when(
        padj < 0.05 & log2FoldChange > 1  ~ "Upregulated",
        padj < 0.05 & log2FoldChange < -1 ~ "Downregulated",
        TRUE                             ~ "Not significant"
      ),
      # Create a label column that only contains the symbol for significant genes
      label = if_else(significance != "Not significant", symbol, NA_character_)
    )

  # Generate the plot
  ggplot(results_df, aes(x = log2FoldChange, y = -log10(padj))) +
    # Add points for all genes, colored by their significance status
    geom_point(aes(color = significance), alpha = 0.6, size = 1.5) +
    
    # Use ggrepel to add non-overlapping labels for the significant genes
    geom_text_repel(aes(label = label),
                    size = 3.5,
                    box.padding = 0.5,
                    max.overlaps = Inf, # Allow all labels to be plotted
                    na.rm = TRUE) + # Ignore genes without a label
    
    # Define custom colors for the points
    scale_color_manual(values = c("Upregulated" = "red", "Downregulated" = "blue", "Not significant" = "grey")) +
    
    # Add dashed lines for the significance cutoffs
    geom_hline(yintercept = -log10(0.05), linetype = "dashed") +
    geom_vline(xintercept = 1, linetype = "dashed") +
    geom_vline(xintercept = -1, linetype = "dashed") +
    
    # Set plot titles and axis labels
    labs(
      title = plot_title,
      x = "Log2 Fold Change",
      y = "-log10(Adjusted P-value)"
    ) +
    
    # Apply a clean theme and adjust the legend
    theme_minimal(base_size = 14) +
    theme(legend.position = "none") # Hide the legend for a cleaner grid
}


# --- 3. Generate Each of the Four Volcano Plots ---

# Create each plot by calling the function with the corresponding dataframe and title
p_si_col <- create_volcano_plot(results_si_col, "SI: Colonization Effect")
p_li_col <- create_volcano_plot(results_li_col, "LI: Colonization Effect")
p_si_suc <- create_volcano_plot(results_si_suc, "SI: Sucrose Effect")
p_li_suc <- create_volcano_plot(results_li_suc, "LI: Sucrose Effect")


# --- 4. Arrange the Plots into a 2x2 Grid ---
# Use cowplot's plot_grid to combine the four plots into a single figure.

final_volcano_grid <- plot_grid(
  p_si_col, p_si_suc,
  p_li_col, p_li_suc,
  ncol = 2,
  labels = "AUTO"
)

# Save the combined figure as a JPG file
save_plot("../data/R49_volcano_plots_summary.jpg", final_volcano_grid, base_height = 10, base_width = 14)

# Display the final plot
print(final_volcano_grid)

# Colonizing germ-free mice with E. faecalis will "wake up" the naive gut. The small intestine will focus on immediate defense by beefing up the mucus layer and producing bacteria-coating IgA antibodies. The large intestine, where the bacteria will primarily reside, will undergo a much more profound transformation, building out its immune infrastructure and physically remodeling its lining to learn how to permanently host a bacterial resident.
```
## plot b cell genes in SI colonization contrast

Use plotCounts (like in your script): To plot the expression of one gene at a time, comparing its value between groups.

Use vst (like for the heatmap): To compare many different genes to each other, like in a heatmap or PCA plot.

```{r}
meta_subset <- meta_table %>% filter(tissue == "small_intestine", water == "regular_water", batch == "batch1")
design_formula <- ~  treatment


# Subset the counts matrix to match the selected metadata
counts_subset <- filtered_raw_counts_matrix[, meta_subset$sample_id]

# Create the DESeqDataSet object with batch in the design
dds <- DESeqDataSetFromMatrix(
  countData = counts_subset,
  colData = meta_subset,
  design = design_formula
)

# Run the DESeq2 analysis
dds <- DESeq(dds)
vst_data <- vst(dds, blind = FALSE)

# 1. find the list of B-cell genes from your volcano plot
b_cell_sig_genes <- annotated_si_col |> 
  filter(padj < 0.05 , log2FoldChange > 1) 

vst_counts <- assay(vst_data)


# 3. Wrangle data for plotting
#    The batch_corrected_counts is a matrix. We need to:
#    a. Filter for our genes of interest
#    b. Convert to a long-format tibble
#    c. Join with the sample metadata (coldata)
plot_data <- vst_counts %>%
  as.data.frame() %>%
  rownames_to_column("ensembl_version") %>%
  inner_join(b_cell_sig_genes) |> 
  # Melt to long format
  pivot_longer(
    cols = contains("IGO_"),
    names_to = "sample",
    values_to = "VST_normalized_count"
  ) %>%
  # Join with sample metadata to get 'condition'
  # We get the coldata straight from the dds object
  left_join(as.data.frame(colData(dds)), by = c("sample" = "sample_id"))
```


```{r}
# 4. Create the faceted boxplot, but show batch with color
ggplot(plot_data, aes(x = treatment, y = VST_normalized_count, color = batch)) +
  # Boxplot to summarize the groups
  #geom_boxplot(outlier.shape = NA, alpha = 0.5, aes(fill = treatment)) +
  
  # Jitter plot to show *all* individual samples, colored by batch
  # This is the most honest part of the visualization
  geom_jitter(width = 0.1, height = 0, size = 3) +
  
  # Use facet_wrap to create one small plot for each gene
  facet_wrap(~ symbol, scales = "free_y") +
  
  # Manually set high-contrast colors
  scale_color_manual(values = c("batch1" = "black", "batch2" = "red")) +
  scale_fill_manual(values = c("E. faecalis" = "#E41A1C", "PBS" = "#377EB8")) +
  
  labs(
    title = "Normalized Counts of B-Cell Signature Genes",
    subtitle = "Points colored by batch (VST data, no batch correction)",
    x = "Experimental treatment",
    y = "Normalized Counts (VST)"
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10),
    legend.position = "bottom",
    strip.background = element_rect(fill = "grey90"),
    strip.text = element_text(face = "bold.italic")
  )

ggsave("../data/R49_bcell_gene_counts_honest_plot.jpg", width = 12, height = 9, dpi = 300)
```

## B cells heatmap   

```{r}
# make a heatmap of the above data
# Filter the count matrix for these genes
batch_corrected_count_si_col <- batch_corrected_counts

genes_to_plot <- batch_corrected_count_si_col |> 
  as.data.frame() %>%
  rownames_to_column('ensembl_version') |> 
  inner_join(annotated_si_col |> select(ensembl_version, symbol)) |> 
  filter(symbol %in% b_cell_sig_genes$symbol)


heatmap_data <- genes_to_plot |> 
  select(-ensembl_version) |> 
  column_to_rownames('symbol') |> 
  as.matrix()

# 8. Create annotation for the columns (Samples)
sample_annotation <- meta_table |> filter(tissue == 'small_intestine', water == 'regular_water') |> 
  select(sample_id, treatment, batch) |> 
  column_to_rownames('sample_id')

# Get unique values from the annotations to build the color lists
condition_levels <- unique(sample_annotation$treatment)
batch_levels <- unique(sample_annotation$batch)


# High-contrast colors for treatment/condition
# Manually assigning for clarity based on the plot
cond_colors <- c("#E41A1C", "#377EB8") # (Red, Blue)
names(cond_colors) <- condition_levels

# Contrasting colors for batch
batch_colors <- c("#FDBF6F", "#A6CEE3") # (Light Orange, Light Blue)
names(batch_colors) <- batch_levels[1:length(batch_colors)]

# Combine into the final list for pheatmap
ann_colors <- list(
  treatment = cond_colors,
  batch = batch_colors
)

# 9. Generate the heatmap
Bcell_heatmap <- pheatmap(
  heatmap_data,
  # Annotation for columns (samples) and rows (genes)
  annotation_col = sample_annotation,
  # Pass the custom colors
  annotation_colors = ann_colors,
  # Scale data by row (Z-score)
  scale = "row",
  
  # Clustering settings
  cluster_rows = T, # We already sorted by function
  cluster_cols = TRUE,
  
  # Aesthetics
  show_rownames = TRUE,
  show_colnames = T,
  border_color = "grey60",
  fontsize_row = 8,
  main = "Heatmap of B cell signature genes (SI Colonization)",
  filename = "../data/R49_Bcell_heatmap.jpg", width = 8, height = 8
)

```

# GSEA

```{r}
# --- Gene Rank Preparation Function ---
# This function is updated to work with data that already contains a 'symbol' column.
prepare_ranked_list <- function(deseq_results) {
  
  # The input `deseq_results` is a dataframe/tibble from read_csv.
  # We assume it contains 'symbol', 'log2FoldChange', and 'pvalue' columns.
  results_df <- deseq_results %>%
    # Ensure symbol, pvalue and log2FoldChange are not NA
    filter(!is.na(symbol) & !is.na(pvalue) & !is.na(log2FoldChange)) %>%
    
    # *** Create a custom ranking metric ***
    # This metric combines the direction (sign of LFC) and significance (-log10 of p-value)
    mutate(rank_metric = sign(log2FoldChange) * -log10(pvalue))

  # Handle cases where one gene symbol maps to multiple entries.
  # We'll keep the one with the largest absolute rank_metric value.
  results_df <- results_df %>%
    group_by(symbol) %>%
    slice_max(order_by = abs(rank_metric), n = 1, with_ties = FALSE) %>%
    ungroup()

  # Create the final ranked list: a named vector
  ranked_list <- results_df$rank_metric
  names(ranked_list) <- results_df$symbol
  
  # Sort the list in descending order
  ranked_list <- sort(ranked_list, decreasing = TRUE)
  
  # Remove any NA values from the ranking metric
  ranked_list <- ranked_list[!is.na(ranked_list)]
  
  return(ranked_list)
}
```

```{r}
# --- Prepare Gene Sets ---
# Fetch the Hallmark (H) gene sets for mouse from the msigdbr database.
hallmark_pathways <- msigdbr(species = "Mus musculus", category = "H") %>%
  split(x = .$gene_symbol, f = .$gs_name)
```


```{r}
# --- Prepare Gene Ranks for all four conditions ---
ranks_si_col <- prepare_ranked_list(results_si_col)
ranks_li_col <- prepare_ranked_list(results_li_col)
ranks_si_suc <- prepare_ranked_list(results_si_suc)
ranks_li_suc <- prepare_ranked_list(results_li_suc)


# --- Run GSEA for all four conditions ---
set.seed(42) # for reproducibility
fgsea_res_si_col <- fgsea(pathways = hallmark_pathways, stats = ranks_si_col, minSize=15, maxSize=500, nPermSimple = 10000)
fgsea_res_li_col <- fgsea(pathways = hallmark_pathways, stats = ranks_li_col, minSize=15, maxSize=500, nPermSimple = 10000)
fgsea_res_si_suc <- fgsea(pathways = hallmark_pathways, stats = ranks_si_suc, minSize=15, maxSize=500, nPermSimple = 10000)
fgsea_res_li_suc <- fgsea(pathways = hallmark_pathways, stats = ranks_li_suc, minSize=15, maxSize=500, nPermSimple = 10000)

# --- Process and Visualize Results ---
# Combine all results into one dataframe with identifying columns
all_fgsea_res <- bind_rows(
  fgsea_res_si_col %>% as_tibble() %>% mutate(condition = "SI - Colonization"),
  fgsea_res_li_col %>% as_tibble() %>% mutate(condition = "LI - Colonization"),
  fgsea_res_si_suc %>% as_tibble() %>% mutate(condition = "SI - Sucrose"),
  fgsea_res_li_suc %>% as_tibble() %>% mutate(condition = "LI - Sucrose")
)
```


```{r}
# Filter for significant pathways and select top N up/down for each condition
top_pathways <- all_fgsea_res %>%
  filter(padj < 0.05) %>%
  mutate(direction = ifelse(NES > 0, "Upregulated", "Downregulated")) %>%
  group_by(condition, direction) %>%
  slice_max(order_by = abs(NES), n = 10) %>% # Get top 10 in each direction
  ungroup()

# --- Plotting Function ---
# This function creates a diverging bar plot for a single condition
create_diverging_plot <- function(data, plot_condition) {
  
  plot_data <- data %>%
    filter(condition == plot_condition)
  
  if (nrow(plot_data) == 0) {
    return(ggplot() + theme_void() + labs(title = plot_condition, subtitle = "No significant pathways"))
  }
  
  plot_data <- plot_data %>%
    mutate(
      pathway_clean = pathway %>%
        str_replace("HALLMARK_", "") %>%    # Remove the prefix.
        str_to_title() %>%                  # Convert to Title Case.
        str_replace_all("_", " ") %>%     # Replace underscores with spaces.
        str_wrap(width = 48)                # Wrap long names for readability.
    ) %>%
    # Calculate -log10(padj) for dot size
    mutate(neg_log_padj = -log10(padj)) %>%
    mutate(pathway_clean = reorder(pathway_clean, NES))

  ggplot(plot_data, aes(x = NES, y = pathway_clean, color = direction)) +
    # Add the "lollipop stick" segment
    geom_segment(aes(x = 0, xend = NES, y = pathway_clean, yend = pathway_clean), linewidth = 0.8) +
    
    # Add the "dot" at the end, with size mapped to significance
    geom_point(aes(size = neg_log_padj), alpha = 0.8) +
    
    # Manually set colors
    scale_color_manual(values = c("Upregulated" = "#E64B35", "Downregulated" = "royalblue"), name = "Direction") +
    
    # Add a legend for dot size
    scale_size_continuous(name = "-log10(Adjusted p-value)") +
    
    labs(
      title = plot_condition,
      x = "Normalized Enrichment Score (NES)",
      y = ""
    ) +
    geom_vline(xintercept = 0, linetype = "dashed") +
    theme_bw(base_size = 12) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      panel.grid.major.y = element_blank(),
      panel.grid.minor.x = element_blank(),
      axis.text.y = element_text(size = 9)
    )
}

# --- Generate the Four Plots ---
plot_si_col <- create_diverging_plot(top_pathways, "SI - Colonization")
plot_li_col <- create_diverging_plot(top_pathways, "LI - Colonization")
plot_si_suc <- create_diverging_plot(top_pathways, "SI - Sucrose")
plot_li_suc <- create_diverging_plot(top_pathways, "LI - Sucrose")

# --- Combine Plots into a 2x2 Grid ---
final_plot <- (plot_si_col | plot_li_col) / (plot_si_suc | plot_li_suc) +
  plot_annotation(
    title = 'Hallmark Gene Set Enrichment Analysis',
    subtitle = 'Significantly Enriched Pathways by Condition',
    theme = theme(plot.title = element_text(hjust = 0.5, size = 16, face = "bold"))
  )

# --- Save and Display the Final Plot ---
ggsave("../data/R49_gsea_hallmark_grid.jpg", final_plot, width = 18, height = 14, dpi = 300)
print(final_plot)

# what the SI gsea and the volcano shows 
# This finding suggests a more nuanced strategy by the small intestine. Instead of a "brute-force" approach of just making more slime, it's mounting a targeted, "special forces" operation. By activating B-cells, it's preparing to produce secretory IgA antibodies. IgA acts like a coat of paint, specifically tagging the E. faecalis to prevent it from sticking to the gut wall and neutralizing it without causing excessive inflammation. This is a much more elegant way to manage a new resident than simply launching an all-out innate attack.

# and about the LI
#Unlike the small intestine, which used its energy to fuel a targeted B-cell immune response, the large intestine is in a defensive state of survival and reconstruction. The colonization has triggered a powerful inflammatory cascade that is causing cellular stress (S100g). In response, the LI has shut down all normal business (cell growth, metabolism) to conserve energy and is now using that energy for a drastic and stressful process of remodeling its own lining (EMT, Apoptosis) to cope with the new resident.The strong signal from genes like Vimentin (Vim), Collagen (Col3a1), and others involved in the extracellular matrix provides direct, single-gene evidence that validates the GSEA finding of Epithelial-to-Mesenchymal Transition (EMT).This confirms that the large intestine's primary response is not an active immune attack, but a deep, structural remodeling and wound-healing process in the face of the stress caused by the new bacterial colonization.
```

Metabolism: The small intestine is boosting its energy production to fuel an active defense, while the large intestine is shutting down its normal metabolism, indicating a more severe level of stress.

Cell Growth: Both parts of the gut are halting cell division to focus on the immediate threat.

Tissue Response: The large intestine is mounting a more aggressive and complex response, leading to significant remodeling of the gut wall itself.

The GSEA data provides the molecular "receipts" for our hypothesis:

The Small Intestine is paying for its "meet-and-greet" defense with a massive surge in energy production.

The Large Intestine is undertaking a deep, stressful, and inflammatory "reconstruction" to prepare for its long-term role as a host.

## B cell related genesets

```{r}
# --- Prepare Gene Sets ---
# Fetch the C8 cell type signature gene sets for mouse.
C7_pathways_all <- msigdbr(species = "Mus musculus", category = "C7", subcollection = 'IMMUNESIGDB')

# Filter this collection to get the B-cell specific response signatures.
b_cell_C7_pathways_filtered <- C7_pathways_all %>%
  filter(str_detect(gs_name, "B_CELL"))

#Are your B-cells just activated, or are they differentiating into full-blown antibody factories?

# What These C7 Gene Sets Represent
# Think of a B-cell's life like a career path.
# 
# Spleen B-Cell: This is like an experienced professional. It's mature, circulates, and is ready for a job, but it isn't fully committed to a single, massive project yet.
# 
# Bone Marrow Plasma Cell: This is the specialist who has taken on that one massive project. It has stopped circulating, set up a factory (often in the bone marrow), and is now dedicated 100% to producing and secreting vast quantities of antibodies. This is the final, most potent stage of a B-cell's life.
# 
# The two gene sets you found define the genetic differences between these two states:
# 
# ..._UP set: Genes that are higher in the spleen B-cell. These are genes for patrolling, signaling, and being ready for activation.
# 
# ..._DN set: Genes that are lower in the spleen B-cell. This is the crucial part—this means these genes are higher in the plasma cell. This list includes the machinery for massive protein synthesis and secretion.

# Convert the filtered dataframe into the list format required by fgsea.
b_cell_c7_pathways <- b_cell_C7_pathways_filtered %>%
  split(x = .$gene_symbol, f = .$gs_name)

# --- Prepare Gene Ranks for the Small Intestine ---
ranks_si_col <- prepare_ranked_list(results_si_col)
```


```{r}
# --- Run GSEA with the B-Cell C7 Signature Pathways ---
set.seed(42)
fgsea_res_bcell_c7 <- fgsea(
  pathways = b_cell_c7_pathways, 
  stats = ranks_si_col, 
  minSize=15, 
  maxSize=500, 
  nPermSimple = 10000
)

# --- Process and Visualize Results ---
# Filter for the most significant pathways to plot.
top_bcell_c7_pathways <- fgsea_res_bcell_c7 %>%
  as_tibble() %>%
  filter(padj < 0.05)
```


```{r}
# --- Plotting Function ---
# Cleans up the C7 pathway names for better readability.
plot_data_c7 <- top_bcell_c7_pathways %>%
  mutate(
    pathway_clean = pathway %>%
      str_remove("GSE\\d+_") %>%
      str_replace("_VS_", " vs ") %>%
      str_replace("_DN", ": Down") %>%
      str_replace("_UP", ": Up") %>%
      str_to_sentence() %>%
      str_replace_all("_", " ") %>%
      str_wrap(width = 60)
  ) %>%
  mutate(
    direction = ifelse(NES > 0, "Upregulated", "Downregulated"),
    pathway_clean = reorder(pathway_clean, NES)
  )

# Create the plot
bcell_c7_plot <- ggplot(plot_data_c7, aes(x = NES, y = pathway_clean, fill = direction)) +
  geom_col(color = "black") +
  scale_fill_manual(values = c("Upregulated" = "#E64B35", "Downregulated" = "#4DBBD5"), name = "Direction") +
  labs(
    title = "Top B-Cell Immunologic Signatures in the Small Intestine",
    subtitle = "Enrichment upon E. faecalis Colonization (C7 Gene Sets)",
    x = "Normalized Enrichment Score (NES)",
    y = ""
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size=16),
    plot.subtitle = element_text(hjust = 0.5),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.text.y = element_text(size = 10)
  )

# --- Save and Display the Final Plot ---
ggsave("../data/R49_gsea_bcell_c7_signatures_plot.jpg", bcell_c7_plot, width = 10, height = 4, dpi = 300)
print(bcell_c7_plot)

# Breaking it Down:

# This gene set contains genes that are normally UPregulated in circulating spleen B-cells compared to stationary plasma cells.
# 
# Your data shows that these "spleen B-cell" genes are being DOWNregulated in your colonized mice (a negative enrichment score).
# 
# The Conclusion: If the genes that define a spleen B-cell are going down, it means your cells are moving away from that state. They are becoming less like circulating B-cells and more like plasma cells.


#This result provides strong evidence that the B-cells in the small intestine are not just activated—they are undergoing terminal differentiation into antibody-secreting plasma cells.

# Think of it this way: to become a dedicated antibody factory (a plasma cell), a B-cell has to shut down the genetic programs for being a mobile scout (a spleen B-cell). It turns off genes for patrolling and responding to new signals and turns on the massive machinery needed for protein production. Your GSEA result has captured this "shutting down" process perfectly.
# 
# This aligns with everything else you've seen:
# 
# Volcano Plot: Shows a massive B-cell signature.
# 
# Hallmark GSEA: Shows high metabolic activity (Oxidative Phosphorylation) needed to fuel the energy-intensive process of antibody production.
# 
# This C7 GSEA: Provides the final piece of the puzzle, showing that these metabolically active B-cells are committing to becoming plasma cells.
```
### enrichment plot

```{r}
# Define the exact name of the pathway of interest.
target_pathway_name <- "GSE39916_B_CELL_SPLEEN_VS_PLASMA_CELL_BONE_MARROW_UP"

# --- Create and Save the Enrichment Plot ---
# Generate the GSEA enrichment plot for the single target pathway.
enrichment_plot <- plotEnrichment(
  pathway = b_cell_c7_pathways[[target_pathway_name]],
  stats = ranks_si_col
) + 
  labs(
    title = "Enrichment Plot",
    subtitle = "Genes downregulated in Spleen B-Cells vs. Plasma Cells",
    x = "Rank in Gene List",
    y = "Enrichment Score"
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5)
  )

# --- Save and Display the Final Plot ---
ggsave("../data/R49_gsea_enrichment_plot_c7_signature.jpg", enrichment_plot, width = 8, height = 6, dpi = 300)
print(enrichment_plot)
```

# download the M7 genesets

```{r}
# --- Iteratively Run GSEA on all GMT files in a Folder ---
# This section programmatically finds all .gmt files in a directory,
# runs GSEA for each, and combines the results.

# Define the path to the folder containing your .gmt files.
geneset_folder <- "../data/geneset/" 

# Check if the directory exists
if (!dir.exists(geneset_folder)) {
  stop("The specified geneset folder does not exist: ", geneset_folder)
}

# Get a list of all files ending with .gmt in the specified folder.
gmt_files <- list.files(geneset_folder, pattern = "\\.gmt$", full.names = TRUE)

if (length(gmt_files) == 0) {
    stop("No .gmt files found in the directory: ", geneset_folder)
}

# Use purrr::map_dfr to iterate over the files, run GSEA, and row-bind the results.
all_fgsea_results <- map_dfr(gmt_files, ~{
  # Load the pathways from the current .gmt file.
  current_pathways <- gmtPathways(.x)
  
  # Run fgsea.
  fgsea(
    pathways = current_pathways,
    stats = ranks_si_col,
    minSize = 5,
    maxSize = 500,
    nPermSimple = 10000
  )
})
```


```{r}
# --- Process and Visualize Combined Results ---
# Filter the combined results for the most significant pathways to plot.
top_combined_pathways <- all_fgsea_results %>%
  as_tibble() %>%
  filter(padj < 0.05) %>%
  mutate(direction = ifelse(NES > 0, "Upregulated", "Downregulated")) %>%
  group_by(direction) %>%
  slice_max(order_by = abs(NES), n = 31) %>% # Show top 15 from each direction
  ungroup()

# --- Plotting Function ---
# Cleans up the pathway names for better readability.
plot_data_combined <- top_combined_pathways %>%
  mutate(
    pathway_clean = pathway %>%
      str_remove("CUI_B_CELL_") %>%
      str_to_sentence() %>%
      str_replace_all("_", " ") %>%
      str_wrap(width = 40)
  ) %>%
  mutate(pathway_clean = reorder(pathway_clean, NES))

# Create the plot
bcell_combined_plot <- ggplot(plot_data_combined, aes(x = NES, y = pathway_clean, color = direction)) +
  # Add the horizontal line segment from 0 to the NES value
  geom_segment(aes(x = 0, xend = NES, y = pathway_clean, yend = pathway_clean), linewidth = 0.5) +
  # Add the point at the end of the line
  geom_point(aes(size = -log10(padj))) + 
  scale_color_manual(values = c("Upregulated" = "#E64B35", "Downregulated" = "#4DBBD5"), name = "Direction") +
  scale_size_continuous(name = "-log10(Adjusted P-value)", range = c(2, 8)) + # Control the range of point sizes
  labs(
    title = "Top B-Cell Response Signatures in the Small Intestine",
    subtitle = "Combined GSEA Results from Custom Gene Sets",
    x = "Normalized Enrichment Score (NES)",
    y = ""
  ) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  theme_bw(base_size = 12) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size=16),
    plot.subtitle = element_text(hjust = 0.5),
    panel.grid.major.y = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.text.y = element_text(size = 10)
  )

# --- Save and Display the Final Plot ---
ggsave("../data/R49_gsea_bcell_combined_plot.jpg", bcell_combined_plot, width = 8, height = 8, dpi = 300)
print(bcell_combined_plot)

# 1. A Dominant Interferon "Alarm" is Sounding
# This is the most powerful signal in your plot. You see strong enrichment for the response signatures of multiple interferons: Ifna1, Ifnb, Ifne, Ifnk, and Ifng.
# 
# Why it matters: This confirms your earlier Hallmark GSEA result with much greater precision. It tells you that both Type I (alpha, beta, etc.) and Type II (gamma) interferons are major players. This type of signal is critical for directing B-cells to class-switch their antibodies and mature into a more potent fighting force.
# 
# 2. The Environment is Primed for Antibody Production
# You see strong enrichment for cytokines that are classic drivers of B-cell differentiation into antibody-secreting plasma cells.
# 
# Il10 response up and Il21 response up: These are two of the most important cytokines for the final stages of B-cell maturation. Seeing these signatures confirms that the local environment is providing the exact signals needed to push the activated B-cells to become antibody factories, which perfectly supports your findings from the C7 gene sets.
# 
# 3. You Are Seeing a Complex, "In-Vivo" Response
# This addresses your excellent question about seeing both "UP" and "DN" signatures for the same cytokine. Look at Interferon Alpha (Ifna1):
# 
# Ifna1 response up: This gene set is significantly enriched.
# 
# Ifna1 response dn: This gene set is also significantly enriched.
# 
# This is not a contradiction. It's a window into complex, real-world biology.
# 
# What it means: The "UP" and "DN" gene sets were defined in a clean lab experiment with only B-cells and IFN-alpha. Your experiment is in a complex gut. Your result shows that the B-cells are definitely "hearing" the IFN-alpha signal (activating the "UP" genes). However, the mix of all the other cytokines (Il10, Il21, etc.) is overriding IFN-alpha's normal ability to turn off its "DN" genes, causing them to be expressed instead. This is a sign of complex signal integration.

```
# LI structural remodeling

```{r}
meta_subset <- meta_table %>% filter(tissue == "large_intestine", water == "regular_water")
design_formula <- ~ batch + treatment


# Subset the counts matrix to match the selected metadata
counts_subset <- filtered_raw_counts_matrix[, meta_subset$sample_id]

# Create the DESeqDataSet object with batch in the design
dds <- DESeqDataSetFromMatrix(
  countData = counts_subset,
  colData = meta_subset,
  design = design_formula
)

# Run the DESeq2 analysis
dds <- DESeq(dds)
vst_data <- vst(dds, blind = FALSE)

batch_corrected_counts_li_col <- removeBatchEffect(
  assay(vst_data), 
  batch = vst_data$batch # Use the 'batch' column from coldata
)
```


```{r}
# --- Extract and Print Leading Edge Genes for EMT ---

# Define the pathway name we're looking for
emt_pathway_name <- "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION"

# Filter the GSEA results to find the EMT pathway
emt_results <- fgsea_res_li_col %>%
  as_tibble() %>%
  filter(pathway == emt_pathway_name)

# Check if the pathway was found and significant
if (nrow(emt_results) > 0) {
  
  # The 'leadingEdge' column is a list column. We need to extract the genes.
  # unlist() converts the list of genes into a simple vector
  leading_edge_genes_emt <- emt_results %>%
    pull(leadingEdge) %>%
    unlist()
  
  # Print the genes to the console
  cat("--- Leading Edge Genes for EMT Pathway ---\n")
  cat("Pathway:", emt_pathway_name, "\n")
  cat("Number of genes:", length(leading_edge_genes_emt), "\n\n")
  
  # Print the list of genes
  print(leading_edge_genes_emt)
  
} else {
  cat("The EMT pathway was not found or was not significant in the GSEA results.\n")
}

plot_data_EMT <- batch_corrected_counts_li_col %>%
  as.data.frame() %>%
  rownames_to_column("ensembl_version") %>%
  inner_join(annotated_li_col |> filter(symbol %in% leading_edge_genes_emt)) |> 
  # Melt to long format
  pivot_longer(
    cols = contains("IGO_"),
    names_to = "sample",
    values_to = "batch_corrected_count"
  ) %>%
  # Join with sample metadata to get 'condition'
  # We get the coldata straight from the dds object
  left_join(as.data.frame(colData(dds)), by = c("sample" = "sample_id"))


plot_EMT <- ggplot(plot_data_EMT, aes(x = treatment, y = batch_corrected_count, color = treatment)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.2, height = 0, size = 2) +
  # Use facet_wrap to create one small plot for each gene
  # scales = "free_y" is important, as each gene will have a different count range
  facet_wrap(~ symbol, scales = "free_y") +
  scale_color_brewer(palette = "Set1") +
  labs(
    title = "Batch-Corrected Counts of EMT leading edge Genes",
    subtitle = "LI: Colonization Effect (VST + removeBatchEffect)",
    x = "Experimental Condition",
    y = "Batch-Corrected Normalized Counts (VST)"
  ) +
  theme_bw(base_size = 14) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "none", # The x-axis already shows the treatment
    strip.background = element_rect(fill = "grey90"),
    strip.text = element_text(face = "bold.italic")
  )

ggsave("../data/R49_EMT_gene_counts_boxplot_batch_corrected.jpg", width = 12, height = 9, dpi = 300, plot = plot_EMT)
```
## LI inflammation

```{r}
# --- Extract Leading Edge Genes for INFLAMMATION ---

# 1. Define your target inflammation pathways from the GSEA plot
inflammation_pathway_names <- c(
  "HALLMARK_INFLAMMATORY_RESPONSE",
  "HALLMARK_TNFA_SIGNALING_VIA_NFKB",
  "HALLMARK_IL6_JAK_STAT3_SIGNALING",
  "HALLMARK_INTERFERON_ALPHA_RESPONSE",
  "HALLMARK_INTERFERON_GAMMA_RESPONSE"
)

# 2. Extract, combine, and de-duplicate all leading edge genes from these pathways
#    We use unnest() to expand the list of genes in the leadingEdge column
inflammation_leading_edge <- fgsea_res_li_col %>%
  as_tibble() %>%
  filter(pathway %in% inflammation_pathway_names) %>%
  unnest(leadingEdge) %>%
  select(pathway, symbol = leadingEdge) %>%
  # A gene might be in multiple pathways. For the heatmap, we'll
  # just keep the first one it's associated with for grouping.
  distinct(symbol, .keep_all = TRUE)

# 3. Create the gene_groups annotation for the heatmap
gene_groups <- inflammation_leading_edge %>%
  # Clean up the pathway names for the heatmap annotation
  mutate(Function = str_replace(pathway, "HALLMARK_", "") %>%
                    str_to_title() %>%
                    str_replace_all("_", " ") %>%
                    str_wrap(40)) %>%
  select(-pathway) %>% # Drop the original pathway name
  arrange(Function) %>%  # Sort by the new functional group
  column_to_rownames("symbol")

# 4. Get the gene symbols in the new sorted order
inflammation_genes_for_heatmap <- rownames(gene_groups)
```


```{r}
# 5. Check if we have any genes before proceeding
if (length(inflammation_genes_for_heatmap) > 0) {
  
  # --- Create Heatmap for INFLAMMATION Leading Edge Genes ---
  # 7. Filter the count matrix for these genes
  #    Use intersect() to ensure we only grab genes present in the counts
  
  genes_to_plot <- batch_corrected_counts_li_col |> 
    as.data.frame() %>%
    rownames_to_column('ensembl_version') |> 
    inner_join(annotated_li_col |> select(ensembl_version, symbol)) |> 
    filter(symbol %in% inflammation_genes_for_heatmap)
  
  # Re-filter gene_groups to match the genes we actually have, preserving the new order
  # The 'drop = FALSE' ensures it remains a dataframe even if only one gene is found
  gene_groups <- gene_groups[genes_to_plot$symbol, , drop = FALSE] |> 
    arrange(Function)
  
  heatmap_data <- genes_to_plot |> 
    select(-ensembl_version) |> 
    column_to_rownames('symbol') |> 
    as.matrix()
  
  heatmap_data_sorted <- heatmap_data[rownames(gene_groups),]
  
  # 8. Create annotation for the columns (Samples)
  sample_annotation <- meta_table |> filter(tissue == 'large_intestine', water == 'regular_water') |> 
    select(sample_id, treatment, batch) |> 
    column_to_rownames('sample_id')
  
  # Get unique values from the annotations to build the color lists
  function_levels <- unique(gene_groups$Function)
  condition_levels <- unique(sample_annotation$treatment)
  batch_levels <- unique(sample_annotation$batch)
  
  # Create named color vectors
  # Using RColorBrewer's "Paired" palette for functions (good for contrast)
  # Ensure we have enough colors, even if n < 3
  n_func_colors <- max(3, length(function_levels))

  func_colors <- RColorBrewer::brewer.pal(n_func_colors, "Paired")[1:length(function_levels)]
  names(func_colors) <- function_levels
  
  # High-contrast colors for treatment/condition
  # Manually assigning for clarity based on the plot
  cond_colors <- c("#E41A1C", "#377EB8") # (Red, Blue)
  names(cond_colors) <- condition_levels


  # Contrasting colors for batch
  batch_colors <- c("#FDBF6F", "#A6CEE3") # (Light Orange, Light Blue)
  names(batch_colors) <- batch_levels[1:length(batch_colors)]
  
  # Combine into the final list for pheatmap
  ann_colors <- list(
    Function = func_colors,
    treatment = cond_colors,
    batch = batch_colors
  )
  
  
  # 9. Generate the heatmap
  Li_Inflammation <- pheatmap(
    heatmap_data_sorted,
    # Annotation for columns (samples) and rows (genes)
    annotation_col = sample_annotation,
    annotation_row = gene_groups,
    # Pass the custom colors
    annotation_colors = ann_colors,
    # Scale data by row (Z-score)
    scale = "row",
    
    # Clustering settings
    cluster_rows = FALSE, # We already sorted by function
    cluster_cols = TRUE,
    
    # Aesthetics
    show_rownames = TRUE,
    show_colnames = T,
    border_color = "grey60",
    fontsize_row = 8,
    main = "Heatmap of Inflammation Leading Edge Genes (LI Colonization)",
    filename = "../data/R49_inflammation_leading_edge_heatmap.jpg", width = 8, height = 15
  )
}
```


# LI what is happening in LI

E. faecalis alone causes inflammation and tells the gut cells to stop growing. Adding sucrose keeps the inflammation going but reverses the stop signal, telling the gut cells to grow rapidly, creating a high-risk, inflamed, and proliferative environment. The sucrose isn't directly affecting the host cells in the large intestine. Instead, a high-sucrose diet feeds the E. faecalis (which shouldn't have access to that sugar), causing it to produce byproducts like lactic acid and form biofilms. The host cells are reacting to this new, acidic, and bacteria-rich environment.

```{r}
# need to correct for batch effects in the sucrose contrast
plot_pathway_heatmap <- function(dds, gene_list, annotation_vars, main_title, cluster_cols = FALSE) {
  
  # Run VST on the dds object
  # blind = FALSE uses the model's dispersion estimates.
  vst_data <- vst(dds, blind = FALSE)
  vst_matrix <- assay(vst_data)
  
  # --- NEW: Check for and remove batch effect ---
  # Check if 'batch' is part of the design formula
  if ("batch" %in% all.vars(design(dds))) {
    
    message("Found 'batch' in the design. Removing batch effect for visualization.")
    
    # Load limma, which is needed for batch correction
    if (!requireNamespace("limma", quietly = TRUE)) {
      stop("Package 'limma' is needed for this function to remove batch effects.")
    }
    
    # Identify the variable to *protect* (e.g., 'water' or 'treatment')
    # This finds the variable in the design that is NOT 'batch'
    design_vars <- all.vars(design(dds))
    protected_var_name <- design_vars[design_vars != "batch"][1] # Get first non-batch var
    
    if (is.na(protected_var_name)) {
      # This case should not happen with our 'Sucrose' design
      warning("Could not automatically find variable to protect; only removing batch.")
      
      vst_matrix <- limma::removeBatchEffect(
        vst_matrix, 
        batch = colData(dds)$batch
      )
      
    } else {
      message(paste("Protecting variable:", protected_var_name))
      
      # Create a design matrix for the variable to protect
      protected_design <- model.matrix(
        as.formula(paste("~", protected_var_name)), 
        data = colData(dds)
      )
      
      # Remove batch effect, protecting the 'protected_design'
      vst_matrix <- limma::removeBatchEffect(
        vst_matrix, 
        batch = colData(dds)$batch,
        design = protected_design
      )
    }
    message("Batch effect removed.")
  }
  # --- END NEW SECTION ---
  
  # Get all genes from the list
  genes_to_plot <- unlist(gene_list)
  
  # Check which genes are actually in the matrix
  genes_present <- genes_to_plot[genes_to_plot %in% rownames(vst_matrix)]
  genes_missing <- genes_to_plot[!genes_to_plot %in% rownames(vst_matrix)]
  
  if (length(genes_missing) > 0) {
    message("Warning: The following genes were not found and will be skipped: ", 
            paste(genes_missing, collapse = ", "))
  }
  
  if (length(genes_present) == 0) {
    stop("Error: None of the specified genes were found in the dataset.")
  }
  
  # Subset the matrix for the genes that are present
  # This now uses the batch-corrected matrix (if batch was present)
  plot_matrix <- vst_matrix[genes_present, , drop = FALSE]
  
  # Get metadata for annotation
  annotation_col <- as.data.frame(colData(vst_data)[, annotation_vars, drop = FALSE])
  
  # --- NEW: Manually sort columns if cluster_cols is FALSE ---
  ordering_indices <- 1:ncol(plot_matrix) # Default order (as is)
  
  if (cluster_cols == FALSE && length(annotation_vars) > 0) {
    message(paste("Manual sorting of columns requested. Sorting by:", 
                  paste(annotation_vars, collapse = ", ")))
    
    # Get the full colData to sort by
    meta <- as.data.frame(colData(dds))
    
    # Create a list of columns to sort by (e.g., list(meta$water, meta$batch))
    sort_list <- lapply(annotation_vars, function(var) meta[[var]])
    
    # Get the ordering indices
    ordering_indices <- do.call(order, sort_list)
  }
  
  # Apply the new order to the matrix and annotation
  plot_matrix <- plot_matrix[, ordering_indices, drop = FALSE]
  annotation_col <- annotation_col[ordering_indices, , drop = FALSE]
  # --- END NEW SORTING LOGIC ---
  
  # Create row annotations and gaps
  # Create a vector of pathway names, repeated for each gene
  pathway_names <- rep(names(gene_list), lengths(gene_list))
  # Filter this vector to only include genes that are present
  pathway_names_present <- pathway_names[unlist(gene_list) %in% genes_present]
  
  annotation_row_df <- data.frame(
    Pathway = pathway_names_present
  )
  rownames(annotation_row_df) <- genes_present
  
  # Calculate gaps based on the *present* genes
  # Find the order of pathways based on the first gene appearance
  unique_pathways_ordered <- unique(pathway_names_present)
  # Table of counts, re-ordered
  present_lengths <- table(pathway_names_present)[unique_pathways_ordered]
  
  gaps_row <- cumsum(present_lengths)
  gaps_row <- gaps_row[-length(gaps_row)] # Remove last gap
  
  # Set colors
  heatmap_colors <- colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlBu")))(100)
  
  # Plot the heatmap
  pheatmap(
    plot_matrix,
    color = heatmap_colors,
    annotation_col = annotation_col,
    annotation_row = annotation_row_df,
    cluster_rows = FALSE,  # Keep pathway groups together
    cluster_cols = cluster_cols, # Allow clustering or keep sample groups
    show_colnames = FALSE, # Tidy up the plot
    show_rownames = TRUE,
    gaps_row = gaps_row,
    scale = "row",         # Scale by gene (Z-score), this is KEY
    main = main_title
  )
} 
```


```{r}
# ---  Usage ---

# 1. Run your analyses 

# Colonization (Batch 1 only)
colonization_output <- run_deseq_with_batch_correction(
  full_counts = filtered_raw_counts_matrix,
  full_meta = meta_table,
  target_tissue = "large_intestine",
  analysis_type = "Colonization"
)

# Sucrose (Both batches, batch-corrected design)
sucrose_output <- run_deseq_with_batch_correction(
  full_counts = filtered_raw_counts_matrix,
  full_meta = meta_table,
  target_tissue = "large_intestine",
  analysis_type = "Sucrose"
)
```




```{r}
#' Get a single vector of leading edge genes from an fgsea result
#'
#' @param fgsea_res The result object from running fgsea()
#' @param pathway_name The exact name of the pathway (e.g., "HALLMARK_MYC_TARGETS_V1")
#' @return A character vector of gene symbols in the leading edge.
get_leading_edge <- function(fgsea_res, pathway_name) {
  
  # Find the pathway in the results
  pathway_data <- fgsea_res %>% 
    as_tibble() %>% 
    filter(pathway == pathway_name)
  
  if (nrow(pathway_data) == 0) {
    message("Warning: Pathway '", pathway_name, "' not found.")
    return(character(0)) # Return empty vector
  }
  
  # The leadingEdge column is a list, so unlist the first (and only) element
  return(unlist(pathway_data$leadingEdge))
}


#' Create gene list of shared Alarm and Brakes/Gas genes from GSEA results
#'
#' @param fgsea_res_col The fgsea results for the Colonization contrast
#' @param fgsea_res_suc The fgsea results for the Sucrose contrast
#' @return A named list ("Interferon (Alarm)", "Cell Cycle (Brakes/Gas)")
#'         containing the shared leading edge genes for those pathways.
create_heatmap_genelist_from_gsea <- function(fgsea_res_col, fgsea_res_suc) {
  
  # --- 1. Define Pathway Names ---
  alarm_pathways <- c("HALLMARK_ALLOGRAFT_REJECTION", 
                      "HALLMARK_INTERFERON_GAMMA_RESPONSE")
  
  brakes_gas_pathways <- c("HALLMARK_MYC_TARGETS_V1", 
                           "HALLMARK_E2F_TARGETS")
  
  # --- 2. Get ALARM (Interferon) Genes ---
  # Get all leading edge genes from these pathways for both contrasts
  alarm_col <- unlist(lapply(alarm_pathways, get_leading_edge, fgsea_res = fgsea_res_col))
  alarm_suc <- unlist(lapply(alarm_pathways, get_leading_edge, fgsea_res = fgsea_res_suc))
  
  # Find the genes that are in the leading edge for *both* contrasts
  shared_alarm_genes <- intersect(alarm_col, alarm_suc) %>% unique()
  
  if (length(shared_alarm_genes) == 0) {
    message("Warning: No shared leading-edge 'Alarm' (Interferon) genes found.")
  }
  
  # --- 3. Get BRAKES/GAS (Cell Cycle) Genes ---
  # Get all leading edge genes from these pathways for both contrasts
  brakes_gas_col <- unlist(lapply(brakes_gas_pathways, get_leading_edge, fgsea_res = fgsea_res_col))
  brakes_gas_suc <- unlist(lapply(brakes_gas_pathways, get_leading_edge, fgsea_res = fgsea_res_suc))
  
  # Find the genes that are in the leading edge for *both* contrasts
  shared_brakes_gas_genes <- intersect(brakes_gas_col, brakes_gas_suc) %>% unique()
  
  if (length(shared_brakes_gas_genes) == 0) {
    message("Warning: No shared leading-edge 'Brakes/Gas' (Myc/E2F) genes found.")
  }

  # --- 4. Create the final list ---
  final_gene_list <- list(
    "Interferon" = shared_alarm_genes,
    "Cell proliferation" = shared_brakes_gas_genes
  )
  
  message("Gene list created.")
  message(paste("  Found", length(shared_alarm_genes), "shared Alarm genes."))
  message(paste("  Found", length(shared_brakes_gas_genes), "shared Brakes/Gas genes."))
  
  return(final_gene_list)
}

# --- Example Usage ---


# Now, run this new function to get your *actual* gene list
my_gene_list <- create_heatmap_genelist_from_gsea(
  fgsea_res_col = fgsea_res_li_col,
  fgsea_res_suc = fgsea_res_li_suc
)
```

```{r}
# 3. Plot Heatmap 1: Colonization
plot_pathway_heatmap(
  dds = colonization_output$dds,
  gene_list = my_gene_list,
  annotation_vars = c("treatment"),
  main_title = "Colonization Effect (Batch 1 Only)"
)

# # --- Sucrose Heatmap (Both Batches, Corrected) ---

# Plot heatmap
# 'dds' object has ~ batch + water, so batch correction is APPLIED
plot_pathway_heatmap(
  dds = sucrose_output$dds,
  gene_list = my_gene_list,
  annotation_vars = c( "water", "batch"),
  main_title = "LI Sucrose Effect (Batch Corrected)",
  cluster_cols = F
)
```


# assemble  

```{r}
final_plot <- plot_grid( p_si_col ,  p_li_col ,
                      plot_si_col, plot_li_col,    
                      Bcell_heatmap$gtable, Li_Inflammation$gtable,
                nrow  = 3,
                rel_heights = c(1,1,3),
                labels = 'auto',
                align = 'vh', axis = '')

title <- ggdraw() + 
  draw_label("Rebuttal Fig X",fontface = 'bold', x = 0,hjust = 0) +
  theme(plot.margin = margin(0, 0, 0, 0))


combined <- plot_grid(
  title, final_plot,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.1, 1)
) +theme(plot.margin = unit(c(1,1,1,1), "cm"))

ggsave('../data/R49_GF_mouse_RNA_seq_all.pdf',
      width = 15, height = 24, units = "in", device = 'pdf', 
      dpi = 300)  
```
